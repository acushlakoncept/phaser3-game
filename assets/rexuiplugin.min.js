!(function (t, e) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = e() : typeof define === 'function' && define.amd ? define(e) : (t = typeof globalThis !== 'undefined' ? globalThis : t || self).rexuiplugin = e(); }(this, () => {
  function k(t) { return (k = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? function (t) { return typeof t; } : function (t) { return t && typeof Symbol === 'function' && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t; })(t); } function B(t, e) { if (!(t instanceof e)) throw new TypeError('Cannot call a class as a function'); } function n(t, e) { for (let i = 0; i < e.length; i++) { const n = e[i]; n.enumerable = n.enumerable || !1, n.configurable = !0, 'value' in n && (n.writable = !0), Object.defineProperty(t, n.key, n); } } function w(t, e, i) { return e && n(t.prototype, e), i && n(t, i), t; } function i(t, e) { if (typeof e !== 'function' && e !== null) throw new TypeError('Super expression must either be null or a function'); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), e && s(t, e); } function p(t) { return (p = Object.setPrototypeOf ? Object.getPrototypeOf : function (t) { return t.__proto__ || Object.getPrototypeOf(t); })(t); } function s(t, e) { return (s = Object.setPrototypeOf || function (t, e) { return t.__proto__ = e, t; })(t, e); } function _(t) { if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return t; } function S(r) { const o = (function () { if (typeof Reflect === 'undefined' || !Reflect.construct) return !1; if (Reflect.construct.sham) return !1; if (typeof Proxy === 'function') return !0; try { return Date.prototype.toString.call(Reflect.construct(Date, [], () => {})), !0; } catch (t) { return !1; } }()); return function () { let t; let e; let i; const n = p(r); if (o) { const s = p(this).constructor; t = Reflect.construct(n, arguments, s); } else t = n.apply(this, arguments); return e = this, !(i = t) || typeof i !== 'object' && typeof i !== 'function' ? _(e) : i; }; } function l(t, e) { for (;!Object.prototype.hasOwnProperty.call(t, e) && (t = p(t)) !== null;);return t; } function g(t, e, i) { return (g = typeof Reflect !== 'undefined' && Reflect.get ? Reflect.get : function (t, e, i) { const n = l(t, e); if (n) { const s = Object.getOwnPropertyDescriptor(n, e); return s.get ? s.get.call(i) : s.value; } })(t, e, i || t); } function r(t, e, i, n) {
    return (r = typeof Reflect !== 'undefined' && Reflect.set ? Reflect.set : function (t, e, i, n) {
      let s; let r; let o; let a; const h = l(t, e); if (h) { if ((s = Object.getOwnPropertyDescriptor(h, e)).set) return s.set.call(n, i), !0; if (!s.writable) return !1; } if (s = Object.getOwnPropertyDescriptor(n, e)) { if (!s.writable) return !1; s.value = i, Object.defineProperty(n, e, s); } else {
        a = i, (o = e) in (r = n) ? Object.defineProperty(r, o, {
          value: a, enumerable: !0, configurable: !0, writable: !0,
        }) : r[o] = a;
      } return !0;
    })(t, e, i, n);
  } function e(t, e, i, n, s) { if (!r(t, e, i, n || t) && s) throw new Error('failed to set property'); return i; } function O(t) { return (function (t) { if (Array.isArray(t)) return t; }(t)) || o(t) || a(t) || (function () { throw new TypeError('Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function h(t) { return (function (t) { if (Array.isArray(t)) return u(t); }(t)) || o(t) || a(t) || (function () { throw new TypeError('Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.'); }()); } function o(t) { if (typeof Symbol !== 'undefined' && Symbol.iterator in Object(t)) return Array.from(t); } function a(t, e) { if (t) { if (typeof t === 'string') return u(t, e); let i = Object.prototype.toString.call(t).slice(8, -1); return i === 'Object' && t.constructor && (i = t.constructor.name), i === 'Map' || i === 'Set' ? Array.from(t) : i === 'Arguments' || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i) ? u(t, e) : void 0; } } function u(t, e) { (e == null || e > t.length) && (e = t.length); for (var i = 0, n = new Array(e); i < e; i++)n[i] = t[i]; return n; } function v(t, e, i) { const n = i.length; if (n >= 2) { const s = i[n - 2]; const r = i[n - 1]; if (t === s && e === r) return i; } return i.push(t, e), i; } function f(t, e, i, n, s, r, o, a, h) { let l; let u; let c; o && (r += 360), s = T(s); for (let d = ((r = T(r)) - s) / a, f = 0; f <= a; f++)c = s + d * f, l = t + i * Math.cos(c), u = e + n * Math.sin(c), v(l, u, h); return h; } const c = (function () { function i(t) { B(this, i), this.scene = t; } return w(i, null, [{ key: 'register', value(t, e) { i.prototype[t] = e; } }]), i; }()); const d = Phaser.Utils.Objects.GetValue; const C = (function () { function r(t, e, i, n, s) { B(this, r), this.cornerRadius = {}, this._width = 0, this._height = 0, this.setTo(t, e, i, n, s); } return w(r, [{ key: 'setTo', value(t, e, i, n, s) { return this.setPosition(t, e), this.setRadius(s), this.setSize(i, n), this; } }, { key: 'setPosition', value(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this; } }, { key: 'setRadius', value(t) { let e; let i; void 0 === t && (t = 0), i = typeof t === 'number' ? e = t : (e = d(t, 'x', 0), d(t, 'y', 0)); const n = this.cornerRadius; return n.tl = m(d(t, 'tl', void 0), e, i), n.tr = m(d(t, 'tr', void 0), e, i), n.bl = m(d(t, 'bl', void 0), e, i), n.br = m(d(t, 'br', void 0), e, i), this; } }, { key: 'setSize', value(t, e) { return this.width = t, this.height = e, this; } }, { key: 'minWidth', get() { const t = this.cornerRadius; return Math.max(t.tl.x + t.tr.x, t.bl.x + t.br.x); } }, { key: 'minHeight', get() { const t = this.cornerRadius; return Math.max(t.tl.y + t.bl.y, t.tr.y + t.br.y); } }, { key: 'width', get() { return this._width; }, set(t) { t == null && (t = 0), this._width = Math.max(t, this.minWidth); } }, { key: 'height', get() { return this._height; }, set(t) { t == null && (t = 0), this._height = Math.max(t, this.minHeight); } }, { key: 'radius', get() { const t = this.cornerRadius; return Math.max(t.tl.x, t.tl.y, t.tr.x, t.tr.y, t.bl.x, t.bl.y, t.br.x, t.br.y); } }]), r; }()); var m = function (t, e, i) { return void 0 === t ? { x: e, y: i } : typeof t === 'number' ? { x: t, y: t } : t; }; const b = Math.PI / 180; var T = function (t) { return t * b; }; const P = t; function t(t, e, i) { i = i || 2; let n; let s; let r; let o; let a; let h; let l; const u = e && e.length; const c = u ? e[0] * i : t.length; let d = M(t, 0, c, i, !0); const f = []; if (!d || d.next === d.prev) return f; if (u && (d = (function (t, e, i, n) { let s; let r; let o; let a; let h; const l = []; for (s = 0, r = e.length; s < r; s++)o = e[s] * n, a = s < r - 1 ? e[s + 1] * n : t.length, (h = M(t, o, a, n, !1)) === h.next && (h.steiner = !0), l.push(A(h)); for (l.sort(R), s = 0; s < l.length; s++)L(l[s], i), i = E(i, i.next); return i; }(t, e, d, i))), t.length > 80 * i) { n = r = t[0], s = o = t[1]; for (let v = i; v < c; v += i)(a = t[v]) < n && (n = a), (h = t[v + 1]) < s && (s = h), r < a && (r = a), o < h && (o = h); l = (l = Math.max(r - n, o - s)) !== 0 ? 1 / l : 0; } return z(d, f, i, n, s, l), f; } function M(t, e, i, n, s) { let r; let o; if (s === Z(t, e, i, n) > 0) for (r = e; r < i; r += n)o = N(r, t[r], t[r + 1], o); else for (r = i - n; e <= r; r -= n)o = N(r, t[r], t[r + 1], o); return o && U(o, o.next) && (J(o), o = o.next), o; } function E(t, e) { if (!t) return t; e = e || t; let i; let n = t; do { if (i = !1, n.steiner || !U(n, n.next) && H(n.prev, n, n.next) !== 0)n = n.next; else { if (J(n), (n = e = n.prev) === n.next) break; i = !0; } } while (i || n !== e);return e; } function z(t, e, i, n, s, r, o) { if (t) { !o && r && (function (t, e, i, n) { let s = t; for (;s.z === null && (s.z = F(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next, s !== t;);s.prevZ.nextZ = null, s.prevZ = null, (function (t) { let e; let i; let n; let s; let r; let o; let a; let h; let l = 1; do { for (i = t, r = t = null, o = 0; i;) { for (o++, n = i, e = a = 0; e < l && (a++, n = n.nextZ); e++);for (h = l; a > 0 || h > 0 && n;)a !== 0 && (h === 0 || !n || i.z <= n.z) ? (i = (s = i).nextZ, a--) : (n = (s = n).nextZ, h--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s; i = n; }r.nextZ = null, l *= 2; } while (o > 1); }(s)); }(t, n, s, r)); for (var a, h, l = t; t.prev !== t.next;) if (a = t.prev, h = t.next, r ? D(t, n, s, r) : j(t))e.push(a.i / i), e.push(t.i / i), e.push(h.i / i), J(t), t = h.next, l = h.next; else if ((t = h) === l) { o ? o === 1 ? z(t = I(t, e, i), e, i, n, s, r, 2) : o === 2 && Y(t, e, i, n, s, r) : z(E(t), e, i, n, s, r, 1); break; } } } function j(t) { const e = t.prev; const i = t; const n = t.next; if (!(H(e, i, n) >= 0)) { for (let s = t.next.next; s !== t.prev;) { if (X(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && H(s.prev, s, s.next) >= 0) return; s = s.next; } return 1; } } function D(t, e, i, n) { const s = t.prev; const r = t; const o = t.next; if (!(H(s, r, o) >= 0)) { for (var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x, h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y, l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x, u = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, c = F(a, h, e, i, n), d = F(l, u, e, i, n), f = t.prevZ, v = t.nextZ; f && f.z >= c && v && v.z <= d;) { if (f !== t.prev && f !== t.next && X(s.x, s.y, r.x, r.y, o.x, o.y, f.x, f.y) && H(f.prev, f, f.next) >= 0) return; if (f = f.prevZ, v !== t.prev && v !== t.next && X(s.x, s.y, r.x, r.y, o.x, o.y, v.x, v.y) && H(v.prev, v, v.next) >= 0) return; v = v.nextZ; } for (;f && f.z >= c;) { if (f !== t.prev && f !== t.next && X(s.x, s.y, r.x, r.y, o.x, o.y, f.x, f.y) && H(f.prev, f, f.next) >= 0) return; f = f.prevZ; } for (;v && v.z <= d;) { if (v !== t.prev && v !== t.next && X(s.x, s.y, r.x, r.y, o.x, o.y, v.x, v.y) && H(v.prev, v, v.next) >= 0) return; v = v.nextZ; } return 1; } } function I(t, e, i) { let n = t; do { const s = n.prev; const r = n.next.next; !U(s, r) && V(s, n, n.next, r) && W(s, r) && W(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), J(n), J(n.next), n = t = r), n = n.next; } while (n !== t);return n; } function Y(t, e, i, n, s, r) { let o; let a; let h = t; do { for (let l = h.next.next; l !== h.prev;) { if (h.i !== l.i && (a = l, (o = h).next.i !== a.i && o.prev.i !== a.i && !(function (t, e) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && V(i, i.next, t, e)) return 1; i = i.next; } while (i !== t); }(o, a)) && W(o, a) && W(a, o) && (function (t, e) { let i = t; let n = !1; const s = (t.x + e.x) / 2; const r = (t.y + e.y) / 2; for (;i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next, i !== t;);return n; }(o, a)))) { let u = G(h, l); return h = E(h, h.next), u = E(u, u.next), z(h, e, i, n, s, r), void z(u, e, i, n, s, r); }l = l.next; }h = h.next; } while (h !== t); } function R(t, e) { return t.x - e.x; } function L(t, e) { if (e = (function (t, e) { let i; let n = e; const s = t.x; const r = t.y; let o = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= s && o < a) { if ((o = a) === s) { if (r === n.y) return n; if (r === n.next.y) return n.next; }i = n.x < n.next.x ? n : n.next; } }n = n.next; } while (n !== e);if (!i) return null; if (s === o) return i.prev; let h; const l = i; const u = i.x; const c = i.y; let d = 1 / 0; n = i.next; for (;n !== l;)s >= n.x && n.x >= u && s !== n.x && X(r < c ? s : o, r, u, c, r < c ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < d || h === d && n.x > i.x) && W(n, t) && (i = n, d = h), n = n.next; return i; }(t, e))) { const i = G(e, t); E(i, i.next); } } function F(t, e, i, n, s) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1; } function A(t) { for (var e = t, i = t; e.x < i.x && (i = e), (e = e.next) !== t;);return i; } function X(t, e, i, n, s, r, o, a) { return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0; } function H(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y); } function U(t, e) { return t.x === e.x && t.y === e.y; } function V(t, e, i, n) { return U(t, e) && U(i, n) || U(t, n) && U(i, e) || H(t, e, i) > 0 != H(t, e, n) > 0 && H(i, n, t) > 0 != H(i, n, e) > 0; } function W(t, e) { return H(t.prev, t, t.next) < 0 ? H(t, e, t.next) >= 0 && H(t, t.prev, e) >= 0 : H(t, e, t.prev) < 0 || H(t, t.next, e) < 0; } function G(t, e) { const i = new K(t.i, t.x, t.y); const n = new K(e.i, e.x, e.y); const s = t.next; const r = e.prev; return (t.next = e).prev = t, (i.next = s).prev = i, (n.next = i).prev = n, (r.next = n).prev = r, n; } function N(t, e, i, n) { const s = new K(t, e, i); return n ? (s.next = n.next, (s.prev = n).next.prev = s, n.next = s) : (s.prev = s).next = s, s; } function J(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ); } function K(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1; } function Z(t, e, i, n) { for (var s = 0, r = e, o = i - n; r < i; r += n)s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return s; }t.deviation = function (t, e, i, n) { const s = e && e.length; const r = s ? e[0] * i : t.length; let o = Math.abs(Z(t, 0, r, i)); if (s) for (var a = 0, h = e.length; a < h; a++) { const l = e[a] * i; const u = a < h - 1 ? e[a + 1] * i : t.length; o -= Math.abs(Z(t, l, u, i)); } let c = 0; for (a = 0; a < n.length; a += 3) { const d = n[a] * i; const f = n[a + 1] * i; const v = n[a + 2] * i; c += Math.abs((t[d] - t[v]) * (t[1 + f] - t[1 + d]) - (t[d] - t[f]) * (t[1 + v] - t[1 + d])); } return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o); }, t.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, s = 0; s < t.length; s++) { for (let r = 0; r < t[s].length; r++) for (let o = 0; o < e; o++)i.vertices.push(t[s][r][o]); s > 0 && (n += t[s - 1].length, i.holes.push(n)); } return i; }; function q(t, e, i, n, s) { const r = this.pipeline; const o = r._tempMatrix1; const a = r._tempMatrix2; const h = r._tempMatrix3; t.setPipeline(r), a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h); const l = e._displayOriginX; const u = e._displayOriginY; const c = n.alpha * e.alpha; e.isFilled && Q(r, h, e, c, l, u), e.isStroked && et(r, e, c, l, u); } const $ = Phaser.Renderer.WebGL.Utils; var Q = function (t, e, i, n, s, r) { for (let o = $.getTintAppendFloatAlphaAndSwap(i.fillColor, i.fillAlpha * n), a = i.pathData, h = i.pathIndexes, l = 0; l < h.length; l += 3) { const u = 2 * h[l]; const c = 2 * h[l + 1]; const d = 2 * h[l + 2]; const f = a[0 + u] - s; const v = a[1 + u] - r; const p = a[0 + c] - s; const g = a[1 + c] - r; const y = a[0 + d] - s; const m = a[1 + d] - r; const b = e.getX(f, v); const x = e.getY(f, v); const k = e.getX(p, g); const C = e.getY(p, g); const w = e.getX(y, m); const S = e.getY(y, m); t.setTexture2D(), t.batchTri(b, x, k, C, w, S, 0, 0, 1, 1, o, o, o, t.tintEffect); } }; const tt = Phaser.Renderer.WebGL.Utils; var et = function (t, e, i, n, s) { const r = t.strokeTint; const o = tt.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * i); r.TL = o, r.TR = o, r.BL = o, r.BR = o; const a = e.pathData; let h = a.length - 1; const l = e.lineWidth; const u = l / 2; let c = a[0] - n; let d = a[1] - s; e.closePath || (h -= 2); for (let f = 2; f < h; f += 2) { const v = a[f] - n; const p = a[f + 1] - s; t.setTexture2D(), t.batchLine(c, d, v, p, u, u, l, f - 2, !!e.closePath && f === h - 1), c = v, d = p; } }; const it = function (t, e, i, n) { const s = i || e.fillColor; const r = n || e.fillAlpha; const o = (16711680 & s) >>> 16; const a = (65280 & s) >>> 8; const h = 255 & s; t.fillStyle = `rgba(${o},${a},${h},${r})`; }; const nt = function (t, e, i, n) { const s = i || e.strokeColor; const r = n || e.strokeAlpha; const o = (16711680 & s) >>> 16; const a = (65280 & s) >>> 8; const h = 255 & s; t.strokeStyle = `rgba(${o},${a},${h},${r})`, t.lineWidth = e.lineWidth; }; const st = Phaser.Renderer.Canvas.SetTransform; const rt = { renderWebGL: q, renderCanvas(t, e, i, n, s) { const r = t.currentContext; if (st(t, r, e, n, s)) { const o = e._displayOriginX; const a = e._displayOriginY; const h = e.pathData; let l = h.length - 1; const u = h[0] - o; const c = h[1] - a; r.beginPath(), r.moveTo(u, c), e.closePath || (l -= 2); for (let d = 2; d < l; d += 2) { const f = h[d] - o; const v = h[d + 1] - a; r.lineTo(f, v); }r.closePath(), e.isFilled && (it(r, e), r.fill()), e.isStroked && (nt(r, e), r.stroke()), r.restore(); } } }; const ot = Phaser.Utils.Objects.GetValue; const at = (function () { i(d, Phaser.GameObjects.Shape); const c = S(d); function d(t, e, i, n, s, r, o, a) { let h; B(this, d), void 0 === e && (e = 0), void 0 === i && (i = 0); const l = ot(r, 'iteration', void 0); r = ot(r, 'radius', r); const u = new C(0, 0, n, s, r); return (h = c.call(this, t, 'RoundRectangle', u)).setIteration(l), h.setPosition(e, i), void 0 !== o && h.setFillStyle(o, a), h.updateDisplayOrigin(), h.updateData(), h; } return w(d, [{ key: 'updateData', value() { const t = this.geom; const e = this.pathData; e.length = 0; let i; const n = t.cornerRadius; const s = this.iteration + 1; if (i = n.br, ht(i)) { var r = t.width - i.x; var o = t.height - i.y; f(r, o, i.x, i.y, 0, 90, !1, s, e); } else v(t.width, t.height, e); if (i = n.bl, ht(i)) { r = i.x, o = t.height - i.y; f(r, o, i.x, i.y, 90, 180, !1, s, e); } else v(0, t.height, e); if (i = n.tl, ht(i)) { r = i.x, o = i.y; f(r, o, i.x, i.y, 180, 270, !1, s, e); } else v(0, 0, e); if (i = n.tr, ht(i)) { r = t.width - i.x, o = i.y; f(r, o, i.x, i.y, 270, 360, !1, s, e); } else v(t.width, 0, e); return e.push(e[0], e[1]), this.pathIndexes = P(e), this; } }, { key: 'resize', value(t, e) { if (void 0 === e && (e = t), this.geom.width === t && this.geom.height === e) return this; this.geom.height = e, this.geom.width = t, this.updateDisplayOrigin(), this.updateData(); const i = this.input; return i && !i.customHitArea && (i.hitArea.width = t, i.hitArea.height = e), this; } }, { key: 'setIteration', value(t) { return void 0 === t && (t = 6), this.iteration = t, this; } }, { key: 'setRadius', value(t) { return void 0 === t && (t = 0), this.radius = t, this; } }, { key: 'setCornerRadius', value(t) { return this.setRadius(t); } }, { key: 'width', get() { return this.geom.width; }, set(t) { this.resize(t, this.height); } }, { key: 'height', get() { return this.geom.height; }, set(t) { this.resize(this.width, t); } }, { key: 'iteration', get() { return this._iteration; }, set(t) { void 0 !== this._iteration ? this._iteration !== t && (this._iteration = t, this.updateData()) : this._iteration = t; } }, { key: 'radius', get() { return this.geom.radius; }, set(t) { this.geom.setRadius(t), this.updateDisplayOrigin(), this.updateData(); } }, { key: 'cornerRadius', get() { return this.geom.cornerRadius; }, set(t) { this.radius = t; } }]), d; }()); var ht = function (t) { return t.x !== 0 && t.y !== 0; }; Object.assign(at.prototype, rt); function lt(t) { return t == null || t === '' || t.length === 0; } function ut(t, e, i) { if (k(t) === 'object') { if (lt(e)) { if (i == null) return; k(i) === 'object' && (t = i); } else { typeof e === 'string' && (e = e.split('.')); const n = e.pop(); (function (t, e, i) { let n = t; if (!lt(e)) { let s; typeof e === 'string' && (e = e.split('.')); for (let r = 0, o = e.length; r < o; r++) { var a; if (n[s = e[r]] == null || k(n[s]) !== 'object')a = r !== o - 1 || void 0 === i ? {} : i, n[s] = a; n = n[s]; } } return n; }(t, e))[n] = i; } return t; } }c.register('roundRectangle', function (t, e, i, n, s, r, o) { const a = new at(this.scene, t, e, i, n, s, r, o); return this.scene.add.existing(a), a; }), ut(window, 'RexPlugins.UI.RoundRectangle', at); function ct(t) { const e = mt.create(this); const i = e.getContext('2d'); t.syncFont(e, i); const n = i.measureText(t.testString); if (n.hasOwnProperty('actualBoundingBoxAscent') && n.hasOwnProperty('actualBoundingBoxDescent')) { const s = n.actualBoundingBoxAscent; const r = n.actualBoundingBoxDescent; var o = { ascent: s, descent: r, fontSize: s + r }; return mt.remove(e), o; } const a = Math.ceil(n.width * t.baselineX); let h = a; const l = 2 * h; if (h = h * t.baselineY | 0, e.width = a, e.height = l, i.fillStyle = '#f00', i.fillRect(0, 0, a, l), i.font = t._font, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(t.testString, 0, h), o = { ascent: 0, descent: 0, fontSize: 0 }, !i.getImageData(0, 0, a, l)) return o.ascent = h, o.descent = h + 6, o.fontSize = o.ascent + o.descent, mt.remove(e), o; let u; let c; const d = i.getImageData(0, 0, a, l).data; const f = d.length; const v = 4 * a; let p = 0; let g = !1; for (u = 0; u < h; u++) { for (c = 0; c < v; c += 4) if (d[p + c] !== 255) { g = !0; break; } if (g) break; p += v; } for (o.ascent = h - u, p = f - v, g = !1, u = l; h < u; u--) { for (c = 0; c < v; c += 4) if (d[p + c] !== 255) { g = !0; break; } if (g) break; p -= v; } return o.descent = u - h, o.fontSize = o.ascent + o.descent, mt.remove(e), o; } function dt(t) { if (Array.isArray(t))t.length = 0; else for (const e in t) delete t[e]; } function ft(t, e) { const i = Array.isArray(t); if (void 0 === e ? e = i ? [] : {} : dt(e), i) { e.length = t.length; for (let n = 0, s = t.length; n < s; n++)e[n] = t[n]; } else for (const r in t)e[r] = t[r]; return e; } function vt() {} function pt(t, e, i, n, s) { n <= 0 && (i = qt); const r = te; if (ee.pushMultiple(r), !t || !t.length) return r; for (var o, a, h, l = t.split(Qt), u = 0, c = l.length; u < c; u++) if (o = l[u], h = u === c - 1 ? Jt : Kt, i !== qt) { var d; var f; if (a = u === 0 ? n - s : n, o.length <= 100) if ((x = e(o)) <= a) { r.push(ee.newline(o, x, h)); continue; } for (var v, p = '', g = '', y = 0, m = 0, b = (d = i === $t ? o.split(' ') : o).length; m < b; m++)f = d[m], i === $t ? (p += f, m < b - 1 && (p += ' ')) : p += f, a < (v = e(p)) && (m === 0 ? r.push(ee.newline('', 0, Zt)) : (r.push(ee.newline(g, y, Zt)), p = f, i === $t && m < b - 1 && (p += ' '), v = e(p)), a = n), g = p, y = v; r.push(ee.newline(g, y, h)); } else { var x = e(o); r.push(ee.newline(o, x, h)); } return r; } const gt = Phaser.Renderer.WebGL.Utils; const yt = { renderWebGL(t, e, i, n, s) { if (e.width !== 0 && e.height !== 0) { const r = e.frame; const o = r.width; const a = r.height; const h = gt.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, r.glTexture, o, a, e.x, e.y, o / e.style.resolution, a / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, o, a, h(e._tintTL, n.alpha * e._alphaTL), h(e._tintTR, n.alpha * e._alphaTR), h(e._tintBL, n.alpha * e._alphaBL), h(e._tintBR, n.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, n, s); } }, renderCanvas(t, e, i, n, s) { e.width !== 0 && e.height !== 0 && t.batchSprite(e, e.frame, n, s); } }; var mt = Phaser.Display.Canvas.CanvasPool; const bt = 0; const xt = 1; const kt = 2; const Ct = 0; const wt = 1; const St = 2; const Ot = /(?:\r\n|\r|\n)/; const Tt = Phaser.Utils.Objects.GetAdvancedValue; const Pt = Phaser.Utils.Objects.GetValue; const Mt = {
    backgroundColor: ['backgroundColor', null], fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], underlineColor: ['underline.color', '#000'], underlineThickness: ['underline.thickness', 0], underlineOffset: ['underline.offset', 0], halign: ['halign', 'left'], valign: ['valign', 'top'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], resolution: ['resolution', 0], lineSpacing: ['lineSpacing', 0], rtl: ['rtl', !1], testString: ['testString', '|MÃ‰qgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wrapMode: ['wrap.mode', 1], wrapWidth: ['wrap.width', 0],
  }; const Et = (function () { function n(t, e) { B(this, n), this.parent = t, this.backgroundColor, this.fontFamily, this.fontSize, this.fontStyle, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.underlineColor, this.underlineThickness, this.underlineOffset, this.halign, this.valign, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.lineSpacing, this.rtl, this.testString, this.baselineX, this.baselineY, this._font, this.setStyle(e, !1); const i = Pt(e, 'metrics', !1); this.metrics = i ? { ascent: Pt(i, 'ascent', 0), descent: Pt(i, 'descent', 0), fontSize: Pt(i, 'fontSize', 0) } : ct(this); } return w(n, [{ key: 'setStyle', value(t, e) { if (void 0 === e && (e = !0), t && t.hasOwnProperty('wrap')) { const i = t.wrap; if (i.hasOwnProperty('mode')) { const n = i.mode; typeof n === 'string' && (i.mode = zt[n]); } else i.hasOwnProperty('width') && (i.mode = 1); } for (const s in t && t.hasOwnProperty('fontSize') && typeof t.fontSize === 'number' && (t.fontSize = `${t.fontSize.toString()}px`), Mt) this[s] = (s === 'wrapCallback' || s === 'wrapCallbackScope' ? Pt : Tt)(t, Mt[s][0], Mt[s][1]); const r = Pt(t, 'font', null); this._font = r === null ? `${this.fontStyle} ${this.fontSize} ${this.fontFamily}` : r; const o = Pt(t, 'fill', null); return o !== null && (this.color = o), e ? this.update(!0) : this.parent; } }, { key: 'syncFont', value(t, e) { e.font = this._font; } }, { key: 'syncStyle', value(t, e) { e.textBaseline = 'alphabetic', e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = 'round', e.lineJoin = 'round'; } }, { key: 'syncShadow', value(t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0); } }, { key: 'update', value(t) { return t && (this._font = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`, this.metrics = ct(this)), this.parent.updateText(t); } }, { key: 'buildFont', value() { const t = `${this.fontStyle} ${this.fontSize} ${this.fontFamily}`; return t !== this._font && (this._font = t), this; } }, { key: 'setFont', value(t) { return typeof t === 'string' ? (this.fontFamily = t, this.fontSize = '', this.fontStyle = '') : (this.fontFamily = Pt(t, 'fontFamily', 'Courier'), this.fontSize = Pt(t, 'fontSize', '16px'), this.fontStyle = Pt(t, 'fontStyle', '')), this.update(!0); } }, { key: 'setFontFamily', value(t) { return this.fontFamily = t, this.update(!0); } }, { key: 'setFontStyle', value(t) { return this.fontStyle = t, this.update(!0); } }, { key: 'setFontSize', value(t) { return typeof t === 'number' && (t = `${t.toString()}px`), this.fontSize = t, this.update(!0); } }, { key: 'setTestString', value(t) { return this.testString = t, this.update(!0); } }, { key: 'setFixedSize', value(t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1); } }, { key: 'setResolution', value(t) { return this.resolution = t, this.update(!1); } }, { key: 'setLineSpacing', value(t) { return this.lineSpacing = t, this.update(!1); } }, { key: 'setBackgroundColor', value(t) { return this.backgroundColor = t, this.update(!1); } }, { key: 'setFill', value(t) { return this.color = t, this.update(!1); } }, { key: 'setColor', value(t) { return this.color = t, this.update(!1); } }, { key: 'setStroke', value(t, e) { return void 0 === t ? this.strokeThickness = 0 : (void 0 === e && (e = this.strokeThickness), this.stroke = t, this.strokeThickness = e), this.update(!0); } }, { key: 'setShadow', value(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = '#000'), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1); } }, { key: 'setShadowOffset', value(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1); } }, { key: 'setShadowColor', value(t) { return void 0 === t && (t = '#000'), this.shadowColor = t, this.update(!1); } }, { key: 'setShadowBlur', value(t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1); } }, { key: 'setShadowStroke', value(t) { return this.shadowStroke = t, this.update(!1); } }, { key: 'setShadowFill', value(t) { return this.shadowFill = t, this.update(!1); } }, { key: 'setUnderline', value(t, e, i) { return void 0 === t && (t = '#000'), void 0 === e && (e = 0), void 0 === i && (i = 0), this.underlineColor = t, this.underlineThickness = e, this.underlineOffset = i, this.update(!1); } }, { key: 'setUnderlineColor', value(t) { return void 0 === t && (t = '#000'), this.underlineColor = t, this.update(!1); } }, { key: 'setUnderlineThickness', value(t) { return void 0 === t && (t = 0), this.underlineThickness = t, this.update(!1); } }, { key: 'setUnderlineOffset', value(t) { return void 0 === t && (t = 0), this.underlineOffset = t, this.update(!1); } }, { key: 'setWrapMode', value(t) { return typeof t === 'string' && (t = zt[t.toLowerCase()] || 0), this.wrapMode = t, this.update(!0); } }, { key: 'setWrapWidth', value(t) { return this.wrapWidth = t, this.update(!1); } }, { key: 'setAlign', value(t, e) { return void 0 === t && (t = 'left'), void 0 === e && (e = 'top'), this.halign = t, this.valign = e, this.update(!1); } }, { key: 'setHAlign', value(t) { return void 0 === t && (t = 'left'), this.halign = t, this.update(!1); } }, { key: 'setVAlign', value(t) { return void 0 === t && (t = 'top'), this.valign = t, this.update(!1); } }, { key: 'setMaxLines', value(t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1); } }, { key: 'getTextMetrics', value() { const t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize }; } }, { key: 'toJSON', value() { const t = {}; for (const e in Mt)t[e] = this[e]; return t.metrics = this.getTextMetrics(), t; } }, { key: 'destroy', value() { this.parent = void 0; } }, { key: 'lineHeight', get() { return this.metrics.fontSize + this.strokeThickness + this.lineSpacing; } }]), n; }()); var zt = {
    none: Ct, word: wt, char: St, character: St,
  }; const Bt = {
    draw(t, e, i, n) { const s = this.penManager; this.hitAreaManager.clear(); const r = this.context; r.save(), this.drawBackground(this.defatultStyle.backgroundColor); const o = this.defatultStyle; t += this.startXOffset, e += this.startYOffset; let a; let h; let l; let u; let c; let d; const f = o.halign; const v = o.valign; const p = o.lineHeight; const g = s.lines; const y = g.length; const m = o.maxLines; u = (l = m > 0 && m < y ? (h = m, v === 'center' ? Math.floor((y - h) / 2) : v === 'bottom' ? y - h : 0) : (h = y, 0)) + h, d = v === 'center' ? Math.max((n - h * p) / 2, 0) : v === 'bottom' ? Math.max(n - h * p - 2, 0) : 0, d += e; for (let b = l; b < u; b++) if ((a = s.getLineWidth(b)) !== 0) { c = f === 'center' ? (i - a) / 2 : f === 'right' ? i - a : 0, c += t; for (let x = g[b], k = 0, C = x.length; k < C; k++) this.drawPen(x[k], c, d); }r.restore(); }, drawPen(t, e, i) { e += t.x, i += t.y; const n = this.canvas; const s = this.context; s.save(); const r = this.parser.propToContextStyle(this.defatultStyle, t.prop); r.buildFont(), r.syncFont(n, s), r.syncStyle(n, s), r.underlineThickness > 0 && t.width > 0 && this.drawUnderline(e, i, t.width, r), t.isTextPen && this.drawText(e, i, t.text, r), t.isImagePen && this.drawImage(e, i, t.prop.img, r), s.restore(), t.hasAreaMarker && t.width > 0 && this.hitAreaManager.add(t.prop.area, e, i - this.startYOffset, t.width, this.defatultStyle.lineHeight); }, clear() { const t = this.canvas; this.context.clearRect(0, 0, t.width, t.height); }, drawBackground(t) { t !== null && (this.context.fillStyle = t, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)); }, drawUnderline(t, e, i, n) { e += n.underlineOffset - n.underlineThickness / 2, this.autoRound && (t = Math.round(t), e = Math.round(e)); const s = this.context; const r = s.lineCap; s.lineCap = 'butt', s.beginPath(), s.strokeStyle = n.underlineColor, s.lineWidth = n.underlineThickness, s.moveTo(t, e), s.lineTo(t + i, e), s.stroke(), s.lineCap = r; }, drawText(t, e, i, n) { this.autoRound && (t = Math.round(t), e = Math.round(e)); const s = this.context; n.strokeThickness && (n.syncShadow(s, n.shadowStroke), s.strokeText(i, t, e)), n.color && n.color !== 'none' && (n.syncShadow(s, n.shadowFill), s.fillText(i, t, e)); }, drawImage(t, e, i) { const n = this.parent.imageManager; const s = n.get(i); const r = n.getFrame(i); t += s.left, e += -this.startYOffset + s.y, this.autoRound && (t = Math.round(t), e = Math.round(e)), this.context.drawImage(r.source.image, r.cutX, r.cutY, r.cutWidth, r.cutHeight, t, e, s.width, s.height); },
  }; const _t = (function () { function t() { B(this, t), this.items = []; } return w(t, [{ key: 'destroy', value() { this.clear(), this.items = void 0; } }, { key: 'pop', value() { return this.items.length > 0 ? this.items.pop() : null; } }, { key: 'push', value(t) { return this.items.push(t), this; } }, { key: 'pushMultiple', value(t) { return this.items.push.apply(this.items, t), t.length = 0, this; } }, { key: 'clear', value() { return this.items.length = 0, this; } }]), t; }()); const jt = Phaser.Utils.Objects.GetValue; const Dt = bt; const It = xt; const Yt = (function () { function e(t) { B(this, e), this.prop = {}, this.resetFromJSON(t); } return w(e, [{ key: 'resetFromJSON', value(t) { this.text = jt(t, 'text', ''), this.x = jt(t, 'x', 0), this.y = jt(t, 'y', 0), this.width = jt(t, 'width', 0); let e = jt(t, 'prop', null); e === null && (e = {}), this.prop = e, this.newLineMode = jt(t, 'newLineMode', 0), this.startIndex = jt(t, 'startIndex', 0); } }, { key: 'plainText', get() { let t = this.text; return this.newLineMode === It && (t += '\n'), t; } }, { key: 'wrapText', get() { let t = this.text; return this.newLineMode !== Dt && (t += '\n'), t; } }, { key: 'rawTextLength', get() { let t = this.text.length; return this.newLineMode === It && (t += 1), t; } }, { key: 'endIndex', get() { return this.startIndex + this.rawTextLength; } }, { key: 'lastX', get() { return this.x + this.width; } }, { key: 'isTextPen', get() { return this.text !== ''; } }, { key: 'isImagePen', get() { return !!this.prop.img; } }, { key: 'hasAreaMarker', get() { return !!this.prop.area; } }]), e; }()); const Rt = Phaser.Utils.Objects.GetFastValue; const Lt = bt; const Ft = kt; const At = new _t(); const Xt = new _t(); const Ht = (function () { function a(t) { B(this, a), this.pens = [], this.lines = [], this.maxLinesWidth = void 0, this.PensPool = Rt(t, 'pensPool', At), this.LinesPool = Rt(t, 'linesPool', Xt), this.tagToText = Rt(t, 'tagToText', vt), this.tagToTextScope = Rt(t, 'tagToTextScope', void 0); } return w(a, [{ key: 'destroy', value() { this.freePens(), this.tagToText = void 0, this.tagToTextScope = void 0; } }, { key: 'freePens', value() { for (let t = 0, e = this.lines.length; t < e; t++) this.lines[t].length = 0; this.PensPool.pushMultiple(this.pens), this.LinesPool.pushMultiple(this.lines), this.maxLinesWidth = void 0; } }, { key: 'addTextPen', value(t, e, i, n, s, r) { let o = this.PensPool.pop(); return o == null && (o = new Yt()), Ut.text = t, Ut.x = e, Ut.y = i, Ut.width = n, Ut.prop = s, Ut.newLineMode = r, o.resetFromJSON(Ut), this.addPen(o), this; } }, { key: 'addImagePen', value(t, e, i, n) { return this.addTextPen('', t, e, i, n, Lt), this; } }, { key: 'addNewLinePen', value() { const t = this.lastPen; const e = t ? t.lastX : 0; const i = t ? t.y : 0; const n = t ? ft(t.prop) : null; return this.addTextPen('', e, i, 0, n, Ft), this; } }, { key: 'addPen', value(t) { const e = this.lastPen; t.startIndex = e == null ? 0 : e.endIndex, this.pens.push(t); let i = this.lastLine; i == null && (i = this.LinesPool.pop() || [], this.lines.push(i)), i.push(t), t.newLineMode !== Lt && (i = this.LinesPool.pop() || [], this.lines.push(i)), this.maxLinesWidth = void 0; } }, { key: 'clone', value(t) { t == null && (t = new a()), t.freePens(); for (let e = 0, i = this.lines.length; e < i; e++) for (let n = this.lines[e], s = 0, r = n.length; s < r; s++) { const o = n[s]; t.addPen(o.text, o.x, o.y, o.width, ft(o.prop), o.newLineMode); } return t; } }, { key: 'getLineStartIndex', value(t) { if (t >= this.lines.length) return this.getLineEndIndex(t); const e = this.lines[t]; return e && e[0] ? e[0].startIndex : 0; } }, { key: 'getLineEndIndex', value(t) { t >= this.lines.length && (t = this.lines.length - 1); let e; let i; let n = !1; for (e = t; e >= 0 && !(n = (i = this.lines[e]) != null && i.length > 0); e--);return n ? i[i.length - 1].endIndex : 0; } }, { key: 'getLineWidth', value(t) { const e = this.lines[t]; if (!e) return 0; const i = e[e.length - 1]; return i == null ? 0 : i.lastX; } }, { key: 'getMaxLineWidth', value() { if (void 0 !== this.maxLinesWidth) return this.maxLinesWidth; for (var t, e = 0, i = 0, n = this.lines.length; i < n; i++)e < (t = this.getLineWidth(i)) && (e = t); return this.maxLinesWidth = e; } }, { key: 'getLineWidths', value() { for (var t = [], e = 0, i = this.lines.length; e < i; e++)t.push(this.getLineWidth(e)); return t; } }, { key: 'getSliceTagText', value(t, e, i) { if (void 0 === t && (t = 0), void 0 === e) { const n = this.lastPen; if (n == null) return ''; e = n.endIndex; } void 0 === i && (i = !1); for (var s, r, o, a, h, l, u = '', c = 0, d = this.pens.length; c < d && ((a = (s = this.pens[c]).endIndex) <= t || (s = this.pens[c], r = i ? s.wrapText : s.plainText, h = s.prop, t <= (o = s.startIndex) && a <= e || (r = r.substring(t - o, e - o)), this.tagToTextScope ? u += this.tagToText.call(this.tagToTextScope, r, h, l) : u += this.tagToText(r, h, l), l = h, !(e <= a))); c++);return u; } }, { key: 'lastPen', get() { return this.pens[this.pens.length - 1]; } }, { key: 'lastLine', get() { return this.lines[this.lines.length - 1]; } }, { key: 'linesCount', get() { return this.lines.length; } }, { key: 'plainText', get() { for (var t = '', e = this.pens, i = 0, n = e.length; i < n; i++)t += e[i].plainText; return t; } }, { key: 'rawTextLength', get() { for (var t = 0, e = this.pens, i = 0, n = this.pens.length; i < n; i++)t += e[i].rawTextLength; return t; } }]), a; }()); var Ut = {}; const Vt = Phaser.Geom.Rectangle; const Wt = new _t(); const Gt = (function () { function t() { B(this, t), this.hitAreas = []; } return w(t, [{ key: 'destroy', value() { this.clear(); } }, { key: 'clear', value() { return Wt.pushMultiple(this.hitAreas), this; } }, { key: 'add', value(t, e, i, n, s) { let r = Wt.pop(); return r === null ? r = new Vt(e, i, n, s) : r.setTo(e, i, n, s), r.key = t, this.hitAreas.push(r), this; } }, { key: 'getFirstHitArea', value(t, e) { for (var i, n = this.hitAreas, s = 0, r = n.length; s < r; s++) if ((i = n[s]).contains(t, e)) return i; return null; } }, { key: 'drawBounds', value(t, e, i) { void 0 === e && (e = 16777215), i && t.save().scaleCanvas(i.scaleX, i.scaleY).rotateCanvas(i.rotation).translateCanvas(i.x, i.y); for (var n, s = this.hitAreas, r = 0, o = s.length; r < o; r++)n = s[r], t.lineStyle(1, e).strokeRect(n.x, n.y, n.width, n.height); return i && t.restore(), this; } }]), t; }()); const Nt = function (t, e, i, n) { const s = this.hitAreaManager.getFirstHitArea(i, n); if (s !== null) { const r = s.key; this.parent.emit(''.concat(t, '-').concat(r), e, i, n), this.parent.emit(t, r, e, i, n); } }; var Jt = bt; var Kt = xt; var Zt = kt; var qt = Ct; var $t = wt; var Qt = Ot; var te = []; var ee = new _t(); ee.newline = function (t, e, i) { let n = this.pop(); return n === null && (n = {}), n.text = t, n.width = e, n.newLineMode = i, n; }; const ie = Phaser.Utils.Objects.GetValue; const ne = Ct; const se = bt; const re = (function () { function i(t) { B(this, i), this.parent = t.parent, this.context = ie(t, 'context', null), this.canvas = this.context.canvas, this.parser = ie(t, 'parser', null), this.defatultStyle = ie(t, 'style', null), this.autoRound = !0, this.pensPool = ie(t, 'pensPool', null), this.penManager = this.newPenManager(), this._tmpPenManager = null, this.hitAreaManager = new Gt(); const e = this.context; this.getTextWidth = function (t) { return e.measureText(t).width; }; } return w(i, [{ key: 'destroy', value() { this.context = void 0, this.canvas = void 0, this.parser = void 0, this.defatultStyle = void 0, this.penManager && (this.penManager.destroy(), this.penManager = void 0), this._tmpPenManager && (this._tmpPenManager.destroy(), this._tmpPenManager = void 0), this.hitAreaManager && (this.hitAreaManager.destroy(), this.hitAreaManager = void 0); } }, { key: 'updatePenManager', value(t, e, i, n, s) { if (void 0 === s && (s = this.penManager), s.freePens(), t === '') return s; for (var r, o, a, h, l, u = this.canvas, c = this.context, d = 0, f = 0, v = this.parser.splitText(t), p = 0, g = v.length; p < g; p++) if (r = (h = this.parser.tagTextToProp(v[p], o)).plainText, (o = h.prop).img) { const y = this.imageManager.getOuterWidth(o.img); i > 0 && e !== ne && i < d + y && (s.addNewLinePen(), f += n, d = 0), s.addImagePen(d, f, y, ft(o)), d += y; } else if (r !== '') { var m; this.context.save(), (a = this.parser.propToContextStyle(this.defatultStyle, o)).buildFont(), a.syncFont(u, c), a.syncStyle(u, c); for (let b = 0, x = (l = pt(r, this.getTextWidth, e, i, d)).length; b < x; b++)m = l[b], s.addTextPen(m.text, d, f, m.width, ft(o), m.newLineMode), m.newLineMode !== se ? (d = 0, f += n) : d += m.width; this.context.restore(); } return s; } }, { key: 'newPenManager', value() { return new Ht({ pensPool: this.pensPool, tagToText: this.parser.propToTagText, tagToTextScope: this.parser }); } }, { key: 'getPlainText', value(t, e, i) { let n; if (t == null)n = this.penManager.plainText; else { const s = this.parser.splitText(t, 1); n = ''; for (let r = 0, o = s.length; r < o; r++)n += s[r]; } return e == null && i == null || (e == null && (e = 0), i == null && (i = n.length), n = n.substring(e, i)), n; } }, { key: 'getPenManager', value(t, e) { if (void 0 === t) return this.copyPenManager(e, this.penManager); void 0 === e && (e = this.newPenManager()); const i = this.defatultStyle; return this.updatePenManager(t, i.wrapMode, i.wrapWidth, i.lineHeight, e), e; } }, { key: 'getText', value(t, e, i, n) { if (t == null) return this.penManager.getSliceTagText(e, i, n); const s = this.tmpPenManager; const r = this.defatultStyle; return this.updatePenManager(t, r.wrapMode, r.wrapWidth, r.lineHeight, s), s.getSliceTagText(e, i, n); } }, { key: 'copyPenManager', value(t, e) { return void 0 === e && (e = this.penManager), e.copy(t); } }, { key: 'getTextWidth', value(t) { return void 0 === t && (t = this.penManager), t.getMaxLineWidth(); } }, { key: 'getLastPen', value(t) { return void 0 === t && (t = this.penManager), t.lastPen; } }, { key: 'startXOffset', get() { return this.defatultStyle.strokeThickness / 2; } }, { key: 'startYOffset', get() { const t = this.defatultStyle; return t.strokeThickness / 2 + t.metrics.ascent; } }, { key: 'lines', get() { return this.penManager.lines; } }, { key: 'desplayLinesCount', get() { let t = this.penManager.linesCount; const e = this.defatultStyle.maxLines; return e > 0 && e < t && (t = e), t; } }, { key: 'linesWidth', get() { return this.penManager.getMaxLineWidth(); } }, { key: 'linesHeight', get() { const t = this.desplayLinesCount; let e = this.defatultStyle.lineHeight * t; return t > 0 && (e -= this.defatultStyle.lineSpacing), e; } }, { key: 'imageManager', get() { return this.parent.imageManager; } }, { key: 'tmpPenManager', get() { return this._tmpPenManager === null && (this._tmpPenManager = this.newPenManager()), this._tmpPenManager; } }]), i; }()); const oe = { setInteractive() { this.parent.on('pointerdown', function (t, e, i, n) { Nt.call(this, 'areadown', t, e, i); }, this).on('pointerup', function (t, e, i, n) { Nt.call(this, 'areaup', t, e, i); }, this); } }; Object.assign(re.prototype, Bt, oe); let ae; const he = Phaser.Utils.Objects.GetValue; const le = (function () {
    function e(t) { B(this, e), this.textureManager = t, this.images = {}; } return w(e, [{ key: 'add', value(t, e) { if (typeof t === 'string') this._add(t, e); else if (Array.isArray(t)) for (let i = 0, n = (s = t).length; i < n; i++) this._add(s[i]); else { var s = t; for (var t in s) this._add(t, s[t]); } return this; } }, {
      key: '_add',
      value(t, e) {
        void 0 === e && (e = { key: t }); const i = e.key; const n = e.frame; let s = e.width; let r = e.height; if (void 0 === s || void 0 === r) { const o = this.textureManager.getFrame(i, n); const a = o ? o.cutWidth : 0; const h = o ? o.cutHeight : 0; void 0 === s && void 0 === r ? (s = a, r = h) : void 0 === s ? s = a * (r / h) : void 0 === r && (r = h * (s / a)); } this.images[t] = {
          key: i, frame: n, width: s, height: r, y: he(e, 'y', 0), left: he(e, 'left', 0), right: he(e, 'right', 0),
        };
      },
    }, { key: 'remove', value(t) { return this.images.hasOwnProperty(t) && delete this.images[t], this; } }, { key: 'get', value(t) { return this.images.hasOwnProperty(t) || this.textureManager.exists(t) && this.add(t), this.images[t]; } }, { key: 'getOuterWidth', value(t) { const e = this.get(t); return e ? e.width + e.left + e.right : 0; } }, { key: 'getFrame', value(t) { const e = this.get(t); return e ? this.textureManager.getFrame(e.key, e.frame) : void 0; } }, { key: 'hasTexture', value(t) { return !!this.getFrame(t); } }]), e;
  }()); const ue = Phaser.DOM.AddToDOM; const ce = Phaser.Display.Canvas.CanvasPool; const de = Phaser.GameObjects.GameObject; const fe = Phaser.Utils.Objects.GetValue; const ve = Phaser.DOM.RemoveFromDOM; const pe = Ot; const ge = {}; const ye = (function () {
    i(u, de); const l = S(u); function u(t, e, i, n, s, r, o) {
      let a; if (B(this, u), void 0 === e && (e = 0), void 0 === i && (i = 0), (a = l.call(this, t, r)).renderer = t.sys.game.renderer, a.setPosition(e, i), a.setOrigin(0, 0), a.initPipeline(), a.canvas = ce.create(_(a)), a.context = a.canvas.getContext('2d'), s) { if (s.hasOwnProperty('align')) { const h = s.align; delete s.align, s.halign = h; }s.hasOwnProperty('stroke') && !s.hasOwnProperty('strokeThickness') && (s.strokeThickness = 1); } return a.style = new Et(_(a), s), a.autoRound = !0, a._text = void 0, a.padding = {
        left: 0, right: 0, top: 0, bottom: 0,
      }, a.width = 1, a.height = 1, a.dirty = !1, a.style.resolution === 0 && (a.style.resolution = t.sys.game.config.resolution), a._crop = a.resetCropObject(), a.texture = t.sys.textures.addCanvas(null, a.canvas, !0), a.frame = a.texture.get(), a.frame.source.resolution = a.style.resolution, a.renderer.gl && (a.renderer.deleteTexture(a.frame.source.glTexture), a.frame.source.glTexture = null), ge.hasOwnProperty(r) || (ge[r] = new _t()), a.canvasText = new re({
        parent: _(a), context: a.context, parser: o, style: a.style, pensPool: ge[r],
      }), s && s.padding && a.setPadding(s.padding), a.setText(n), t.sys.game.events.on('contextrestored', function () { this.dirty = !0; }, _(a)), a;
    } return w(u, [{ key: 'initRTL', value() { this.style.rtl && (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', ue(this.canvas, this.scene.sys.canvas), this.originX = 1); } }, { key: 'setText', value(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this._text && (this._text = t.toString(), this.updateText()), this; } }, { key: 'setStyle', value(t) { return this.style.setStyle(t); } }, { key: 'setFont', value(t) { return this.style.setFont(t); } }, { key: 'setFontFamily', value(t) { return this.style.setFontFamily(t); } }, { key: 'setFontSize', value(t) { return this.style.setFontSize(t); } }, { key: 'setFontStyle', value(t) { return this.style.setFontStyle(t); } }, { key: 'setFixedSize', value(t, e) { return this.style.setFixedSize(t, e); } }, { key: 'setBackgroundColor', value(t) { return this.style.setBackgroundColor(t); } }, { key: 'setFill', value(t) { return this.style.setFill(t); } }, { key: 'setColor', value(t) { return this.style.setColor(t); } }, { key: 'setStroke', value(t, e) { return this.style.setStroke(t, e); } }, { key: 'setShadow', value(t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r); } }, { key: 'setShadowOffset', value(t, e) { return this.style.setShadowOffset(t, e); } }, { key: 'setShadowColor', value(t) { return this.style.setShadowColor(t); } }, { key: 'setShadowBlur', value(t) { return this.style.setShadowBlur(t); } }, { key: 'setShadowStroke', value(t) { return this.style.setShadowStroke(t); } }, { key: 'setShadowFill', value(t) { return this.style.setShadowFill(t); } }, { key: 'setWrapMode', value(t) { return this.style.setWrapMode(t); } }, { key: 'setWrapWidth', value(t) { return this.style.setWrapWidth(t); } }, { key: 'setAlign', value(t) { return this.style.setHAlign(t); } }, { key: 'setLineSpacing', value(t) { return this.style.setLineSpacing(t); } }, { key: 'setPadding', value(t, e, i, n) { if (k(t) === 'object') { const s = t; const r = fe(s, 'x', null); i = r !== null ? t = r : (t = fe(s, 'left', 0), fe(s, 'right', t)); const o = fe(s, 'y', null); n = o !== null ? e = o : (e = fe(s, 'top', 0), fe(s, 'bottom', e)); } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(!1); } }, { key: 'setResolution', value(t) { return this.style.setResolution(t); } }, { key: 'setMaxLines', value(t) { return this.style.setMaxLines(t); } }, { key: 'updateText', value(t) { void 0 === t && (t = !0); const e = this.canvasText; const i = this.style; t && e.updatePenManager(this._text, i.wrapMode, i.wrapWidth, i.lineHeight); let n; let s; const r = this.padding; i.fixedWidth === 0 ? (this.width = e.linesWidth + r.left + r.right, n = e.linesWidth) : (this.width = i.fixedWidth, (n = this.width - r.left - r.right) < e.linesWidth && (n = e.linesWidth)), i.fixedHeight === 0 ? (this.height = e.linesHeight + r.top + r.bottom, s = e.linesHeight) : (this.height = i.fixedHeight, (s = this.height - r.top - r.bottom) < e.linesHeight && (s = e.linesHeight)); let o = this.width; let a = this.height; this.updateDisplayOrigin(); const h = i.resolution; o *= h, a *= h, o = Math.max(Math.ceil(o), 1), a = Math.max(Math.ceil(a), 1); const l = this.canvas; const u = this.context; l.width !== o || l.height !== a ? (l.width = o, l.height = a, this.frame.setSize(o, a)) : u.clearRect(0, 0, o, a), u.save(), u.scale(h, h), e.draw(r.left, r.top, n, s), u.restore(), this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(l, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0; const c = this.input; return c && !c.customHitArea && (c.hitArea.width = this.width, c.hitArea.height = this.height), this; } }, { key: 'getTextMetrics', value() { return this.style.getTextMetrics(); } }, {
      key: 'toJSON',
      value() {
        const t = me.ToJSON(this); const e = {
          autoRound: this.autoRound,
          text: this._text,
          style: this.style.toJSON(),
          resolution: this.resolution,
          padding: {
            left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom,
          },
        }; return t.data = e, t;
      },
    }, { key: 'preDestroy', value() { this.style.rtl && ve(this.canvas), ce.remove(this.canvas), this.canvasText.destroy(); } }, { key: 'setInteractive', value(t, e, i) { return de.prototype.setInteractive.call(this, t, e, i), this.canvasText.setInteractive(), this; } }, { key: 'getWrappedText', value(t, e, i) { return (t = this.canvasText.getText(t, e, i, !0)).split(pe); } }, { key: 'getPlainText', value(t, e, i) { return this.canvasText.getPlainText(t, e, i); } }, { key: 'getText', value(t, e, i) { return this.canvasText.getText(t, e, i, !1); } }, { key: 'getSubString', value(t, e, i) { return this.getText(t, e, i); } }, { key: 'copyPenManager', value(t) { return this.canvasText.copyPenManager(t); } }, { key: 'getPenManager', value(t, e) { return this.canvasText.getPenManager(t, e); } }, { key: 'setSize', value(t, e) { return this.setFixedSize(t, e); } }, { key: 'resize', value(t, e) { return this.setFixedSize(t, e); } }, { key: 'addImage', value(t, e) { return this.imageManager.add(t, e), this; } }, { key: 'drawAreaBounds', value(t, e) { return this.canvasText.hitAreaManager.drawBounds(t, e, this), this; } }, { key: 'text', set(t) { this.setText(t); }, get() { return this._text; } }, { key: 'lineSpacing', set(t) { this.setLineSpacing(t); }, get() { return this.style.lineSpacing; } }, { key: 'imageManager', get() { return t = this.scene.textures, void 0 === ae && (ae = new le(t)), ae; let t; } }]), u;
  }()); var me = Phaser.GameObjects.Components; Phaser.Class.mixin(ye, [me.Alpha, me.BlendMode, me.ComputedSize, me.Crop, me.Depth, me.Flip, me.GetBounds, me.Mask, me.Origin, me.Pipeline, me.ScrollFactor, me.Tint, me.Transform, me.Visible, yt]); const be = { plainText: null, prevProp: null }; const xe = new Et(); const ke = {}; const Ce = {
    splitText(t, e) { for (var i, n, s = [], r = 0, o = t.length, a = o; i = Oe.exec(t);)n = i[0], r < (a = Oe.lastIndex - n.length) && s.push(t.substring(r, a)), void 0 === e && s.push(n), r = Oe.lastIndex; return r < o && s.push(t.substring(r, o)), s; }, tagTextToProp(t, e) { let i; let n; e == null && (e = {}), e.img && we(e, Ge, 'img'), i = Te.test(t) ? (we(e, Ne, 'b', !0), '') : Pe.test(t) ? (we(e, Ge, 'b'), '') : Me.test(t) ? (we(e, Ne, 'i', !0), '') : Ee.test(t) ? (we(e, Ge, 'i'), '') : ze.test(t) ? (n = t.match(ze), we(e, Ne, 'size', `${n[1]}px`), '') : Be.test(t) ? (we(e, Ge, 'size'), '') : _e.test(t) ? (n = t.match(_e), we(e, Ne, 'color', n[1]), '') : je.test(t) ? (we(e, Ge, 'color'), '') : De.test(t) ? (n = t.match(De), we(e, Ne, 'u', !0), '') : Ie.test(t) ? (n = t.match(Ie), we(e, Ne, 'u', n[1]), '') : Ye.test(t) ? (we(e, Ge, 'u'), '') : Re.test(t) ? (we(e, Ne, 'shadow', !0), '') : Le.test(t) ? (we(e, Ge, 'shadow'), '') : Fe.test(t) ? (we(e, Ne, 'stroke', !0), '') : Ae.test(t) ? (n = t.match(Ae), we(e, Ne, 'stroke', n[1]), '') : Xe.test(t) ? (we(e, Ge, 'stroke'), '') : He.test(t) ? (n = t.match(He), we(e, Ne, 'img', n[1]), '') : Ue.test(t) ? (we(e, Ge, 'img'), '') : Ve.test(t) ? (n = t.match(Ve), we(e, Ne, 'area', n[1]), '') : We.test(t) ? (we(e, Ge, 'area'), '') : t; const s = be; return s.plainText = i, s.prop = e, s; }, propToContextStyle(t, e) { const i = xe; if (e.hasOwnProperty('img'))i.image = e.img; else { if (i.image = null, e.hasOwnProperty('family') ? i.fontFamily = e.family : i.fontFamily = t.fontFamily, e.hasOwnProperty('size')) { let n = e.size; typeof n === 'number' && (n = `${n.toString()}px`), i.fontSize = n; } else i.fontSize = t.fontSize; i.fontStyle = Se(e.b, e.i), e.hasOwnProperty('color') ? i.color = e.color : i.color = t.color, e.hasOwnProperty('stroke') ? (!0 === e.stroke ? i.stroke = t.stroke : i.stroke = e.stroke, i.strokeThickness = t.strokeThickness) : (i.stroke = t.stroke, i.strokeThickness = 0); } return e.hasOwnProperty('shadow') ? (!0 === e.shadow ? i.shadowColor = t.shadowColor : i.shadowColor = e.shadow, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.shadowBlur = t.shadowBlur, i.shadowStroke = !0, i.shadowFill = !0) : (i.shadowColor = '#000', i.shadowOffsetX = 0, i.shadowOffsetY = 0, i.shadowBlur = 0, i.shadowStroke = !1, i.shadowFill = !1), e.hasOwnProperty('u') ? (!0 === e.u ? i.underlineColor = t.underlineColor : i.underlineColor = e.u, i.underlineThickness = t.underlineThickness, i.underlineOffset = t.underlineOffset) : (i.underlineColor = '#000', i.underlineThickness = 0, i.underlineOffset = 0), i; }, propToTagText(t, e, i) { for (var n in i == null && (i = ke), i)e.hasOwnProperty(n) || (t = `[/${n}]${t}`); let s = ''; for (var n in e)i[n] !== e[n] && (n === 'size' ? s += `[size=${e[n].replace('px', '')}]` : n === 'color' || n === 'stroke' || n === 'img' ? s += `[${n}=${e[n]}]` : n === 'u' ? !0 === e[n] ? s += '[u]' : s += `[u=${e[n]}]` : s += `[${n}]`); return t = s + t; },
  }; var we = function (t, e, i, n) { return e === Ne ? t[i] = n : t.hasOwnProperty(i) && delete t[i], t; }; var Se = function (t, e) { return t && e ? 'bold italic' : t ? 'bold' : e ? 'italic' : ''; }; var Oe = /\[b\]|\[\/b\]|\[i\]|\[\/i\]|\[size=(\d+)\]|\[\/size\]|\[color=([a-z]+|#[0-9abcdef]+)\]|\[\/color\]|\[u\]|\[u=([a-z]+|#[0-9abcdef]+)\]|\[\/u\]|\[shadow\]|\[\/shadow\]|\[stroke\]|\[stroke=([a-z]+|#[0-9abcdef]+)\]|\[\/stroke\]|\[img=([^\]]+)\]|\[\/img\]|\[area=([^\]]+)\]|\[\/area\]/gi; var Te = /\[b\]/i; var Pe = /\[\/b\]/i; var Me = /\[i\]/i; var Ee = /\[\/i\]/i; var ze = /\[size=(\d+)\]/i; var Be = /\[\/size\]/i; var _e = /\[color=([a-z]+|#[0-9abcdef]+)\]/i; var je = /\[\/color\]/i; var De = /\[u\]/i; var Ie = /\[u=([a-z]+|#[0-9abcdef]+)\]/i; var Ye = /\[\/u\]/i; var Re = /\[shadow\]/i; var Le = /\[\/shadow\]/i; var Fe = /\[stroke\]/i; var Ae = /\[stroke=([a-z]+|#[0-9abcdef]+)\]/i; var Xe = /\[\/stroke\]/i; var He = /\[img=([^\]]+)\]/i; var Ue = /\[\/img\]/i; var Ve = /\[area=([^\]]+)\]/i; var We = /\[\/area\]/i; var Ge = !1; var Ne = !0; const Je = (function () { i(o, ye); const r = S(o); function o(t, e, i, n, s) { return B(this, o), r.call(this, t, e, i, n, s, 'rexBBCodeText', Ce); } return o; }()); c.register('BBCodeText', function (t, e, i, n) { const s = new Je(this.scene, t, e, i, n); return this.scene.add.existing(s), s; }), ut(window, 'RexPlugins.UI.BBCodeText', Je); const Ke = { plainText: null, prevProp: null }; const Ze = new Et(); const qe = (function () { function e(t) { B(this, e), void 0 === t && (t = {}), this.tags = t; } return w(e, [{ key: 'addTag', value(t, e) { this.tags[t] = e; } }, { key: 'splitText', value(t, e) { for (var i, n, s, r = [], o = 0, a = t.length, h = a; i = ti.exec(t);)n = i[0], o < (h = ti.lastIndex - n.length) && r.push(t.substring(o, h)), void 0 === e ? r.push(n) : e === 1 && (ei.test(n) ? (s = n.match(ii), r.push(s[2])) : ni.test(n) && (s = n.match(si), r.push(s[2]))), o = ti.lastIndex; return o < a && r.push(t.substring(o, a)), r; } }, { key: 'tagTextToProp', value(t) { let e; let i; if (ei.test(t)) { if ((r = t.match(ii)) != null) { const n = r[1]; const s = this.tags; (i = s.hasOwnProperty(n) ? s[n] : {})._class = n, e = r[2]; } } else if (ni.test(t)) { var r; if ((r = t.match(si)) != null) { const o = r[1]; (i = $e(o))._style = o, e = r[2]; } }e == null && (e = t), i == null && (i = {}); const a = Ke; return a.plainText = e, a.prop = i, a; } }, { key: 'propToContextStyle', value(t, e) { const i = Ze; if (e.hasOwnProperty('img'))i.image = e.img; else { if (i.image = null, e.hasOwnProperty('family') || e.hasOwnProperty('fontFamily') || e.hasOwnProperty('font-family')) { const n = e.hasOwnProperty('family') ? e.family : e.hasOwnProperty('fontFamily') ? e.fontFamily : e['font-family']; i.fontFamily = n; } else i.fontFamily = t.fontFamily; if (e.hasOwnProperty('size') || e.hasOwnProperty('fontSize') || e.hasOwnProperty('font-size')) { let s = e.hasOwnProperty('size') ? e.size : e.hasOwnProperty('fontSize') ? e.fontSize : e['font-size']; typeof s === 'number' && (s = `${s.toString()}px`), i.fontSize = s; } else i.fontSize = t.fontSize; if (e.hasOwnProperty('style') || e.hasOwnProperty('fontStyle') || e.hasOwnProperty('font-style')) { const r = e.hasOwnProperty('style') ? e.style : e.hasOwnProperty('fontStyle') ? e.fontStyle : e['font-style']; i.fontStyle = r; } else i.fontStyle = t.fontStyle; if (e.hasOwnProperty('color') || e.hasOwnProperty('font-color')) { const o = e.hasOwnProperty('color') ? e.color : e['font-color']; i.color = o; } else i.color = t.color; if (e.hasOwnProperty('stroke')) { const a = e.stroke; i.stroke = a.hasOwnProperty('color') ? a.color : t.stroke, i.strokeThickness = a.hasOwnProperty('thinkness') ? a.thinkness : t.strokeThickness; } else i.stroke = t.stroke, i.strokeThickness = t.strokeThickness; } if (e.hasOwnProperty('shadow')) { const h = e.shadow; i.shadowColor = h.hasOwnProperty('color') ? h.color : t.shadowColor, i.shadowOffsetX = h.hasOwnProperty('offsetX') ? h.offsetX : t.shadowOffsetX, i.shadowOffsetY = h.hasOwnProperty('offsetY') ? h.offsetY : t.shadowOffsetY, i.shadowBlur = h.hasOwnProperty('blur') ? h.blur : t.shadowBlur, i.shadowStroke = !0, i.shadowFill = !0; } else i.shadowColor = t.shadowColor, i.shadowOffsetX = t.shadowOffsetX, i.shadowOffsetY = t.shadowOffsetY, i.shadowBlur = t.shadowBlur, i.shadowStroke = t.shadowStroke, i.shadowFill = t.shadowFill; if (e.hasOwnProperty('u') || e.hasOwnProperty('underline')) { const l = e.hasOwnProperty('u') ? e.u : e.underline; i.underlineColor = l.hasOwnProperty('color') ? l.color : t.underlineColor, i.underlineThickness = l.hasOwnProperty('thinkness') ? l.thinkness : t.underlineThickness, i.underlineOffset = l.hasOwnProperty('offset') ? l.offset : t.underlineOffset; } else i.underlineColor = t.underlineColor, i.underlineThickness = t.underlineThickness, i.underlineOffset = t.underlineOffset; return i; } }, { key: 'propToTagText', value(t, e) { return e.hasOwnProperty('_class') ? t === '' && this.isTextTag(e._class) ? '' : `<class='${e._class}'>${t}</class>` : e.hasOwnProperty('_style') ? `<style='${e._style}'>${t}</style>` : void 0; } }, { key: 'destroy', value() { this.tags = void 0; } }, { key: 'isTextTag', value(t) { const e = this.tags[t]; return !!e && e.img == null; } }]), e; }()); var $e = function (t) { for (var e, i, n, s = {}, r = 0, o = (t = t.split(';')).length; r < o; r++) if (i = (e = t[r].split(':'))[0], n = e[1], !Qe(i) && !Qe(n)) { switch (i) { case 'stroke': var a = n.split(' '); n = {}, (l = a.length) >= 1 && (n.color = a[0]), l >= 2 && (n.thinkness = parseInt(a[1].replace('px', ''))); break; case 'shadow': var h = n.split(' '); n = {}, (l = h.length) >= 1 && (n.color = h[0]), l >= 2 && (n.offsetX = parseInt(h[1].replace('px', ''))), l >= 3 && (n.offsetY = parseInt(h[2].replace('px', ''))), l >= 4 && (n.blur = parseInt(h[3].replace('px', ''))); break; case 'u': case 'underline': var l; var u = n.split(' '); n = {}, (l = u.length) >= 1 && (n.color = u[0]), l >= 2 && (n.thinkness = parseInt(u[1].replace('px', ''))), l >= 3 && (n.offset = parseInt(u[2].replace('px', ''))); }s[i] = n; } return s; }; var Qe = function (t) { return (t = t.replace(ri, '')).length === 0; }; var ti = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>|<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/g; var ei = /<\s*class=/i; var ii = /<\s*class=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/class\s*\>/; var ni = /<\s*style=/i; var si = /<\s*style=["|']([^"|']+)["|']\s*\>([\s\S]*?)<\s*\/style\s*\>/; var ri = /^\s+|\s+$/; const oi = Phaser.Utils.Objects.GetValue; const ai = (function () { i(l, ye); const h = S(l); function l(t, e, i, n, s) { let r; B(this, l); const o = oi(s, 'tags', void 0); const a = new qe(o); return (r = h.call(this, t, e, i, n, s, 'rexTagText', a)).parser = a, r; } return w(l, [{ key: 'addTag', value(t, e) { return this.parser.addTag(t, e), this.updateText(!0); } }, { key: 'addTags', value(t) { for (const e in t) this.parser.addTag(e, t[e]); return this.updateText(!0); } }, { key: 'preDestroy', value() { g(p(l.prototype), 'preDestroy', this).call(this), this.parser.destroy(), this.parser = void 0; } }]), l; }()); c.register('tagText', function (t, e, i, n) { const s = new ai(this.scene, t, e, i, n); return this.scene.add.existing(s), s; }), ut(window, 'RexPlugins.UI.TagText', ai); const hi = Phaser.GameObjects.Zone; const li = Phaser.Utils.Array.Add; const ui = Phaser.Utils.Array.Remove; const ci = (function () { i(a, hi); const o = S(a); function a(t, e, i, n, s) { let r; return B(this, a), void 0 === n && (n = 1), void 0 === s && (s = 1), (r = o.call(this, t, e, i, n, s)).children = [], r; } return w(a, [{ key: 'destroy', value(t) { this.scene && (this.clear(!t), g(p(a.prototype), 'destroy', this).call(this, t)); } }, { key: 'contains', value(t) { return this.children.indexOf(t) !== -1; } }, { key: 'add', value(t) { return li(this.children, t, 0, function (t) { t.on('destroy', this.remove, this); }, this), this; } }, { key: 'remove', value(t, e) { return ui(this.children, t, function (t) { t.off('destroy', this.remove, this), e && t.destroy(); }), this; } }, { key: 'clear', value(t) { for (var e, i = 0, n = this.children.length; i < n; i++)(e = this.children[i]).off('destroy', this.remove, this), t && e.destroy(); return this.children.length = 0, this; } }]), a; }()); const di = Phaser.GameObjects.Components; Phaser.Class.mixin(ci, [di.Alpha, di.Flip]); function fi(t) { let e; return t.hasOwnProperty('rexContainer') && (e = t.rexContainer.parent), e; } function vi(t) { for (let e = fi(t); e;)e = fi(t = e); return t; } function pi(t) {
    return this.setParent(t), this.resetChildState(t).updateChildVisible(t).updateChildActive(t).updateChildScrollFactor(t)
      .updateChildMask(t), bi.call(this, t), this;
  } function gi(t, e) { return t === e ? 1 : t / e; } function yi(t) { return Object.prototype.toString.call(t) === '[object Array]'; } const mi = { setParent(t, e) { void 0 === e && (e = this); const i = this.getLocalState(t); return e ? (i.parent = e, i.self = t) : (i.parent = null, i.self = null), this; }, getParent(t) { return void 0 === t && (t = this), fi(t); }, getTopmostParent(t) { return void 0 === t && (t = this), vi(t); } }; var bi = ci.prototype.add; const xi = { add(t) { return Array.isArray(t) ? this.addMultiple(t) : pi.call(this, t), this; }, addMultiple(t) { for (let e = 0, i = t.length; e < i; e++)pi.call(this, t[e]); return this; } }; const ki = ci.prototype.remove; const Ci = ci.prototype.clear; const wi = { remove(t, e) { return this.getParent(t) !== this || (this.setParent(t, null), ki.call(this, t, e)), this; }, clear(t) { for (let e = 0, i = this.children.length; e < i; e++) this.setParent(this.children[e], null); return Ci.call(this, t), this; } }; const Si = Phaser.Math.RotateAround; const Oi = { worldToLocal(t) { return t.x -= this.x, t.y -= this.y, Si(t, 0, 0, -this.rotation), t.x /= this.scaleX, t.y /= this.scaleY, t.x *= this.flipX ? -1 : 1, t.y *= this.flipY ? -1 : 1, t; }, localToWorld(t) { return t.x *= this.flipX ? -1 : 1, t.y *= this.flipY ? -1 : 1, t.x *= this.scaleX, t.y *= this.scaleY, Si(t, 0, 0, this.rotation), t.x += this.x, t.y += this.y, t; } }; const Ti = {
    updateChildPosition(t) { t.isRexContainerLite && (t.syncChildrenEnable = !1); const e = this.getLocalState(t); return t.x = e.x, t.y = e.y, this.localToWorld(t), t.scaleX = e.scaleX * this.scaleX, t.scaleY = e.scaleY * this.scaleY, void 0 !== t.flipX && (t.flipX = this.flipX ? !e.flipX : e.flipX, t.flipY = this.flipY ? !e.flipY : e.flipY), t.rotation = e.rotation + this.rotation, t.isRexContainerLite && (t.syncChildrenEnable = !0, t.syncPosition()), this; }, syncPosition() { return this.syncChildrenEnable && this.children.forEach(this.updateChildPosition, this), this; }, resetChildPositionState(t) { const e = this.getLocalState(t); return e.x = t.x, e.y = t.y, this.worldToLocal(e), e.scaleX = gi(t.scaleX, this.scaleX), e.scaleY = gi(t.scaleY, this.scaleY), void 0 !== t.flipX && (e.flipX = t.flipX, e.flipY = t.flipY), e.rotation = t.rotation - this.rotation, this; }, setChildPosition(t, e, i) { return t.x = e, t.y = i, this.resetChildPositionState(t), this; }, setChildLocalPosition(t, e, i) { const n = this.getLocalState(t); return n.x = e, n.y = i, this.updateChildPosition(t), this; },
  }; const Pi = {
    updateChildVisible(t) { const e = this.getLocalState(t); const i = !e.hasOwnProperty('maskVisible') || e.maskVisible; return t.visible = this.visible && e.visible && i, this; }, syncVisible() { return this.syncChildrenEnable && this.children.forEach(this.updateChildVisible, this), this; }, resetChildVisibleState(t) { const e = this.getLocalState(t); return e.hasOwnProperty('maskVisible') && delete e.maskVisible, e.visible = t.visible, this; }, setChildVisible(t, e) { return this.setChildLocalVisible(t, e), this; }, setChildLocalVisible(t, e) { return void 0 === e && (e = !0), this.getLocalState(t).visible = e, this.updateChildVisible(t), this; }, setChildMaskVisible(t, e) { return void 0 === e && (e = !0), this.getLocalState(t).maskVisible = e, this.updateChildVisible(t), this; },
  }; const Mi = {
    updateChildAlpha(t) { return t.alpha = this.alpha * this.getLocalState(t).alpha, this; }, syncAlpha() { return this.syncChildrenEnable && this.children.forEach(this.updateChildAlpha, this), this; }, resetChildAlphaState(t) { return this.getLocalState(t).alpha = gi(t.alpha, this.alpha), this; }, setChildAlpha(t, e) { return t.alpha = e, this.resetChildAlphaState(t), this._add; }, setChildLocalAlpha(t, e) { return this.getLocalState(t).alpha = e, this.updateChildAlpha(t), this; },
  }; const Ei = {
    updateChildActive(t) { return t.active = this.active && this.getLocalState(t).active, this; }, syncActive() { return this.syncChildrenEnable && this.children.forEach(this.updateChildActive, this), this; }, resetChildActiveState(t) { return this.getLocalState(t).active = t.active, this; }, setChildActive(t, e) { return t.active = e, this.resetChildActiveState(t), this; }, setChildLocalActive(t, e) { return void 0 === e && (e = !0), this.getLocalState(t).active = e, this.updateChildActive(t), this; },
  }; const zi = {
    updateChildMask(t) { return this.mask == null || (this.mask.hasOwnProperty('geometryMask') ? this.mask.geometryMask : this.mask.bitmapMask) !== t && (t.mask = this.mask), this; }, syncMask() { return this.syncChildrenEnable && this.children.forEach(this.updateChildMask, this), this; }, setMask(t) { return this.mask = t, this; }, clearMask(t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this; },
  }; const Bi = Phaser.Utils.Array; const _i = {
    getChildren() { return this.children; }, getAllChildren(t) { void 0 === t && (t = []); for (var e, i = this.children, n = 0, s = i.length; n < s; n++) { if (e = i[n], t.push(e), e.hasOwnProperty('isRexContainerLite'))t.push.apply(t, h(e.getAllChildren())); } return t; }, contains(t) { const e = this.getParent(t); return !!e && (e === this || this.contains(e)); }, getByName(t, e) { if (e) { for (var i, n, s = [this]; s.length;) for (let r = 0, o = (i = s.shift()).children.length; r < o; r++) { if ((n = i.children[r]).name === t) return n; n.isRexContainerLite && s.push(n); } return null; } return Bi.GetFirst(this.children, 'name', t); }, getRandom(t, e) { return Bi.GetRandom(this.children, t, e); }, getFirst(t, e, i, n) { return Bi.GetFirstElement(this.children, t, e, i, n); }, getAll(t, e, i, n) { return Bi.GetAll(this.children, t, e, i, n); }, count(t, e, i, n) { return Bi.CountAllMatching(this.children, t, e, i, n); }, swap(t, e) { return Bi.Swap(this.children, t, e), this; }, moveTo(t, e) { return Bi.MoveTo(this.children, t, e), this; }, setAll(t, e, i, n) { return Bi.SetAll(this.children, t, e, i, n), this; },
  }; const ji = { tweenChild(t) { let e = t.targets; yi(e) || (e = [e]); for (var i, n, s = [], r = 0, o = e.length; r < o; r++)(n = e[r]).hasOwnProperty('rexContainer') && (i = n.scene, s.push(n.rexContainer)); if (i) { t.targets = s; const a = i.tweens.add(t); return a.on('update', (t, e, i) => { for (var n, s, r = 0, o = i.length; r < o; r++) switch (n = i.parent, s = i.self, e) { case 'x': case 'y': case 'angle': case 'rotation': case 'scaleX': case 'scaleY': case 'flipX': case 'flipY': n.updateChildPosition(s); break; case 'alpha': n.updateChildAlpha(s); } }), a; } }, tween(t) { const e = this.scene; return t.targets || (t.targets = this), e.tweens.add(t); } }; const Di = {}; Object.assign(Di, mi, xi, wi, {
    getLocalState(t) { return t.hasOwnProperty('rexContainer') || (t.rexContainer = {}), t.rexContainer; },
    resetChildState(t) { return this.resetChildPositionState(t).resetChildVisibleState(t).resetChildAlphaState(t).resetChildActiveState(t), this; },
    resetChildrenState(t) { for (let e = 0, i = t.length; e < i; e++) this.resetChildState(t[e]); return this; },
    syncProperties() {
      return this.syncPosition().syncVisible().syncAlpha().syncActive()
        .syncScrollFactor()
        .syncMask(), this;
    },
  }, Oi, Ti, Pi, Mi, Ei, { updateChildScrollFactor(t) { return t.setScrollFactor(this.scrollFactorX, this.scrollFactorY), this; }, syncScrollFactor() { return this.syncChildrenEnable && this.children.forEach(this.updateChildScrollFactor, this), this; } }, zi, { setDepth(t, e) { if (this.depth = t, !e && this.children) for (let i = this.getAllChildren(), n = 0, s = i.length; n < s; n++)i[n].depth = t; return this; }, swapDepth(t) { const e = this.depth; const i = t.depth; return this.setDepth(i), t.setDepth(e), this; }, incDepth(t) { if (this.depth += t, this.children) for (let e = this.getAllChildren(), i = 0, n = e.length; i < n; i++)e[i].depth += t; return this; } }, _i, ji); const Ii = (function () { i(h, ci); const a = S(h); function h(t, e, i, n, s, r) { let o; return B(this, h), (o = a.call(this, t, e, i, n, s)).type = 'rexContainerLite', o.isRexContainerLite = !0, o.syncChildrenEnable = !0, o._active = !0, o._mask = null, o._scrollFactorX = 1, o._scrollFactorY = 1, r && o.add(r), o; } return w(h, [{ key: 'destroy', value(t) { this.scene && (this.syncChildrenEnable = !1, g(p(h.prototype), 'destroy', this).call(this, t)); } }, { key: 'resize', value(t, e) { return this.setSize(t, e), this; } }, { key: 'x', get() { return this._x; }, set(t) { this._x !== t && (this._x = t, this.syncPosition()); } }, { key: 'y', get() { return this._y; }, set(t) { this._y !== t && (this._y = t, this.syncPosition()); } }, { key: 'rotation', get() { return g(p(h.prototype), 'rotation', this); }, set(t) { this.rotation !== t && (e(p(h.prototype), 'rotation', t, this, !0), this.syncPosition()); } }, { key: 'scaleX', get() { return g(p(h.prototype), 'scaleX', this); }, set(t) { this.scaleX !== t && (e(p(h.prototype), 'scaleX', t, this, !0), this.syncPosition()); } }, { key: 'scaleY', get() { return g(p(h.prototype), 'scaleY', this); }, set(t) { this.scaleY !== t && (e(p(h.prototype), 'scaleY', t, this, !0), this.syncPosition()); } }, { key: 'flipX', get() { return g(p(h.prototype), 'flipX', this); }, set(t) { g(p(h.prototype), 'flipX', this) !== t && (e(p(h.prototype), 'flipX', t, this, !0), this.syncPosition()); } }, { key: 'flipY', get() { return g(p(h.prototype), 'flipY', this); }, set(t) { g(p(h.prototype), 'flipY', this) !== t && (e(p(h.prototype), 'flipY', t, this, !0), this.syncPosition()); } }, { key: 'visible', get() { return g(p(h.prototype), 'visible', this); }, set(t) { g(p(h.prototype), 'visible', this) !== t && (e(p(h.prototype), 'visible', t, this, !0), this.syncVisible()); } }, { key: 'alpha', get() { return g(p(h.prototype), 'alpha', this); }, set(t) { g(p(h.prototype), 'alpha', this) !== t && (e(p(h.prototype), 'alpha', t, this, !0), this.syncAlpha()); } }, { key: 'active', get() { return this._active; }, set(t) { this._active !== t && (this._active = t, this.syncActive()); } }, { key: 'mask', get() { return this._mask; }, set(t) { this._mask !== t && (this._mask = t, this.syncMask()); } }, { key: 'scrollFactorX', get() { return this._scrollFactorX; }, set(t) { this._scrollFactorX !== t && (this._scrollFactorX = t, this.syncScrollFactor()); } }, { key: 'scrollFactorY', get() { return this._scrollFactorY; }, set(t) { this._scrollFactorY !== t && (this._scrollFactorY = t, this.syncScrollFactor()); } }, { key: 'list', get() { return this.children; } }]), h; }()); Object.assign(Ii.prototype, Di), c.register('container', function (t, e, i, n, s) { const r = new Ii(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r; }), ut(window, 'RexPlugins.UI.Container', Ii); const Yi = Phaser.Renderer.WebGL.Utils; const Ri = { renderWebGL(t, e, i, n, s) { if (e.dirty && (e.updateTexture(), e.dirty = !1), e.width !== 0 && e.height !== 0) { const r = e.frame; const o = r.width; const a = r.height; const h = Yi.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, r.glTexture, o, a, e.x, e.y, o / e.resolution, a / e.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, o, a, h(e._tintTL, n.alpha * e._alphaTL), h(e._tintTR, n.alpha * e._alphaTR), h(e._tintBL, n.alpha * e._alphaBL), h(e._tintBR, n.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, n, s); } }, renderCanvas(t, e, i, n, s) { e.width !== 0 && e.height !== 0 && t.batchSprite(e, e.frame, n, s); } }; const Li = Phaser.Display.Color; const Fi = {
    clear() { return this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.dirty = !0, this; }, fill(t) { return this.context.fillStyle = t, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height), this.dirty = !0, this; }, loadFromURL(t, e) { const i = this; const n = new Image(); return n.onload = function () { i.width !== n.width || i.height !== n.height ? i.resize(n.width, n.height) : i.clear(), i.context.drawImage(n, 0, 0), i.updateTexture(), e && e(), n.onload = null, n.src = '', n.remove(); }, n.src = t, this; }, loadFromURLPromise(i) { const n = this; return new Promise(((t, e) => { n.loadFromURL(i, t); })); }, getDataURL(t, e) { return this.canvas.toDataURL(t, e); }, getPixel(t, e, i) { void 0 === i && (i = new Li()); const n = this.context.getImageData(t, e, 1, 1); return i.setTo(n.data[0], n.data[1], n.data[2], n.data[3]), i; }, setPixel(t, e, i, n, s, r) { if (typeof i !== 'number') { const o = i; i = o.red, n = o.green, s = o.blue, r = o.alpha; } void 0 === r && (r = i !== 0 || n !== 0 || s !== 0 ? 255 : 0); const a = this.context.createImageData(1, 1); return a.data[0] = i, a.data[1] = n, a.data[2] = s, a.data[3] = r, this.context.putImageData(a, t, e), this.dirty = !0, this; },
  }; const Ai = { updateTexture(t, e) { t && (e ? t.call(e, this.canvas, this.context) : t(this.canvas, this.context)), this.canvas.width === this.frame.width && this.canvas.height === this.frame.height || this.frame.setSize(this.canvas.width, this.canvas.height), this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(this.canvas, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !1; const i = this.input; return i && !i.customHitArea && (i.hitArea.width = this.width, i.hitArea.height = this.height), this; }, generateTexture(t, e, i, n, s) { let r; const o = this.canvas; const a = this.scene.sys; const h = a.game.renderer; void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n ? n = o.width : n *= this.resolution, void 0 === s ? s = o.height : s *= this.resolution; const l = (r = a.textures.exists(t) ? a.textures.get(t) : a.textures.createCanvas(t, n, s)).getSourceImage(); l.width !== n && (l.width = n), l.height !== s && (l.height = s); const u = l.getContext('2d'); return u.clearRect(0, 0, n, s), u.drawImage(o, e, i, n, s), h.gl && r && h.canvasToTexture(l, r.source[0].glTexture, !0, 0), this; }, loadTexture(t, e) { const i = this.scene.textures.getFrame(t, e); return i && (this.width !== i.cutWidth || this.height !== i.cutHeight ? this.resize(i.cutWidth, i.cutHeight) : this.clear(), this.context.drawImage(i.source.image, i.cutX, i.cutY, i.cutWidth, i.cutHeight, 0, 0, this.canvas.width, this.canvas.height), this.dirty = !0), this; } }; const Xi = Phaser.Display.Canvas.CanvasPool; const Hi = Phaser.GameObjects.GameObject; const Ui = (function () { i(a, Hi); const o = S(a); function a(t, e, i, n, s) { let r; return B(this, a), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 1), (r = o.call(this, t, 'rexCanvas')).renderer = t.sys.game.renderer, r.resolution = t.sys.game.config.resolution, r.canvas = Xi.create(_(r), r.resolution * n, r.resolution * s), r.context = r.canvas.getContext('2d'), r.dirty = !1, r.setPosition(e, i), r.setSize(n, s), r.setOrigin(0.5, 0.5), r.initPipeline(), r._crop = r.resetCropObject(), r.texture = t.sys.textures.addCanvas(null, r.canvas, !0), r.frame = r.texture.get(), r.frame.source.resolution = r.resolution, r.renderer.gl && (r.renderer.deleteTexture(r.frame.source.glTexture), r.frame.source.glTexture = null), r.dirty = !0, t.sys.game.events.on('contextrestored', function () { this.dirty = !0; }, _(r)), r; } return w(a, [{ key: 'getCanvas', value(t) { return t || (this.dirty = !0), this.canvas; } }, { key: 'getContext', value(t) { return t || (this.dirty = !0), this.context; } }, { key: 'needRedraw', value() { return this.dirty = !0, this; } }, { key: 'preDestroy', value() { Xi.remove(this.canvas); } }, { key: 'resize', value(t, e) { return this.width === t && this.height === e || (this.setSize(t, e).updateDisplayOrigin(), t *= this.resolution, e *= this.resolution, t = Math.max(Math.ceil(t), 1), e = Math.max(Math.ceil(e), 1), this.canvas.width = t, this.canvas.height = e, this.frame.setSize(t, e), this.dirty = !0), this; } }]), a; }()); const Vi = Phaser.GameObjects.Components; Phaser.Class.mixin(Ui, [Vi.Alpha, Vi.BlendMode, Vi.ComputedSize, Vi.Crop, Vi.Depth, Vi.Flip, Vi.GetBounds, Vi.Mask, Vi.Origin, Vi.Pipeline, Vi.ScrollFactor, Vi.Tint, Vi.Transform, Vi.Visible, Ri, Fi, Ai]), c.register('canvas', function (t, e, i, n) { const s = new Ui(this.scene, t, e, i, n); return this.scene.add.existing(s), s; }), ut(window, 'RexPlugins.UI.Canvas', Ui); const Wi = Phaser.Math.DegToRad; const Gi = Wi(0); const Ni = Wi(90); const Ji = Wi(180); const Ki = Wi(270); const Zi = function (t) { return t.x !== 0 && t.y !== 0; }; const qi = Phaser.Utils.Objects.GetValue; const $i = (function () { i(h, Ui); const a = S(h); function h(t, e, i, n, s, r) { let o; return B(this, h), (o = a.call(this, t, e, i)).type = 'rexCircleMaskImage', o.setTexture(n, s, r), o; } return w(h, [{ key: 'setTexture', value(t, e, i) { let n; let s; if (k(e) === 'object' && (i = e, e = void 0), s = typeof i === 'string' ? void (n = i) : (n = qi(i, 'maskType', 0), qi(i, 'backgroundColor', void 0)), void 0 === n ? n = 0 : typeof n === 'string' && (n = Qi[n]), this._textureKey = t, this._frameName = e, n === null) return this.loadTexture(t, e), this.dirty = !0, this; const r = s != null; r || this.loadTexture(t, e); let o; let a; let h; let l; let u; let c; let d; let f; let v; let p; const g = this.canvas; const y = this.context; const m = g.width; const b = g.height; switch (y.save(), y.globalCompositeOperation = r ? 'source-over' : 'destination-in', y.beginPath(), n) { case 0: c = y, d = m, f = b, v = Math.floor(d / 2), p = Math.floor(f / 2), c.arc(v, p, Math.min(v, p), 0, 2 * Math.PI); break; case 1: o = y, a = m, h = b, l = Math.floor(a / 2), u = Math.floor(h / 2), o.ellipse(l, u, l, u, 0, 0, 2 * Math.PI); break; case 2: !(function (t, e, i, n) { void 0 === n && (n = Math.min(Math.floor(e / 2), Math.floor(i / 2))); let s; let r; let o; const a = new C(0, 0, e, i, n); const h = a.cornerRadius; s = h.br, r = a.width - s.x, o = a.height - s.y, Zi(s) ? t.ellipse(r, o, s.x, s.y, 0, Gi, Ni) : (t.moveTo(a.width, o), t.lineTo(a.width, a.height), t.lineTo(r, a.height)), r = (s = h.bl).x, o = a.height - s.y, t.lineTo(s.x, a.height), Zi(s) ? t.ellipse(r, o, s.x, s.y, 0, Ni, Ji) : (t.lineTo(0, a.height), t.lineTo(0, o)), r = (s = h.tl).x, o = s.y, t.lineTo(0, o), Zi(s) ? t.ellipse(r, o, s.x, s.y, 0, Ji, Ki) : (t.lineTo(0, 0), t.lineTo(r, 0)), s = h.tr, r = a.width - s.x, o = s.y, t.lineTo(r, 0), Zi(s) ? t.ellipse(r, o, s.x, s.y, 0, Ki, Gi) : (t.lineTo(a.width, 0), t.lineTo(a.width, o)), t.closePath(); }(y, m, b, qi(i, 'radius', void 0))); } return r && (y.fillStyle = s), y.fill(), y.restore(), r && (y.save(), y.globalCompositeOperation = 'destination-atop', this.loadTexture(t, e), y.restore()), this.dirty = !0, this; } }]), h; }()); var Qi = { circle: 0, ellipse: 1, roundRectangle: 2 }; c.register('circleMaskImage', function (t, e, i, n, s) { const r = new $i(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r; }), ut(window, 'RexPlugins.UI.CircleMaskImage', $i); const tn = function (e, t) { void 0 === t && (t = {}), void 0 === t.options && (t.options = {}); const i = t.options; i.responsive = !1, i.maintainAspectRatio = !1, i.hasOwnProperty('devicePixelRatio') || (i.devicePixelRatio = 1); let n = !1; void 0 === i.animation ? i.animation = {} : !1 === i.animation && (n = !0, i.animation = {}); const s = i.animation; n && (s.duration = 0); const r = s.onProgress; s.onProgress = function (t) { r && r(t), e.needRedraw(); }; const o = s.onComplete; return s.onComplete = function (t) { o && o(t), e.needRedraw(); }, t; }; const en = (function () { i(h, Ui); const a = S(h); function h(t, e, i, n, s, r) { let o; return B(this, h), (o = a.call(this, t, e, i, n, s)).type = 'rexChart', (o.chart = void 0) !== r && o.setChart(r), o; } return w(h, [{ key: 'destroy', value(t) { this.scene && (this.chart && (this.chart.destroy(), this.chart = void 0), g(p(h.prototype), 'destroy', this).call(this, t)); } }, { key: 'resize', value(t, e) { if (t === this.width && e === this.height) return this; if (g(p(h.prototype), 'resize', this).call(this, t, e), this.chart) { const i = this.chart; i.height = this.canvas.height, i.width = this.canvas.width, i.aspectRatio = i.height ? i.width / i.height : null, i.update(); } return this; } }]), h; }()); const nn = {
    setChart(t) { if (window.Chart) return this.chart && this.chart.destroy(), this.chart = new Chart(this.context, tn(this, t)), this; return console.error("Can not find chartjs! Load chartjs in preload stage.\nscene.load.script('chartjs', 'https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.7.2/Chart.min.js');"), this; }, getChartDataset(t) { if (void 0 !== this.chart) { if (typeof t !== 'string') return this.chart.data.datasets[t]; for (var e, i = this.chart.data.datasets, n = 0, s = i.length; n < s; n++) if ((e = i[n]).label === t) return e; } }, getChartData(t, e) { const i = this.getChartDataset(t); if (void 0 !== i) { if (typeof e === 'string') if ((e = this.chart.data.labels.indexOf(e)) === -1) return; return i.data[e]; } }, setChartData(t, e, i) { if (void 0 === this.chart) return this; const n = this.getChartDataset(t); if (typeof e === 'string' && (e = this.chart.data.labels.indexOf(e)) === -1) return this; return n.data[e] = i, this; }, updateChart() { if (void 0 === this.chart) return this; this.chart.update(); },
  }; Object.assign(en.prototype, nn), c.register('chart', function (t, e, i, n, s) { const r = new en(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r; }), ut(window, 'RexPlugins.UI.Chart', en); function sn(t, e, i) { return void 0 === i && (i = 'image'), t[e] || (t[e] = t.scene.make[i]({ add: !1, origin: { x: 0, y: 0 } }), t.on('destroy', () => { t[e] && (t[e].destroy(), t[e] = void 0); })), t[e]; } function rn(t, e, i) { return i === '__BASE' ? ''.concat(t, ',').concat(e) : ''.concat(i, '_').concat(t, ',').concat(e); } const on = Phaser.Utils.Objects.IsPlainObject; const an = Phaser.Utils.Objects.GetValue; const hn = function (t) { return typeof t === 'string' && (t = ln[t]), t; }; var ln = { scale: 0, repeat: 1 }; const un = {
    setTexture(t, e, i, n) { yi(e) && (n = i, i = e, e = void 0), void 0 === e && (e = '__BASE'), this.textureKey = t, this.baseFrameName = e, this.columns.data = i, this.columns.count = i ? i.length : 0, this.columns.stretch = 0, this.columns.minWidth = 0, this.rows.data = n, this.rows.count = n ? n.length : 0, this.rows.stretch = 0, this.rows.minHeight = 0; const s = this.scene.textures.get(t); if (!s) return this.clear(), this; if (!i || !n) return this.clear(), this; for (var r = s.frames[e], o = r.width, a = 0, h = 0, l = i.length; h < l; h++) void 0 === i[h] ? a++ : typeof i[h] === 'number' ? o -= i[h] : o -= i[h].width; const u = o / a; let c = r.height; let d = 0; for (h = 0, l = n.length; h < l; h++) void 0 === n[h] ? d++ : typeof n[h] === 'number' ? c -= n[h] : c -= n[h].width; for (var f, v, p, g, y, m = c / d, b = 0, x = 0, k = 0, C = n.length; k < C; k++) { void 0 === n[k] && (n[k] = m), typeof n[k] === 'number' && (n[k] = { height: n[k], stretch: k % 2 }), p = (f = n[k]).height, this.rows.stretch += 0 | f.stretch, this.rows.minHeight += f.stretch > 0 ? 0 : p; h = b = 0; for (let w = i.length; h < w; h++) void 0 === i[h] && (i[h] = u), typeof i[h] === 'number' && (i[h] = { width: i[h], stretch: h % 2 }), g = (v = i[h]).width, k === 0 && (this.columns.stretch += 0 | v.stretch, this.columns.minWidth += v.stretch > 0 ? 0 : g), g >= 1 && p >= 1 ? (y = this.getFrameNameCallback(h, k, e)) && s.add(y, 0, b + r.cutX, x + r.cutY, g, p) : console.warn('Size of Grid('.concat(h, ',').concat(k, ') = ').concat(g, 'x').concat(p, ', which is invalid')), b += g; x += p; } return this.updateTexture(), this; }, updateTexture() { if (this.clear(), void 0 === this.textureKey) return this; const t = this.scene.textures.get(this.textureKey); if (!t) return this; let e; let i; const n = this.width - this.columns.minWidth; i = n >= 0 ? (e = this.columns.stretch > 0 ? n / this.columns.stretch : 0, 1) : (e = 0, this.width / this.columns.minWidth); let s; let r; let o; let a; let h; let l; let u; const c = this.height - this.rows.minHeight; r = c >= 0 ? (s = this.rows.stretch > 0 ? c / this.rows.stretch : 0, 1) : (s = 0, this.height / this.rows.minHeight); for (var d, f = 0, v = 0, p = 0, g = this.rows.count; p < g; p++) { u = (h = this.rows.data[p]).stretch === 0 ? h.height * r : s * h.stretch; for (let y = f = 0, m = this.columns.count; y < m; y++)l = (a = this.columns.data[y]).stretch === 0 ? a.width * i : e * a.stretch, (o = this.getFrameNameCallback(y, p, this.baseFrameName)) && l > 0 && u > 0 && t.has(o) && ((h.stretch === 0 && a.stretch === 0 || this.getStretchMode(y, p) === 0 ? 0 : 1) === 0 ? (d = sn(this, '_image', 'image')).setTexture(this.textureKey, o).setDisplaySize(l, u) : (d = sn(this, '_tileSprite', 'tileSprite')).setTexture(this.textureKey, o).setSize(l, u)), d && (this.draw(d, f, v), d = void 0), f += l; v += u; } }, setStretchMode(t) { return on(t) ? (this.stretchMode.edge = hn(an(t, 'edge', 0)), this.stretchMode.internal = hn(an(t, 'internal', 0))) : (t = hn(t), this.stretchMode.edge = t, this.stretchMode.internal = t), this; }, getStretchMode(t, e) { return function (t, e) { return t === 0 || t === this.columns.count - 1 || e === 0 || e === this.rows.count - 1; }.call(this, t, e) ? this.stretchMode.edge : this.stretchMode.internal; },
  }; const cn = Phaser.GameObjects.RenderTexture; const dn = Phaser.Utils.Objects.IsPlainObject; const fn = Phaser.Utils.Objects.GetValue; const vn = (function () { i(d, cn); const c = S(d); function d(t, e, i, n, s, r, o, a, h, l) { let u; return B(this, d), dn(e) ? (e = fn(l = e, 'x', 0), i = fn(l, 'y', 0), n = fn(l, 'width', 1), s = fn(l, 'height', 1), r = fn(l, 'key', void 0), o = fn(l, 'baseFrame', void 0), a = fn(l, 'columns', void 0), h = fn(l, 'rows', void 0)) : dn(n) ? (n = fn(l = n, 'width', 1), s = fn(l, 'height', 1), r = fn(l, 'key', void 0), o = fn(l, 'baseFrame', void 0), a = fn(l, 'columns', void 0), h = fn(l, 'rows', void 0)) : dn(r) ? (r = fn(l = r, 'key', void 0), o = fn(l, 'baseFrame', void 0), a = fn(l, 'columns', void 0), h = fn(l, 'rows', void 0)) : dn(o) ? (o = fn(l = o, 'baseFrame', void 0), a = fn(l, 'columns', void 0), h = fn(l, 'rows', void 0)) : yi(o) ? (l = h, h = a, a = o, o = fn(l, 'baseFrame', void 0)) : dn(a) && (a = fn(l = a, 'columns', void 0), h = fn(l, 'rows', void 0)), (u = c.call(this, t, e, i, n, s)).columns = {}, u.rows = {}, u.stretchMode = {}, u._tileSprite = void 0, u._image = void 0, u.setOrigin(0.5, 0.5), u.setGetFrameNameCallback(fn(l, 'getFrameNameCallback', void 0)), u.setStretchMode(fn(l, 'stretchMode', 0)), u.setTexture(r, o, a, h), u; } return w(d, [{ key: 'setGetFrameNameCallback', value(t) { return void 0 === t && (t = rn), this.getFrameNameCallback = t, this; } }, { key: 'resize', value(t, e) { return this.width === t && this.height === e || (g(p(d.prototype), 'resize', this).call(this, t, e), this.updateTexture()), this; } }, { key: 'minWidth', get() { return this.columns.minWidth; } }, { key: 'minHeight', get() { return this.rows.minHeight; } }]), d; }()); Object.assign(vn.prototype, un), c.register('ninePatch', function (t, e, i, n, s, r, o, a) { const h = new vn(this.scene, t, e, i, n, s, r, o, a); return this.scene.add.existing(h), h; }), ut(window, 'RexPlugins.UI.NinePatch', vn); function pn(t) { return t.hasOwnProperty('rexSizer') || (t.rexSizer = {}), t.rexSizer; } function gn(t, e) { void 0 === e && (void 0 === yn && (yn = new Phaser.Geom.Rectangle()), e = yn); const i = t.game.config; return e.setTo(0, 0, i.width, i.height), e; } let yn; const mn = Phaser.Display.Align; const bn = {
    center: mn.CENTER, left: mn.LEFT_CENTER, right: mn.RIGHT_CENTER, top: mn.TOP_CENTER, bottom: mn.BOTTOM_CENTER, 'left-top': mn.TOP_LEFT, 'left-center': mn.LEFT_CENTER, 'left-bottom': mn.BOTTOM_LEFT, 'center-top': mn.TOP_CENTER, 'center-center': mn.CENTER, 'center-bottom': mn.BOTTOM_CENTER, 'right-top': mn.TOP_RIGHT, 'right-center': mn.RIGHT_CENTER, 'right-bottom': mn.BOTTOM_RIGHT,
  }; const xn = new Phaser.GameObjects.Zone({ sys: { queueDepthSort: vt, events: { once: vt } } }, 0, 0, 1, 1); xn.setOrigin(0); function kn(t) { return void 0 !== t.displayWidth ? t.displayWidth : t.width; } function Cn(t) { return void 0 !== t.displayHeight ? t.displayHeight : t.height; } function wn(t) { const e = Cn(t); return t.y + e - e * t.originY; } function Sn(t) { const e = kn(t); return t.x - e * t.originX + 0.5 * e; } function On(t, e) { const i = Cn(t); return t.y = e - i + i * t.originY, t; } function Tn(t, e) { const i = kn(t); const n = i * t.originX; return t.x = e + n - 0.5 * i, t; } function Pn(t) { const e = kn(t); return t.x - e * t.originX; } function Mn(t, e) { const i = kn(t); return t.x = e + i * t.originX, t; } function En(t) { const e = kn(t); return t.x + e - e * t.originX; } function zn(t, e) { const i = kn(t); return t.x = e - i + i * t.originX, t; } function Bn(t, e) { const i = Cn(t); const n = i * t.originY; return t.y = e + n - 0.5 * i, t; } function _n(t) { const e = Cn(t); return t.y - e * t.originY + 0.5 * e; } function jn(t) { const e = Cn(t); return t.y - e * t.originY; } function Dn(t, e) { const i = Cn(t); return t.y = e + i * t.originY, t; } const In = 0; const Yn = 1; const Rn = 2; const Ln = 4; const Fn = 6; const An = 8; const Xn = 10; const Hn = 12; const Un = []; Un[11] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Tn(t, Sn(e) + i), On(t, wn(e) + n), t; }, Un[Xn] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Mn(t, Pn(e) - i), On(t, wn(e) + n), t; }, Un[Hn] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), zn(t, En(e) + i), On(t, wn(e) + n), t; }, Un[Fn] = function (t, e, i, n) { let s; let r; let o; return void 0 === i && (i = 0), void 0 === n && (n = 0), s = t, r = Sn(e) + i, o = _n(e) + n, Tn(s, r), Bn(s, o), t; }, Un[Ln] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Mn(t, Pn(e) - i), Bn(t, _n(e) + n), t; }, Un[An] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), zn(t, En(e) + i), Bn(t, _n(e) + n), t; }, Un[Yn] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Tn(t, Sn(e) + i), Dn(t, jn(e) - n), t; }, Un[In] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), Mn(t, Pn(e) - i), Dn(t, jn(e) - n), t; }, Un[Rn] = function (t, e, i, n) { return void 0 === i && (i = 0), void 0 === n && (n = 0), zn(t, En(e) + i), Dn(t, jn(e) - n), t; }; function Vn(t, e, i, n, s) { return Un[i](t, e, n, s); } function Wn(t, e) { return void 0 === e && (e = {}), typeof t === 'number' ? (e.left = t, e.right = t, e.top = t, e.bottom = t) : (e.left = is(t, 'left', 0), e.right = is(t, 'right', 0), e.top = is(t, 'top', 0), e.bottom = is(t, 'bottom', 0)), e; } function Gn(t, e) { return void 0 === this.childrenMap && (this.childrenMap = {}), this.childrenMap[t] = e, this; } function Nn() { this._childrenWidth = void 0, this._childrenHeight = void 0; } function Jn(t, e) { void 0 === e ? e = new os() : !0 === e && (e = as); const i = t.scale; const n = i.canvasBounds; const s = i.displayScale; const r = i.autoCenter; return e.x = n.x >= 0 ? 0 : -(n.x * s.x), e.y = n.y >= 0 ? 0 : -(n.y * s.y), e.width = n.width * s.x - e.x, e.height = n.height * s.y - e.y, r !== 1 && r !== 2 || (e.width -= e.x), r !== 1 && r !== 3 || (e.height -= e.y), e; } function Kn(t) { return t instanceof us; } function Zn(t) { return Kn(t) ? t : t.scene && Kn(t.scene) ? t.scene : t.parent && t.parent.scene && Kn(t.parent.scene) ? t.parent.scene : void 0; } function qn(t) { return t instanceof cs; } const $n = Phaser.Utils.Objects.GetValue; const Qn = Phaser.GameObjects.Group; const ts = function (t) { return t.add.text(0, 0, ''); }; const es = new Phaser.Geom.Rectangle(); var is = Phaser.Utils.Objects.GetValue; const ns = Ii.prototype.add; const ss = { pin(t) { return ns.call(this, t), this; }, addBackground(t, e, i) { return void 0 === this.backgroundChildren && (this.backgroundChildren = []), typeof e === 'string' && (i = e, e = void 0), void 0 === e && (e = 0), this.pin(t), this.backgroundChildren.push(t), this.getSizerConfig(t).padding = Wn(e), void 0 !== i && this.addChildrenMap(i, t), this; }, isBackground(t) { return void 0 !== this.backgroundChildren && this.backgroundChildren.indexOf(t) !== -1; } }; const rs = /(\S+)\[(\d+)\]/i; var os = Phaser.Geom.Rectangle; var as = new os(); const hs = (function () { function i(t, e) { B(this, i), this.gameObject = t, this.scene = t.scene, this.resetFromJSON(e), this.boot(); } return w(i, [{ key: 'resetFromJSON', value(t) { let e; let i; let n; let s; let r; let o; let a; let h; return void 0 !== t.x ? (e = null, i = t.x) : void 0 !== t.left ? (e = 0, i = t.left) : void 0 !== t.right ? (e = 1, i = t.right) : void 0 !== t.centerX && (e = 0.5, i = t.centerX), void 0 !== t.y ? (n = null, s = t.y) : void 0 !== t.top ? (n = 0, s = t.top) : void 0 !== t.bottom ? (n = 1, s = t.bottom) : void 0 !== t.centerY && (n = 0.5, s = t.centerY), void 0 !== i && (i = i.replace('left', '0%').replace('right', '100%').replace('center', '50%').split('%'), r = parseFloat(i[0]) / 100, o = i[1] === '' ? 0 : parseFloat(i[1])), void 0 !== s && (s = s.replace('top', '0%').replace('bottom', '100%').replace('center', '50%').split('%'), a = parseFloat(s[0]) / 100, h = s[1] === '' ? 0 : parseFloat(s[1])), this.setAlign(e, n), this.setPercentage(r, a), this.setOffset(o, h), this; } }, { key: 'boot', value() { this.scene.scale.on('resize', this.anchor, this), this.gameObject.on('destroy', this.destroy, this), this.anchor(); } }, { key: 'shutdown', value() { this.scene.scale.off('resize', this.anchor, this), this.gameObject = void 0, this.scene = void 0; } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setAlign', value(t, e) { return this.alignX = t, this.alignY = e, this; } }, { key: 'setPercentage', value(t, e) { return this.percentageX = t, this.percentageY = e, this; } }, { key: 'setOffset', value(t, e) { return this.offsetX = t, this.offsetY = e, this; } }, { key: 'anchor', value() { return this.viewport = Jn(this.scene, !0), this.updatePosition(), this; } }, { key: 'updatePosition', value() { const t = this.gameObject; return this.alignX === null ? t.x = this.anchorX : void 0 !== this.alignX && (t.x = this.anchorX + t.displayWidth * (t.originX - this.alignX)), this.alignY === null ? this.gameObject.y = this.anchorY : void 0 !== this.alignY && (t.y = this.anchorY + t.displayHeight * (t.originY - this.alignY)), this; } }, { key: 'anchorX', get() { return this.viewport.x + this.viewport.width * this.percentageX + this.offsetX; } }, { key: 'anchorY', get() { return this.viewport.y + this.viewport.height * this.percentageY + this.offsetY; } }]), i; }()); const ls = {
    setEventEmitter(t, e) { return void 0 === e && (e = Phaser.Events.EventEmitter), this._privateEE = void 0 === t, this._eventEmitter = this._privateEE ? new e() : t, this; }, destroyEventEmitter() { return this._eventEmitter && this._privateEE && this._eventEmitter.shutdown(), this; }, getEventEmitter() { return this._eventEmitter; }, on() { return this._eventEmitter && this._eventEmitter.on.apply(this._eventEmitter, arguments), this; }, once() { return this._eventEmitter && this._eventEmitter.once.apply(this._eventEmitter, arguments), this; }, off() { return this._eventEmitter && this._eventEmitter.off.apply(this._eventEmitter, arguments), this; }, emit(t) { return this._eventEmitter && t && this._eventEmitter.emit.apply(this._eventEmitter, arguments), this; }, addListener() { return this._eventEmitter && this._eventEmitter.addListener.apply(this._eventEmitter, arguments), this; }, removeListener() { return this._eventEmitter && this._eventEmitter.removeListener.apply(this._eventEmitter, arguments), this; }, removeAllListeners() { return this._eventEmitter && this._eventEmitter.removeAllListeners.apply(this._eventEmitter, arguments), this; }, listenerCount() { return this._eventEmitter ? this._eventEmitter.listenerCount.apply(this._eventEmitter, arguments) : 0; }, listeners() { return this._eventEmitter ? this._eventEmitter.listeners.apply(this._eventEmitter, arguments) : []; },
  }; var us = Phaser.Scene; var cs = Phaser.GameObjects.GameObject; const ds = Phaser.Utils.Objects.GetValue; const fs = (function () { function n(t, e) { B(this, n), this.parent = t, this.scene = Zn(t); let i = ds(e, 'eventEmitter', !1); !0 === i && (i = void 0), this.setEventEmitter(i), this.boot(); } return w(n, [{ key: 'boot', value() { qn(this.parent) ? this.parent.once && this.parent.on('destroy', this.destroy, this) : Kn(this.parent) && this.parent.events.once('shutdown', this.destroy, this); } }, { key: 'shutdown', value() { return this.stop(), Kn(this.parent) && this.parent.events.off('shutdown', this.destroy, this), this.destroyEventEmitter(), this.parent = void 0, this.scene = void 0, this; } }, { key: 'destroy', value() { return this.shutdown(), this; } }, { key: 'start', value(t) { return this.isRunning || (this.tween = this.scene.tweens.add(t).on('complete', this.complete, this), !1 === this.getEventEmitter() && this.setEventEmitter(this.tween)), this; } }, { key: 'restart', value() { return this.stop().start(), this; } }, { key: 'stop', value() { return this.tween && (this.getEventEmitter() === this.tween && this.setEventEmitter(!1), this.tween.remove(), this.tween = void 0), this; } }, { key: 'complete', value() { return this.stop(), this.getEventEmitter() && this.emit('complete'), this; } }, { key: 'isRunning', get() { return !!this.tween; } }]), n; }()); Object.assign(fs.prototype, ls); function vs(i, n) { return new Promise(((t, e) => { i.once(n, () => { t(); }); })); } function ps(t) { return vs(t, 'complete'); } function gs(t, e, i, n, s) { return !(!t || !t.getBounds) && (!(n && !n(t, e, i)) && (!!(Ws = t.getBounds(Ws)).contains(e, i) && !(s && !s(t, e, i)))); } function ys(t, e, i, n) { if (e) return gs(t, e.x, e.y, i, n); for (let s = t.scene.input.manager, r = s.pointersTotal, o = s.pointers, a = 0; a < r; a++) if (e = o[a], gs(t, e.x, e.y, i, n)) return !0; return !1; } function ms(t) { return t && typeof t === 'function'; } function bs(t, e, i, n, s) { return gs(t, e, i, Gs(n), Ns(s)); } function xs(t) { return !(t.rexSizer && t.rexSizer.hidden); } function ks(t, e, i) { !t || void 0 === e && void 0 === i || (t.resize ? (void 0 === e && (e = t.width), void 0 === i && (i = t.height), t.resize(e, i)) : (void 0 !== e && (t.displayWidth = e), void 0 !== i && (t.displayHeight = i))); } const Cs = Phaser.Utils.Objects.GetValue; const ws = Phaser.Utils.Objects.GetAdvancedValue; const Ss = (function () {
    i(s, fs); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t)).gameObject = t, i.scaleStart = {}, i.scaleEnd = {}, i.resetFromJSON(e), i; } return w(s, [{ key: 'resetFromJSON', value(t) { return this.setMode(Cs(t, 'mode', 0)), this.setScaleRange(ws(t, 'start', void 0), ws(t, 'end', 0)), this.setDelay(ws(t, 'delay', 0)), this.setDuration(ws(t, 'duration', 1e3)), this.setEase(Cs(t, 'ease', void 0)), this; } }, {
      key: 'toJSON',
      value() {
        return {
          mode: this.mode, startX: this.startX, startY: this.startY, endX: this.endX, endY: this.endY, delay: this.delay, duration: this.duration,
        };
      },
    }, { key: 'setMode', value(t) { return typeof t === 'string' && (t = Os[t]), this.mode = t, this; } }, { key: 'setScaleRange', value(t, e) { return typeof t === 'number' ? (this.startX = t, this.startY = t) : (this.startX = ws(t, 'x', this.gameObject.scaleX), this.startY = ws(t, 'y', this.gameObject.scaleY)), typeof e === 'number' ? (this.endX = e, this.endY = e) : (this.endX = ws(e, 'x', void 0), this.endY = ws(e, 'y', void 0)), this; } }, { key: 'setDelay', value(t) { return this.delay = t, this; } }, { key: 'setDuration', value(t) { return this.duration = t, this; } }, { key: 'setEase', value(t) { return void 0 === t && (t = 'Linear'), this.ease = t, this; } }, {
      key: 'start',
      value() {
        if (this.isRunning) return this; const t = {
          targets: this.gameObject, delay: this.delay, duration: this.duration, ease: this.ease, yoyo: this.mode == 2, repeat: this.mode == 2 ? -1 : 0,
        }; return void 0 !== this.startX && void 0 !== this.endX && (this.gameObject.scaleX = this.startX, t.scaleX = this.endX), void 0 !== this.startY && void 0 !== this.endY && (this.gameObject.scaleY = this.startY, t.scaleY = this.endY), g(p(s.prototype), 'start', this).call(this, t), this;
      },
    }, { key: 'complete', value() { return g(p(s.prototype), 'complete', this).call(this), this.mode === 1 && this.gameObject.destroy(), this; } }]), s;
  }()); var Os = { stop: 0, destroy: 1, yoyo: 2 }; const Ts = {}; const Ps = Phaser.Utils.Objects.IsPlainObject; const Ms = {
    popUp(t, e, i) { if (Ps(t)) { const n = t; t = n.duration, e = n.orientation, i = n.ease; } this._scale = (function (t, e, i, n, s) { switch (i) { case Ts.mode = 0: case 'x': Ts.start = { x: 0 }; break; case 1: case 'y': Ts.start = { y: 0 }; break; default: Ts.start = 0; } return Ts.end = 1, Ts.duration = e, Ts.ease = void 0 === n ? 'Cubic' : n, void 0 === s ? s = new Ss(t, Ts) : s.resetFromJSON(Ts), s.restart(), s; }(this, t, e, i, this._scale)), this._scale.once('complete', function () { this.emit('popup.complete', this); }, this); const s = this.getParentSizer(); if (s) { const r = this; this._scale.on('update', () => { s.resetChildPositionState(r); }); } return this; }, popUpPromise(t, e, i) { return this.popUp(t, e, i), ps(this._scale); }, scaleDownDestroy(t, e, i, n) { if (Ps(t)) { const s = t; t = s.duration, e = s.orientation, i = s.ease, n = s.destroy; } this._scale = (function (t, e, i, n, s, r) { s instanceof Ss && (r = s, s = void 0), void 0 === s && (s = !0); const o = {}; switch (o.mode = s ? 1 : 0, i) { case 0: case 'x': o.end = { x: 0 }; break; case 1: case 'y': o.end = { y: 0 }; break; default: o.end = 0; } return o.duration = e, o.ease = void 0 === n ? 'Linear' : n, void 0 === r ? r = new Ss(t, o) : r.resetFromJSON(o), r.restart(), r; }(this, t, e, i, n, this._scale)), this._scale.once('complete', function () { this.emit('scaledown.complete', this); }, this); const r = this.getParentSizer(); if (r) { const o = this; this._scale.on('update', () => { r.resetChildPositionState(o); }); } return this; }, scaleDownDestroyPromise(t, e, i, n) { return this.scaleDownDestroy(t, e, i, n), ps(this._scale); }, scaleDown(t, e, i) { return this.scaleDownDestroy(t, e, i, !1), this; }, scaleDownPromise(t, e, i) { return this.scaleDown(t, e, i), ps(this._scale); },
  }; const Es = Phaser.Utils.Objects.GetValue; const zs = Phaser.Utils.Objects.GetAdvancedValue; const Bs = (function () {
    i(s, fs); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t)).gameObject = t, i.alphaStart = void 0, i.alphaEnd = void 0, i.resetFromJSON(e), i; } return w(s, [{ key: 'resetFromJSON', value(t) { return this.setMode(Es(t, 'mode', 0)), this.setAlphaRange(zs(t, 'start', this.gameObject.alpha), zs(t, 'end', 0)), this.setDelay(zs(t, 'delay', 0)), this.setDuration(zs(t, 'duration', 1e3)), this; } }, {
      key: 'toJSON',
      value() {
        return {
          mode: this.mode, start: this.alphaStart, end: this.alphaEnd, delay: this.delay, duration: this.duration,
        };
      },
    }, { key: 'shutdown', value() { return g(p(s.prototype), 'shutdown', this).call(this), this.gameObject = void 0, this; } }, { key: 'setMode', value(t) { return typeof t === 'string' && (t = _s[t]), this.mode = t, this; } }, { key: 'setAlphaRange', value(t, e) { return this.alphaStart = t, this.alphaEnd = e, this; } }, { key: 'setDelay', value(t) { return this.delay = t, this; } }, { key: 'setDuration', value(t) { return this.duration = t, this; } }, {
      key: 'start',
      value() {
        return this.isRunning || (this.gameObject.setAlpha(this.alphaStart), g(p(s.prototype), 'start', this).call(this, {
          targets: this.gameObject, alpha: this.alphaEnd, delay: this.delay, duration: this.duration, ease: 'Linear', yoyo: this.mode == 2, repeat: this.mode == 2 ? -1 : 0,
        })), this;
      },
    }, { key: 'complete', value() { return g(p(s.prototype), 'complete', this).call(this), this.mode === 1 && this.gameObject.destroy(), this; } }]), s;
  }()); var _s = { stop: 0, destroy: 1, yoyo: 2 }; const js = Phaser.Utils.Objects.IsPlainObject; const Ds = {}; const Is = {}; const Ys = Phaser.Utils.Objects.IsPlainObject; const Rs = {
    fadeIn(t, e) { let i; let n; let s; let r; let o; let a; Ys(t) && (t = t.duration); this._fade = (n = t, s = e, r = (i = this)._fade, a = js(s) ? (o = s.start, s.end) : s, void 0 === o && (o = 0), void 0 === a && (a = i.alpha), Ds.mode = 0, Ds.start = o, Ds.end = a, Ds.duration = n, void 0 === r ? r = new Bs(i, Ds) : r.resetFromJSON(Ds), r.restart(), r), this._fade.once('complete', function () { this.emit('fadein.complete', this); }, this); const h = this.getParentSizer(); if (h) { const l = this; this._fade.on('update', () => { h.resetChildAlphaState(l); }); } return this; }, fadeInPromoise(t, e) { return this.fadeIn(t, e), ps(this._fade); }, fadeOutDestroy(t, e) { if (Ys(t)) { const i = t; t = i.duration, e = i.destroy; } let n; let s; let r; let o; this._fade = (s = t, r = e, o = (n = this)._fade, r instanceof Bs && (o = r, r = void 0), void 0 === r && (r = !0), Is.mode = r ? 1 : 0, Is.end = 0, Is.duration = s, void 0 === o ? o = new Bs(n, Is) : o.resetFromJSON(Is), o.restart(), o), this._fade.once('complete', function () { this.emit('fadeout.complete', this); }, this); const a = this.getParentSizer(); if (a) { const h = this; this._fade.on('update', () => { a.resetChildAlphaState(h); }); } return this; }, fadeOutDestroyPromise(t, e) { return this.fadeOutDestroy(t, e), ps(this._fade); }, fadeOut(t) { return this.fadeOutDestroy(t, !1), this; }, fadeOutPromise(t) { return this.fadeOut(t), ps(this._fade); },
  }; const Ls = Phaser.Utils.Objects.GetValue; const Fs = Phaser.Utils.Objects.GetAdvancedValue; const As = (function () {
    i(s, fs); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t)).gameObject = t, i.resetFromJSON(e), i; } return w(s, [{ key: 'resetFromJSON', value(t) { if (this.setMode(Ls(t, 'mode', 0)), t && (t.hasOwnProperty('x') || t.hasOwnProperty('y'))) { const e = Fs(t, 'x', void 0); const i = Fs(t, 'y', void 0); this.setTargetPosition(e, i); } else this.setTargetPosition(t); return this.setDelay(Fs(t, 'delay', 0)), this.setDuration(Fs(t, 'duration', 1e3)), this.setEase(Ls(t, 'ease', void 0)), this; } }, {
      key: 'toJSON',
      value() {
        return {
          mode: this.mode, startX: this.startX, startY: this.startY, endX: this.endX, endY: this.endY, delay: this.delay, duration: this.duration,
        };
      },
    }, { key: 'setMode', value(t) { return typeof t === 'string' && (t = Xs[t]), this.mode = t, this; } }, { key: 'setTargetPosition', value(t, e) { if (typeof t === 'number' || typeof e === 'number') this.startX = this.gameObject.x, this.startY = this.gameObject.y, this.endX = t, this.endY = e; else { const i = t; this.startX = Fs(i, 'startX', void 0), this.startY = Fs(i, 'startY', void 0), this.endX = Fs(i, 'endX', void 0), this.endY = Fs(i, 'endY', void 0); } return this; } }, { key: 'setDelay', value(t) { return this.delay = t, this; } }, { key: 'setDuration', value(t) { return this.duration = t, this; } }, { key: 'setEase', value(t) { return void 0 === t && (t = 'Linear'), this.ease = t, this; } }, {
      key: 'start',
      value() {
        if (this.isRunning) return this; const t = {
          targets: this.gameObject, delay: this.delay, duration: this.duration, ease: this.ease, yoyo: this.mode == 2, repeat: this.mode == 2 ? -1 : 0,
        }; return void 0 !== this.startX && void 0 !== this.endX && (this.gameObject.setX(this.startX), t.x = this.endX), void 0 !== this.startY && void 0 !== this.endY && (this.gameObject.setY(this.startY), t.y = this.endY), g(p(s.prototype), 'start', this).call(this, t), this;
      },
    }, { key: 'complete', value() { return g(p(s.prototype), 'complete', this).call(this), this.mode === 1 && this.gameObject.destroy(), this; } }]), s;
  }()); var Xs = { stop: 0, destroy: 1, yoyo: 2 }; const Hs = function (t, e) { if (typeof t === 'number') return t; const i = t[0]; const n = parseFloat(t.substr(2)); switch (i) { case '+': return e + n; case '-': return e - n; case '*': return e * n; case '/': return e / n; } }; const Us = Phaser.Utils.Objects.IsPlainObject; const Vs = {
    moveFrom(t, e, i, n, s) { if (Us(e)) { const r = e; e = r.x, i = r.y, t = r.duration, n = r.ease; } this._easeMove = (function (t, e, i, n, s, r, o) { r instanceof As && (o = r, r = void 0), void 0 === r && (r = !1); const a = {}; return a.mode = r ? 1 : 0, void 0 !== i && (a.startX = Hs(i, t.x), a.endX = t.x), void 0 !== n && (a.startY = Hs(n, t.y), a.endY = t.y), a.duration = e, a.ease = void 0 === s ? 'Linear' : s, void 0 === o ? o = new As(t, a) : o.resetFromJSON(a), o.restart(), o; }(this, t, e, i, n, s, this._easeMove)), this._easeMove.once('complete', function () { this.emit('movefrom.complete', this); }, this); const o = this.getParentSizer(); if (o) { const a = this; this._easeMove.on('update', () => { o.resetChildPositionState(a); }); } return this; }, moveFromPromise(t, e, i, n, s) { return this.moveFrom(t, e, i, n, s), ps(this._easeMove); }, moveFromDestroy(t, e, i, n) { return this.moveFrom(t, e, i, n, !0), this; }, moveFromDestroyPromise(t, e, i, n) { return this.moveFromDestroy(t, e, i, n), ps(this._easeMove); }, moveTo(t, e, i, n, s) { if (Us(e)) { const r = e; e = r.x, i = r.y, t = r.duration, n = r.ease; } this._easeMove = (function (t, e, i, n, s, r, o) { r instanceof As && (o = r, r = void 0), void 0 === r && (r = !1); const a = {}; return a.mode = r ? 1 : 0, void 0 !== i && (a.startX = t.x, a.endX = Hs(i, t.x)), void 0 !== n && (a.startY = t.y, a.endY = Hs(n, t.y)), a.duration = e, a.ease = void 0 === s ? 'Linear' : s, void 0 === o ? o = new As(t, a) : o.resetFromJSON(a), o.restart(), o; }(this, t, e, i, n, s, this._easeMove)), this._easeMove.once('complete', function () { this.emit('moveto.complete', this); }, this); const o = this.getParentSizer(); if (o) { const a = this; this._easeMove.on('update', () => { o.resetChildPositionState(a); }); } return this; }, moveToPromise(t, e, i, n, s) { return this.moveTo(t, e, i, n, s), ps(this._easeMove); }, moveToDestroy(t, e, i, n) { return this.moveTo(t, e, i, n, !0), this; }, moveToDestroyPromise(t, e, i, n) { return this.moveToDestroy(t, e, i, n, !0), ps(this._easeMove); },
  }; var Ws = void 0; var Gs = function (n) { return n ? function (t, e, i) { return !!xs(t) && (n(t, e, i), !0); } : xs; }; var Ns = function (t) { return t; }; const Js = Phaser.Display.Align.CENTER; const Ks = function (t, e, i) { const n = this.getTopmostSizer(); n.x += e - this.x, n.y += i - this.y; }; const Zs = {
    getSizerConfig: pn, pushIntoBounds(t) { return void 0 === t && (t = gn(this.scene)), this.left = Math.max(this.left, t.left), this.right = Math.min(this.right, t.right), this.top = Math.max(this.top, t.top), this.bottom = Math.min(this.bottom, t.bottom), this; }, drawBounds(t, e) { let i; let n; let s; let r; const o = t.scene; if (typeof e === 'number')i = e; else { i = $n(e, 'color', 16777215); const a = $n(e, 'name', !1); a && (n = $n(a, 'createTextCallback', ts), s = $n(a, 'createTextCallbackScope', void 0), typeof (r = $n(a, 'align', 'left-top')) === 'string' && (r = bn[r])); } if (n && !t.children) { t.children = new Qn(o), t.on('destroy', () => { t.children.destroy(!0), t.children = void 0; }); const h = t.clear.bind(t); t.clear = function () { h(), t.children.clear(!1, !0); }; } for (var l, u, c = this.getAllChildren([this]), d = 0, f = c.length; d < f; d++)(l = c[d]).getBounds && (i && t.lineStyle(1, i).strokeRectShape(l.getBounds(es)), l.name && n && (u = s ? n.call(s, o) : n(o)) && (u.setText(l.name), t.children.add(u), xn.setPosition(es.x, es.y).setSize(es.width, es.height), Vn(u, xn, r))); return this; }, getChildrenWidth() { return 0; }, getChildrenHeight() { return 0; }, addChildrenMap: Gn, addElement: Gn, getElement(t, e) { if (typeof t === 'string' && (t = t.split('.')), t.length !== 0) { let i = t.shift(); let n = null; if (i.charAt(0) === '#')i = i.substring(1), n = this.getByName(i, e); else if (i.indexOf('[') === -1) this.childrenMap && (n = this.childrenMap[i]); else { const s = i.match(rs); if (s != null && this.childrenMap) { const r = this.childrenMap[s[1]]; r && (n = r[s[2]]); } } return t.length === 0 ? n : n && n.childrenMap ? n.getElement(t) : null; } }, getAllChildrenSizers(t) { void 0 === t && (t = []); for (let e = t.length, i = this.getChildrenSizers(t), n = t.length, s = e; s < n; s++)i[s].getAllChildrenSizers(t); return t; }, getChildrenSizers(t) { return void 0 === t && (t = []), t; }, preLayout(t) { if (!t) { this._layoutInit(); for (var e, i = this.getChildrenSizers(), n = 0, s = i.length; n < s; n++)!(e = i[n]).rexSizer.hidden && e.dirty && e.preLayout(); } }, _layoutInit: Nn, layout() { return this._layout(), this; }, _layout(t, e, i) { return this.rexSizer.hidden || !this.dirty ? this : (this.preLayout(t), void 0 === e && (e = Math.max(this.childrenWidth, this.minWidth)), void 0 === i && (i = Math.max(this.childrenHeight, this.minHeight)), this.resize(e, i), this.layoutBackgrounds(), this.postLayout()); }, layoutBackgrounds() { if (void 0 !== this.backgroundChildren) for (var t, e, i, n, s, r, o, a = this.backgroundChildren, h = this.left, l = this.top, u = this.width, c = this.height, d = 0, f = a.length; d < f; d++)(e = (t = a[d]).rexSizer).hidden || (n = h + (i = e.padding).left, s = l + i.top, r = u - i.left - i.right, o = c - i.top - i.bottom, ks(t, r, o), xn.setPosition(n, s).setSize(r, o), Vn(t, xn, Js), this.resetChildPositionState(t)); }, postLayout() { return this._anchor && this._anchor.updatePosition(), this; }, setAnchor(t) { return void 0 === this._anchor ? this._anchor = new hs(this, t) : this._anchor.resetFromJSON(t), this; }, isInTouching(t, e) { return void 0 === e && (e = this), ys(e, t); }, pointToChild(t, e, i, n, s) { if (ms(i) || (s = i, n = i = void 0), void 0 === s && (s = this.sizerChildren ? this.sizerChildren : this.children), yi(s)) { for (var r, o = 0, a = s.length; o < a; o++) if (r = s[o], bs(r, t, e, i, n)) return r; } else for (const h in s) if (r = s[h], bs(r, t, e, i, n)) return r; return null; }, setDraggable(t, e) { const i = k(t); return i === 'string' ? t = this.getElement(t) : void 0 !== t && i == 'object' || (e = t, t = this), void 0 === e && (e = !0), t.input && t.input.hasOwnProperty('draggable') ? t.input.draggable = e : e && (t.setInteractive(), t.scene.input.setDraggable(t), t.on('drag', Ks, this)), this; },
  }; Object.assign(Zs, ss, { getParentSizer(t) { return this.getParent(t); }, getTopmostSizer(t) { return this.getTopmostParent(t); } }, Ms, Rs, Vs); const qs = Phaser.Utils.Objects.GetValue; const $s = (function () { i(l, Ii); const h = S(l); function l(t, e, i, n, s, r) { let o; B(this, l), (o = h.call(this, t, e, i, 2, 2)).isRexSizer = !0, o.setMinSize(n, s), o.setName(qs(r, 'name', '')), o.rexSizer = {}, o.backgroundChildren = void 0, o.sizerChildren = void 0; const a = qs(r, 'anchor', void 0); return a && o.setAnchor(a), o.space = Wn(qs(r, 'space', 0)), o.setDraggable(qs(r, 'draggable', !1)), o.setDirty(!0), o; } return w(l, [{ key: 'destroy', value(t) { this.scene && (void 0 !== this.backgroundChildren && (this.backgroundChildren.length = 0), g(p(l.prototype), 'destroy', this).call(this, t)); } }, { key: 'setMinSize', value(t, e) { return this.setMinWidth(t).setMinHeight(e), this; } }, { key: 'setMinWidth', value(t) { return t == null && (t = 0), this.minWidth = t, this; } }, { key: 'setMinHeight', value(t) { return t == null && (t = 0), this.minHeight = t, this; } }, { key: 'setDirty', value(t) { return void 0 === t && (t = !0), this.dirty = t, this; } }, { key: 'alignLeft', value(t) { return this.left = t, this; } }, { key: 'alignRight', value(t) { return this.right = t, this; } }, { key: 'alignCenterX', value(t) { return this.centerX = t, this; } }, { key: 'alignTop', value(t) { return this.top = t, this; } }, { key: 'alignBottom', value(t) { return this.bottom = t, this; } }, { key: 'alignCenterY', value(t) { return this.centerY = t, this; } }, { key: 'childrenWidth', get() { return void 0 === this._childrenWidth && (this._childrenWidth = this.getChildrenWidth()), this._childrenWidth; } }, { key: 'childrenHeight', get() { return void 0 === this._childrenHeight && (this._childrenHeight = this.getChildrenHeight()), this._childrenHeight; } }, { key: 'left', get() { return this.x - kn(this) * this.originX; }, set(t) { this.x += t - this.left; } }, { key: 'right', get() { return this.left + kn(this); }, set(t) { this.x += t - this.right; } }, { key: 'centerX', get() { return this.left + kn(this) / 2; }, set(t) { this.x += t - this.centerX; } }, { key: 'top', get() { return this.y - Cn(this) * this.originY; }, set(t) { this.y += t - this.top; } }, { key: 'bottom', get() { return this.top + Cn(this); }, set(t) { this.y += t - this.bottom; } }, { key: 'centerY', get() { return this.top + Cn(this) / 2; }, set(t) { this.y += t - this.centerY; } }, { key: 'innerLeft', get() { return this.left + this.space.left; } }, { key: 'innerRight', get() { return this.right - this.space.right; } }, { key: 'innerTop', get() { return this.top + this.space.top; } }, { key: 'innerBottom', get() { return this.bottom - this.space.bottom; } }, { key: 'innerWidth', get() { return this.width - this.space.left - this.space.right; } }, { key: 'innerHeight', get() { return this.height - this.space.top - this.space.bottom; } }]), l; }()); Object.assign($s.prototype, Zs); function Qs(t, e, i, n, s, r, o) { this.pin(t); const a = k(e); if (e === null) return this; if (a !== 'number') if (a === 'string')e = nr[e]; else if (tr(e)) { var h; e = er(h = e, 'proportion', 0), i = er(h, 'align', ir), n = er(h, 'padding', 0), s = er(h, 'expand', !1), r = er(h, 'key', void 0), o = er(h, 'index', void 0); } return typeof i === 'string' && (i = bn[i]), void 0 === e && (e = 0), void 0 === i && (i = ir), void 0 === n && (n = 0), void 0 === s && (s = !1), (h = this.getSizerConfig(t)).proportion = e, h.align = i, h.padding = Wn(n), h.expand = s, void 0 === o || o >= this.sizerChildren.length ? this.sizerChildren.push(t) : this.sizerChildren.splice(o, 0, t), void 0 !== r && this.addChildrenMap(r, t), this; } var tr = Phaser.Utils.Objects.IsPlainObject; var er = Phaser.Utils.Objects.GetValue; var ir = Phaser.Display.Align.CENTER; var nr = { min: 0, full: -1 }; const sr = { add: Qs, addSpace(t) { let e; let i; return void 0 === t && (t = 1), Qs.call(this, (e = this.scene, (i = e.add.zone(0, 0, 1, 1)).isRexSpace = !0, i), t), this; }, insert(t, e, i, n, s, r, o) { return Qs.call(this, e, i, n, s, r, o, t), this; } }; const rr = Phaser.Utils.Array.Remove; const or = Ii.prototype.remove; const ar = Ii.prototype.clear; const hr = { remove(t, e) { return this.getParentSizer(t) !== this || (rr(this.sizerChildren, t), or.call(this, t, e)), this; }, removeAll(t) { for (let e = 0, i = this.sizerChildren; e < i; e++) this.remove(this.sizerChildren[e], t); return this.sizerChildren.length = 0, this; }, clear(t) { return this.sizerChildren.length = 0, this.backgroundChildren && (this.backgroundChildren.length = 0), ar.call(this, t), this; } }; const lr = {
    getChildrenWidth(t) { if (this.rexSizer.hidden) return 0; void 0 === t && (t = !0); let e; let i; let n; let s = 0; const r = this.sizerChildren; if (this.orientation === 0) for (var o = 0, a = r.length; o < a; o++)(e = r[o]).rexSizer.hidden || (n = e.rexSizer.proportion === 0 || t && !e.isRexSpace && e.rexSizer.proportion > 0 ? e.isRexSizer ? Math.max(e.minWidth, e.childrenWidth) : kn(e) : 0, n += (i = e.rexSizer.padding).left + i.right, o > 0 && (n += this.space.item), s += n); else for (o = 0, a = r.length; o < a; o++)(e = r[o]).hasOwnProperty('rexSizer') && (e.rexSizer.hidden || (n = e.isRexSizer ? Math.max(e.minWidth, e.childrenWidth) : kn(e), n += (i = e.rexSizer.padding).left + i.right, s = Math.max(n, s))); return s + this.space.left + this.space.right; }, getChildrenHeight(t) { if (this.rexSizer.hidden) return 0; void 0 === t && (t = !0); let e; let i; let n; let s = 0; const r = this.sizerChildren; if (this.orientation === 0) for (var o = 0, a = r.length; o < a; o++)(e = r[o]).rexSizer.hidden || (n = e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : Cn(e), n += (i = e.rexSizer.padding).top + i.bottom, s = Math.max(n, s)); else for (o = 0, a = r.length; o < a; o++)(e = r[o]).hasOwnProperty('rexSizer') && (e.rexSizer.hidden || (n = e.rexSizer.proportion === 0 || t && !e.isRexSpace && e.rexSizer.proportion > 0 ? e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : Cn(e) : 0, n += (i = e.rexSizer.padding).top + i.bottom, o > 0 && (n += this.space.item), s += n)); return s + this.space.top + this.space.bottom; }, getChildrenProportion() { for (var t, e, i = 0, n = this.sizerChildren, s = 0, r = n.length; s < r; s++)(t = n[s]).rexSizer.hidden || (e = t.rexSizer.proportion) > 0 && (i += e); return i; }, getChildrenSizers(t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]).isRexSizer && t.push(e); return t; }, _layout(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; let n; if (this.preLayout(t), void 0 === e && (e = Math.max(this.childrenWidth, this.minWidth)), void 0 === i && (i = Math.max(this.childrenHeight, this.minHeight)), this.resize(e, i), this.childrenProportion > 0) { let s = this.orientation === 0 ? this.width - this.childrenWidth : this.height - this.childrenHeight; n = s > 0 ? (s = this.orientation === 0 ? this.width - this.getChildrenWidth(!1) : this.height - this.getChildrenHeight(!1)) / this.childrenProportion : 0; } else n = 0; this.proportionLength = n; for (var r, o, a, h, l, u, c, d, f, v, p, g, y, m, b, x, k, C = this.sizerChildren, w = this.innerLeft, S = this.innerTop, O = this.innerWidth, T = this.innerHeight, P = w, M = S, E = 0, z = C.length; E < z; E++)(r = C[E]).rexSizer.hidden || (a = (o = r.rexSizer).padding, m = this, b = void 0, x = r.rexSizer, k = x.padding, m.orientation === 0 ? x.proportion > 0 && m.proportionLength > 0 && (b = x.proportion * m.proportionLength) : x.expand && (b = m.innerWidth - k.left - k.right), d = b, v = this, p = void 0, g = r.rexSizer, y = g.padding, v.orientation === 0 ? g.expand && (p = v.innerHeight - y.top - y.bottom) : g.proportion > 0 && v.proportionLength > 0 && (p = g.proportion * v.proportionLength), f = p, r.isRexSizer ? r._layout(this, d, f) : ks(r, d, f), void 0 === d && (d = kn(r)), void 0 === f && (f = Cn(r)), c = this.orientation === 0 ? (h = P + a.left, u = o.proportion === 0 || n === 0 ? d : o.proportion * n, l = M + a.top, T - a.top - a.bottom) : (h = P + a.left, u = O - a.left - a.right, l = M + a.top, o.proportion === 0 || n === 0 ? f : o.proportion * n), xn.setPosition(h, l).setSize(u, c), Vn(r, xn, o.align), this.resetChildPositionState(r), this.orientation === 0 ? P += u + a.left + a.right + this.space.item : M += c + a.top + a.bottom + this.space.item); return this.layoutBackgrounds(), this.postLayout(); }, _layoutInit() { Nn.call(this), this._childrenProportion = void 0; },
  }; Object.assign(lr, sr, hr); const ur = {
    x: 0, h: 0, horizontal: 0, 'left-to-right': 0, y: 1, v: 1, vertical: 1, 'top-to-bottom': 1,
  }; const cr = Phaser.Utils.Objects.IsPlainObject; const dr = Phaser.Utils.Objects.GetValue; const fr = (function () { i(l, $s); const h = S(l); function l(t, e, i, n, s, r, o) { let a; return B(this, l), cr(e) ? (e = dr(o = e, 'x', 0), i = dr(o, 'y', 0), n = dr(o, 'width', void 0), s = dr(o, 'height', void 0), r = dr(o, 'orientation', 0)) : cr(n) ? (n = dr(o = n, 'width', void 0), s = dr(o, 'height', void 0), r = dr(o, 'orientation', 0)) : cr(r) && (r = dr(o = r, 'orientation', 0)), void 0 === r && (r = 0), (a = h.call(this, t, e, i, n, s, o)).type = 'rexSizer', a.sizerChildren = [], a.setOrientation(r), a.setItemSpacing(dr(o, 'space.item', 0)), a.addChildrenMap('items', a.sizerChildren), a; } return w(l, [{ key: 'destroy', value(t) { this.scene && (this.sizerChildren.length = 0, g(p(l.prototype), 'destroy', this).call(this, t)); } }, { key: 'setOrientation', value(t) { return typeof t === 'string' && (t = ur[t]), this.orientation = t, this; } }, { key: 'setItemSpacing', value(t) { return this.space.item = t, this; } }, { key: 'childrenProportion', get() { return void 0 === this._childrenProportion && (this._childrenProportion = this.getChildrenProportion()), this._childrenProportion; } }]), l; }()); Object.assign(fr.prototype, lr), c.register('sizer', function (t, e, i, n, s, r) { const o = new fr(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o; }), ut(window, 'RexPlugins.UI.Sizer', fr); function vr() { return Array.prototype.reduce.call(arguments, mr, 0); } function pr(t, e) { let i; const n = t.rexSizer; if (n.expand) { const s = n.padding; i = e - s.left - s.right; } return i; } function gr(t, e) { let i; const n = t.rexSizer; if (n.expand) { const s = n.padding; i = e - s.top - s.bottom; } return i; } function yr(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = t.length - 1); for (let s = i; s <= n; s++)t[s] = e; return t; } var mr = function (t, e) { return t + e; }; const br = Phaser.Utils.Objects.IsPlainObject; const xr = Phaser.Utils.Objects.GetValue; const kr = Phaser.Display.Align.CENTER; const Cr = { add(t, e, i, n, s, r, o) { this.pin(t), br(e) && (e = xr(a = e, 'column', void 0), i = xr(a, 'row', void 0), n = xr(a, 'align', kr), s = xr(a, 'padding', 0), r = xr(a, 'expand', !1), o = xr(a, 'key', void 0)); let a; const h = (function (t, e, i, n, s) { if (typeof t === 'number' || typeof e === 'number') if (void 0 === t) { for (var r = 0; r < n; r++) if (!i[o = e * n + r]) return o; } else if (void 0 === e) { for (r = 0; r < s; r++) if (!i[o = r * n + t]) return o; } else if (!i[o = e * n + t]) return o; else if (!0 === e) { var o; for (r = 0; r < n; r++) for (let a = 0; a < s; a++) if (!i[o = a * n + r]) return o; } else { r = 0; for (let h = i.length; r < h; r++) if (!i[r]) return r; } return null; }(e, i, this.sizerChildren, this.columnCount, this.rowCount)); return h === null || (typeof n === 'string' && (n = bn[n]), void 0 === n && (n = kr), void 0 === s && (s = 0), void 0 === r && (r = !0), (a = this.getSizerConfig(t)).align = n, a.padding = Wn(s), a.expand = r, this.sizerChildren[h] = t, void 0 !== o && this.addChildrenMap(o, t)), this; } }; const wr = Phaser.Utils.Array.Remove; const Sr = Ii.prototype.remove; const Or = Ii.prototype.clear; const Tr = {
    remove(t, e) { if (this.getParentSizer(t) !== this) return this; if (this.isBackground(t))wr(this.backgroundChildren, t); else { const i = this.sizerChildren.indexOf(t); i !== -1 && (this.sizerChildren[i] = null); } return Sr.call(this, t, e), this; }, removeAt(t, e, i) { const n = this.getChildAt(t, e); return n && this.remove(n, i), this; }, removeAll(t) { for (let e = 0, i = this.sizerChildren; e < i; e++) this.sizerChildren[e] && this.remove(this.sizerChildren[e], t); return this; }, clear(t) { return yr(this.sizerChildren, null), this.backgroundChildren && (this.backgroundChildren.length = 0), Or.call(this, t), this; },
  }; const Pr = Phaser.Utils.Objects.GetValue; const Mr = {
    getChildrenWidth() { if (this.rexSizer.hidden) return 0; for (var t, e, i, n, s = 0, r = this.sizerChildren, o = 0; o < this.columnCount; o++) { if ((t = 0) === this.columnProportions[o]) { for (let a = 0; a < this.rowCount; a++)(e = r[a * this.columnCount + o]) && (e.rexSizer.hidden || (n = e.isRexSizer ? Math.max(e.minWidth, e.childrenWidth) : kn(e), n += (i = e.rexSizer.padding).left + i.right, t = Math.max(t, n))); s += t; } this.columnWidth[o] = t; } return s + vr.apply(void 0, [this.space.left].concat(h(this.space.column), [this.space.right])); }, getChildrenHeight() { if (this.rexSizer.hidden) return 0; for (var t, e, i, n, s = 0, r = this.sizerChildren, o = 0; o < this.rowCount; o++) { if ((t = 0) === this.rowProportions[o]) { for (let a = 0; a < this.columnCount; a++)(e = r[o * this.columnCount + a]) && (e.rexSizer.hidden || (n = e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : Cn(e), n += (i = e.rexSizer.padding).top + i.bottom, t = Math.max(t, n))); s += t; } this.rowHeight[o] = t; } return s + vr.apply(void 0, [this.space.top].concat(h(this.space.row), [this.space.bottom])); }, getChildrenSizers(t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]) && e.isRexSizer && t.push(e); return t; }, _layout(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; this.preLayout(t); let n; let s; let r; let o; const a = this.totalColumnProportions; const h = this.totalRowProportions; if (void 0 === e) if (t && a > 0) { var l = this.rexSizer.padding; e = t.width - l.left - l.right; } else e = Math.max(this.childrenWidth, this.minWidth); if (void 0 === i) if (t && h > 0) { var l = this.rexSizer.padding; i = t.height - l.top - l.bottom; } else i = Math.max(this.childrenHeight, this.minHeight); this.resize(e, i), n = a > 0 ? (this.width - this.childrenWidth) / a : 0, s = h > 0 ? (this.height - this.childrenHeight) / h : 0; for (var u, c, d, f, v, p, g, y, m, b, x = this.innerLeft, k = x, C = this.innerTop, w = this.space.column, S = this.space.row, O = 0; O < this.rowCount; O++) { b = (y = this.rowProportions[O]) === 0 ? this.rowHeight[O] : y * s, k = x; for (let T = 0; T < this.columnCount; T++)m = (g = this.columnProportions[T]) === 0 ? this.columnWidth[T] : g * n, (r = this.getChildAt(T, O)) && !r.rexSizer.hidden && (v = pr(r, m), p = gr(r, b), r.isRexSizer ? r._layout(this, v, p) : ks(r, v, p), u = k + (l = (o = r.rexSizer).padding).left, d = m - l.left - l.right, c = C + l.top, f = b - l.top - l.bottom, xn.setPosition(u, c).setSize(d, f), Vn(r, xn, o.align), this.resetChildPositionState(r)), k += m + w[T]; C += b + S[O]; } return this.layoutBackgrounds(), this.postLayout(); }, resetGrid(t, e, i, n, s) { if (void 0 === i && (i = 0), void 0 === n && (n = 0), this.columnCount = t, this.rowCount = e, void 0 === this.sizerChildren ? this.sizerChildren = [] : this.removeAll(), this.sizerChildren.length = t * e, yr(this.sizerChildren, null), this.columnProportions = [], this.columnProportions.length = t, typeof i === 'number')yr(this.columnProportions, i); else for (var r = 0; r < t; r++) this.columnProportions[r] = i[r] || 0; if (this.rowProportions = [], this.rowProportions.length = e, typeof n === 'number')yr(this.rowProportions, n); else for (r = 0; r < e; r++) this.rowProportions[r] = n[r] || 0; this.columnWidth = [], this.columnWidth.length = t, this.rowHeight = [], this.rowHeight.length = e, this.space.column = [], this.space.column.length = t - 1; const o = Pr(s, 'column', 0); if (typeof o === 'number')yr(this.space.column, o); else { r = 0; for (var a = this.space.column.length; r < a; r++) this.space.column[r] = o[r] || 0; } this.space.row = [], this.space.row.length = e - 1; const h = Pr(s, 'row', 0); if (typeof h === 'number')yr(this.space.row, h); else for (r = 0, a = this.space.row.length; r < a; r++) this.space.row[r] = h[r] || 0; return this; },
  }; Object.assign(Mr, Cr, Tr); const Er = Phaser.Utils.Objects.IsPlainObject; const zr = Phaser.Utils.Objects.GetValue; const Br = (function () { i(d, $s); const c = S(d); function d(t, e, i, n, s, r, o, a, h, l) { let u; return B(this, d), Er(e) ? (e = zr(l = e, 'x', 0), i = zr(l, 'y', 0), n = zr(l, 'width', void 0), s = zr(l, 'height', void 0), r = zr(l, 'column', 0), o = zr(l, 'row', 0), a = zr(l, 'columnProportions', 0), h = zr(l, 'rowProportions', 0)) : Er(n) ? (n = zr(l = n, 'width', void 0), s = zr(l, 'height', void 0), r = zr(l, 'column', 0), o = zr(l, 'row', 0), a = zr(l, 'columnProportions', 0), h = zr(l, 'rowProportions', 0)) : Er(r) ? (r = zr(l = r, 'column', 0), o = zr(l, 'row', 0), a = zr(l, 'columnProportions', 0), h = zr(l, 'rowProportions', 0)) : Er(a) && (a = zr(l = a, 'columnProportions', 0), h = zr(l, 'rowProportions', 0)), (u = c.call(this, t, e, i, n, s, l)).type = 'rexGridSizer', u.resetGrid(r, o, a, h, zr(l, 'space', void 0)), u.addChildrenMap('items', u.sizerChildren), u; } return w(d, [{ key: 'destroy', value(t) { this.scene && (this.sizerChildren.length = 0, g(p(d.prototype), 'destroy', this).call(this, t)); } }, { key: 'setColumnProportion', value(t, e) { return t >= this.columnProportions.length || (this.columnProportions[t] = e), this; } }, { key: 'setRowProportion', value(t, e) { return t >= this.rowProportions.length || (this.rowProportions[t] = e), this; } }, { key: 'getChildAt', value(t, e) { return this.sizerChildren[e * this.columnCount + t]; } }, { key: 'childToGridIndex', value(t, e) { if (!t) return null; const i = this.sizerChildren.indexOf(t); return i === -1 ? null : (void 0 === e && (e = {}), e.x = i % this.columnCount, e.y = Math.floor(i / this.columnCount), e); } }, { key: 'totalColumnProportions', get() { for (var t, e = 0, i = 0; i < this.columnCount; i++)(t = this.columnProportions[i]) > 0 && (e += t); return e; } }, { key: 'totalRowProportions', get() { for (var t, e = 0, i = 0; i < this.rowCount; i++)(t = this.rowProportions[i]) > 0 && (e += t); return e; } }]), d; }()); Object.assign(Br.prototype, Mr), c.register('gridSizer', function (t, e, i, n, s, r, o, a, h) { const l = new Br(this.scene, t, e, i, n, s, r, o, a, h); return this.scene.add.existing(l), l; }), ut(window, 'RexPlugins.UI.GridSizer', Br); function _r(t, e, i, n) { return t === '\n' ? this.addNewLine() : (this.pin(t), Yr(e) && (e = Rr(s = e, 'padding', 0), i = Rr(s, 'key', void 0), n = Rr(s, 'index', void 0)), void 0 === e && (e = 0), (s = this.getSizerConfig(t)).align = Lr, s.padding = Wn(e), void 0 === n || n >= this.sizerChildren.length ? this.sizerChildren.push(t) : this.sizerChildren.splice(n, 0, t), void 0 !== i && this.addChildrenMap(i, t)), this; let s; } const jr = function (t) { const e = t.rexSizer.padding; return kn(t) + e.left + e.right; }; const Dr = function (t) { const e = t.rexSizer.padding; return Cn(t) + e.top + e.bottom; }; const Ir = function (t, e, i) { return e / t <= 0.25 ? e / (i - 1) : 0; }; var Yr = Phaser.Utils.Objects.IsPlainObject; var Rr = Phaser.Utils.Objects.GetValue; var Lr = Phaser.Display.Align.CENTER; const Fr = { add(t, e, i) { if (yi(t)) for (let n = t, s = 0, r = n.length; s < r; s++)_r.call(this, n[s], e); else _r.call(this, t, e, i); return this; }, addNewLine() { return this.sizerChildren.push('\n'), this; }, insert(t, e, i, n) { return _r.call(this, e, i, n, t), this; } }; const Ar = Phaser.Utils.Array.Remove; const Xr = Ii.prototype.remove; const Hr = Ii.prototype.clear; const Ur = { remove(t, e) { return this.getParentSizer(t) !== this || (Ar(this.sizerChildren, t), Xr.call(this, t, e)), this; }, removeAll(t) { for (let e = 0, i = this.sizerChildren; e < i; e++) this.remove(this.sizerChildren[e], t); return this.sizerChildren.length = 0, this; }, clear(t) { return this.sizerChildren.length = 0, this.backgroundChildren && (this.backgroundChildren.length = 0), Hr.call(this, t), this; } }; const Vr = {
    getChildrenWidth() { return this.rexSizer.hidden ? 0 : (this.orientation === 0 ? this.maxChildWidth : 0) + this.space.left + this.space.right; }, getChildrenHeight() { return this.rexSizer.hidden ? 0 : (this.orientation === 0 ? 0 : this.maxChildHeight) + this.space.top + this.space.bottom; }, getChildrenSizers(t) { void 0 === t && (t = []); for (var e, i = this.sizerChildren, n = 0, s = i.length; n < s; n++)(e = i[n]) !== '\n' && e.isRexSizer && t.push(e); return t; }, _layout(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; let n; this.preLayout(t), void 0 === e && (e = Math.max(this.maxChildWidth + this.space.left + this.space.right, this.minWidth)), void 0 === i && (i = Math.max(this.maxChildHeight + this.space.top + this.space.bottom, this.minHeight)), n = this.orientation === 0 ? e - this.space.left - this.space.right : i - this.space.top - this.space.bottom; const s = function (t) { for (var e, i, n, s, r, o = { lines: [], width: 0, height: 0 }, a = this.sizerChildren, h = 0, l = o.lines, u = 0, c = a.length; u < c; u++) { if ((e = a[u]) === '\n')e = void 0, r = !(i = 0); else { if (e.rexSizer.hidden) continue; e.isRexSizer && e.layout(), r = h < (i = (this.orientation === 0 ? jr : Dr)(e)); }r && (s && (s.width = t - (h + this.space.item), o.width = Math.max(o.width, s.width), o.height += s.height + this.space.line), s = { children: [], height: 0 }, l.push(s), h = t), h -= i + this.space.item, e && (s.children.push(e), n = (this.orientation === 0 ? Dr : jr)(e), s.height = Math.max(s.height, n)); } return s && (s.width = t - (h + this.space.item), o.width = Math.max(o.width, s.width), o.height += s.height), o; }.call(this, n); this.orientation === 0 ? i = Math.max(i, s.height + this.space.top + this.space.bottom) : e = Math.max(e, s.height + this.space.left + this.space.right), this.resize(e, i); for (var r, o, a, h, l, u, c, d, f, v, p = 0, g = this.innerLeft, y = this.innerTop, m = g, b = y, x = s.lines, k = 0, C = x.length; k < C; k++) { switch (f = (d = x[k]).children, this.rtl && f.reverse(), v = n - d.width, this.align) { case 0: break; case 1: this.orientation === 0 ? m += v : b += v; break; case 2: this.orientation === 0 ? m += v / 2 : b += v / 2; break; case 3: p = Ir(n, v, f.length); break; case 4: (p = Ir(n, v, f.length)) === 0 && (this.orientation === 0 ? m += v : b += v); break; case 5: (p = Ir(n, v, f.length)) === 0 && (this.orientation === 0 ? m += v / 2 : b += v / 2); } for (let w = 0, S = f.length; w < S; w++)a = (o = (r = f[w]).rexSizer).padding, this.orientation === 0 ? (h = m + a.left, w > 0 && (h += this.space.item), l = b + a.top, u = kn(r), c = Cn(r), m = h + u + a.right + p) : (h = m + a.left, l = b + a.top, w > 0 && (l += this.space.item), u = kn(r), b = l + (c = Cn(r)) + a.bottom + p), xn.setPosition(h, l).setSize(u, c), Vn(r, xn, o.align), this.resetChildPositionState(r); this.orientation === 0 ? (m = g, b += d.height + this.space.line) : (m += d.height + this.space.line, b = y); } return this.layoutBackgrounds(), this.postLayout(); }, _layoutInit() { Nn.call(this), this._maxChildWidth = void 0, this._maxChildHeight = void 0; },
  }; Object.assign(Vr, Fr, Ur); const Wr = Phaser.Utils.Objects.IsPlainObject; const Gr = Phaser.Utils.Objects.GetValue; const Nr = (function () { i(h, $s); const a = S(h); function h(t, e, i, n, s, r) { let o; return B(this, h), Wr(e) ? (e = Gr(r = e, 'x', 0), i = Gr(r, 'y', 0), n = Gr(r, 'width', void 0), s = Gr(r, 'height', void 0)) : Wr(n) && (n = Gr(r = n, 'width', void 0), s = Gr(r, 'height', void 0)), (o = a.call(this, t, e, i, n, s, r)).type = 'rexFixWidthSizer', o.sizerChildren = [], o.setOrientation(Gr(r, 'orientation', 0)), o.setItemSpacing(Gr(r, 'space.item', 0)), o.setLineSpacing(Gr(r, 'space.line', 0)), o.setAlign(Gr(r, 'align', 0)), o.setRTL(Gr(r, 'rtl', !1)), o.addChildrenMap('items', o.sizerChildren), o; } return w(h, [{ key: 'destroy', value(t) { this.scene && (this.sizerChildren.length = 0, g(p(h.prototype), 'destroy', this).call(this, t)); } }, { key: 'setOrientation', value(t) { return typeof t === 'string' && (t = ur[t]), this.orientation = t, this; } }, { key: 'setItemSpacing', value(t) { return this.space.item = t, this; } }, { key: 'setLineSpacing', value(t) { return this.space.line = t, this; } }, { key: 'setAlign', value(t) { return typeof t === 'string' && (t = Jr[t]), this.align = t, this; } }, { key: 'setRTL', value(t) { return void 0 === t && (t = !0), this.rtl = t, this; } }, { key: 'maxChildWidth', get() { return void 0 === this._maxChildWidth && (this._maxChildWidth = function (t) { void 0 === t && (t = this.sizerChildren); for (var e, i, n = 0, s = 0, r = t.length; s < r; s++)(e = t[s]) !== '\n' && (i = e.isRexSizer ? Math.max(e.minWidth, e.childrenWidth) : kn(e), n = Math.max(i, n)); return n; }.call(this)), this._maxChildWidth; } }, { key: 'maxChildHeight', get() { return void 0 === this._maxChildHeight && (this._maxChildHeight = function (t) { void 0 === t && (t = this.sizerChildren); for (var e, i, n = 0, s = 0, r = t.length; s < r; s++)(e = t[s]) !== '\n' && (i = e.isRexSizer ? Math.max(e.minHeight, e.childrenHeight) : Cn(e), n = Math.max(i, n)); return n; }.call(this)), this._maxChildHeight; } }]), h; }()); var Jr = {
    left: 0, top: 0, right: 1, bottom: 1, center: 2, justify: 3, 'justify-left': 3, 'justify-top': 3, 'justify-right': 4, 'justify-bottom': 4, 'justify-center': 5,
  }; Object.assign(Nr.prototype, Vr), c.register('fixWidthSizer', function (t, e, i, n, s) { const r = new Nr(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r; }), ut(window, 'RexPlugins.UI.FixWidthSizer', Nr); const Kr = Phaser.Utils.Objects.IsPlainObject; const Zr = Phaser.Utils.Objects.GetValue; const qr = Phaser.Display.Align.CENTER; const $r = { add(t, e, i, n, s) { let r; this.pin(t), Kr(e) && (e = Zr(r = e, 'key', void 0), i = Zr(r, 'align', qr), n = Zr(r, 'padding', 0), s = Zr(r, 'expand', !0)); return void 0 === e && (e = Date.now()), typeof i === 'string' && (i = bn[i]), void 0 === i && (i = qr), void 0 === n && (n = 0), void 0 === s && (s = !0), (r = this.getSizerConfig(t)).align = i, r.padding = Wn(n), Kr(s) ? (r.expandWidth = Zr(s, 'width', !1), r.expandHeight = Zr(s, 'height', !1)) : (r.expandWidth = s, r.expandHeight = s), this.sizerChildren.hasOwnProperty(e) && this.sizerChildren[e].destroy(), this.sizerChildren[e] = t, this; } }; const Qr = Ii.prototype.remove; const to = Ii.prototype.clear; const eo = { remove(t, e) { let i; if (typeof t === 'string') { if (i = t, !this.sizerChildren.hasOwnProperty(i)) return this; } else { if (this.getParentSizer(t) !== this) return this; i = this.childToKey(t); } return delete this.sizerChildren[i], Qr.call(this, t, e), this; }, removeAll(t) { let e; for (const i in this.sizerChildren)e = this.sizerChildren[i], delete this.sizerChildren[i], Qr.call(this, e, t); return this; }, clear(t) { return this.removeAll(t), this.backgroundChildren && (this.backgroundChildren.length = 0), to.call(this, t), this; } }; const io = {
    getChildrenWidth() { if (this.rexSizer.hidden) return 0; let t; let e; let i; let n = 0; const s = this.sizerChildren; for (const r in s)i = (t = s[r]).isRexSizer ? Math.max(t.minWidth, t.childrenWidth) : kn(t), i += (e = t.rexSizer.padding).left + e.right, n = Math.max(i, n); return n + this.space.left + this.space.right; }, getChildrenHeight() { if (this.rexSizer.hidden) return 0; let t; let e; let i; let n = 0; const s = this.sizerChildren; for (const r in s)i = (t = s[r]).isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : Cn(t), i += (e = t.rexSizer.padding).top + e.bottom, n = Math.max(i, n); return n + this.space.top + this.space.bottom; }, getChildrenSizers(t) { void 0 === t && (t = []); let e; const i = this.sizerChildren; for (const n in i)(e = i[n]).isRexSizer && t.push(e); return t; }, _layout(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; let n; let s; let r; this.preLayout(t), void 0 === e && (e = Math.max(this.childrenWidth, this.minWidth)), void 0 === i && (i = Math.max(this.childrenHeight, this.minHeight)), this.resize(e, i); let o; let a; let h; let l; let u; let c; let d; let f; let v; let p; let g; let y; let m; let b; const x = this.innerLeft; const k = this.innerTop; const C = this.innerWidth; const w = this.innerHeight; const S = this.sizerChildren; for (const O in S)r = (s = (n = S[O]).rexSizer).padding, n.isRexSizer ? n._layout(this, (g = this, y = void 0, m = n.rexSizer, b = m.padding, m.expandWidth && (y = g.innerWidth - b.left - b.right), y), (d = this, f = void 0, v = n.rexSizer, p = v.padding, v.expandHeight && (f = d.innerHeight - p.top - p.bottom), f)) : (c = u = void 0, s.expandWidth && (u = C - r.left - r.right), s.expandHeight && (c = w - r.top - r.bottom), ks(n, u, c)), o = x + r.left, h = C - r.left - r.right, a = k + r.top, l = w - r.top - r.bottom, xn.setPosition(o, a).setSize(h, l), Vn(n, xn, s.align), this.resetChildPositionState(n); return this.layoutBackgrounds(), this.postLayout(); },
  }; Object.assign(io, $r, eo); function no(t, e) { if (Array.isArray(t)) return t.indexOf(e); for (const i in t) if (t[i] === e) return i; return null; } const so = Phaser.Utils.Objects.IsPlainObject; const ro = Phaser.Utils.Objects.GetValue; const oo = (function () { i(h, $s); const a = S(h); function h(t, e, i, n, s, r) { let o; return B(this, h), so(e) ? (e = ro(r = e, 'x', 0), i = ro(r, 'y', 0), n = ro(r, 'width', void 0), s = ro(r, 'height', void 0)) : so(n) && (n = ro(r = n, 'width', void 0), s = ro(r, 'height', void 0)), (o = a.call(this, t, e, i, n, s, r)).type = 'rexOverlapSizer', o.sizerChildren = {}, o.addChildrenMap('items', o.sizerChildren), o; } return w(h, [{ key: 'destroy', value(t) { this.scene && (dt(this.sizerChildren), g(p(h.prototype), 'destroy', this).call(this, t)); } }, { key: 'childToKey', value(t) { if (typeof t !== 'string') return no(this.sizerChildren, t); const e = t; return this.sizerChildren.hasOwnPropery(e) ? e : null; } }]), h; }()); Object.assign(oo.prototype, io), c.register('overlapSizer', function (t, e, i, n, s) { const r = new oo(this.scene, t, e, i, n, s); return this.scene.add.existing(r), r; }), ut(window, 'RexPlugins.UI.OverlapSizer', oo); function ao(t, e, i, n) { const s = new lo(e, i, n); return t && !t.isRexSizer && t.setMask(s.createGeometryMask()), this.pin(s), s; } const ho = Phaser.GameObjects.Graphics; var lo = (function () { i(r, ho); const s = S(r); function r(t, e, i) { let n; return B(this, r), void 0 === e && (e = 0), typeof e === 'string' && (e = uo[e]), void 0 === i && (i = 0), (n = s.call(this, t.scene)).parent = t, n.shape = e, n.padding = i, n.setPosition().resize(), n; } return w(r, [{ key: 'destroy', value() { return this.parent = void 0, g(p(r.prototype), 'destroy', this).call(this), this; } }, { key: 'setPosition', value(t, e) { const i = this.parent; return void 0 === t && (t = i.x), void 0 === e && (e = i.y), g(p(r.prototype), 'setPosition', this).call(this, t, e), this; } }, { key: 'resize', value(t, e, i) { const n = this.parent; if (void 0 === t && (t = n.width), void 0 === e && (e = n.height), void 0 === i && (i = this.padding), this.widthSave === t && this.heightSave === e && this.paddingSave === i) return this; switch (this.clear().fillStyle(16777215), this.shape) { case 1: var s = Math.min(t, e) / 2; this.fillCircle(0, 0, s + i); break; default: this.fillRect(-(t * n.originX) - i, -(e * n.originY) - i, t + 2 * i, e + 2 * i); } return this.widthSave = t, this.heightSave = e, this.paddingSave = i, this; } }]), r; }()); var uo = { rectangle: 0, circle: 1 }; const co = Phaser.Utils.Objects.GetValue; const fo = (function () { i(m, fr); const y = S(m); function m(t, e) { let i; B(this, m), (i = y.call(this, t, e)).type = 'rexLabel'; const n = co(e, 'background', void 0); const s = co(e, 'icon', void 0); let r = co(e, 'iconMask', void 0); const o = co(e, 'text', void 0); const a = co(e, 'action', void 0); let h = co(e, 'actionMask', void 0); const l = co(e, 'align', void 0); const u = co(e, 'space.icon', 0); const c = co(e, 'space.text', 0); n && i.addBackground(n), l !== 'right' && l !== 'bottom' && l !== 'center' || i.addSpace(), s && (i.orientation === 0 ? (o || a) && (f = { right: u }) : (o || a) && (f = { bottom: u }), i.add(s, 0, 'center', f), r = r && i.addChildMask(s, s, 1)); if (o) { let d; var f; let v; const p = co(e, 'expandTextWidth', !1); const g = co(e, 'expandTextHeight', !1); v = i.orientation === 0 ? (d = p ? 1 : 0, a && (f = { right: c }), g) : (d = g ? 1 : 0, a && (f = { bottom: c }), p), i.add(o, d, 'center', f, v); } return a && (i.add(a), h = h && i.addChildMask(a, a, 1)), l === 'center' && i.addSpace(), i.addChildrenMap('background', n), i.addChildrenMap('icon', s), i.addChildrenMap('iconMask', r), i.addChildrenMap('text', o), i.addChildrenMap('action', a), i.addChildrenMap('actionMask', h), i; } return w(m, [{ key: 'setText', value(t) { return this.text = t, this; } }, { key: 'appendText', value(t) { return this.text += t, this; } }, { key: '_layout', value(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; g(p(m.prototype), '_layout', this).call(this, t, e, i); const n = this.childrenMap.iconMask; n && (n.setPosition(), this.resetChildPositionState(n)); const s = this.childrenMap.actionMask; return s && (s.setPosition(), this.resetChildPositionState(s)), this; } }, { key: 'resize', value(t, e) { g(p(m.prototype), 'resize', this).call(this, t, e); const i = this.childrenMap.iconMask; i && i.resize(); const n = this.childrenMap.actionMask; return n && n.resize(), this; } }, { key: 'text', get() { const t = this.childrenMap.text; return void 0 === t ? '' : t.text ? t.text : t.getData('text'); }, set(t) { const e = this.childrenMap.text; void 0 !== e && (e.setText ? e.setText(t) : e.setData('text', t)); } }]), m; }()); const vo = { addChildMask: ao }; Object.assign(fo.prototype, vo), c.register('label', function (t) { const e = new fo(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Label', fo); const po = Phaser.Utils.Objects.GetValue; const go = (function () { function i(t, e) { B(this, i), this.gameObject = t, this.scene = Zn(t), this.setEventEmitter(po(e, 'eventEmitter', void 0)), this._enable = void 0, t.setInteractive(po(e, 'inputConfig', void 0)), this.resetFromJSON(e), this.boot(); } return w(i, [{ key: 'resetFromJSON', value(t) { return this.pointer = void 0, this.lastClickTime = void 0, this.setEnable(po(t, 'enable', !0)), this.setMode(po(t, 'mode', 1)), this.setClickInterval(po(t, 'clickInterval', 100)), this.setDragThreshold(po(t, 'threshold', void 0)), this; } }, { key: 'boot', value() { this.gameObject.on('pointerdown', this.onPress, this), this.gameObject.on('pointerup', this.onRelease, this), this.gameObject.on('pointerout', this.onPointOut, this), this.gameObject.on('pointermove', this.onMove, this), this.gameObject.on('destroy', this.destroy, this); } }, { key: 'shutdown', value() { this.destroyEventEmitter(), this.pointer = null, this.gameObject = null, this.scene = null; } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'toggleEnable', value() { return this.setEnable(!this.enable), this; } }, { key: 'setMode', value(t) { return typeof t === 'string' && (t = Oo[t]), this.mode = t, this; } }, { key: 'setClickInterval', value(t) { return this.clickInterval = t, this; } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'onPress', value(t, e, i, n) { void 0 === this.pointer && (this.pointer = t, this.mode === 0 && this.click(t.downTime, t, n)); } }, { key: 'onRelease', value(t, e, i, n) { this.pointer === t && (this.mode === 1 && this.click(t.upTime, t, n), this.pointer = void 0); } }, { key: 'onPointOut', value(t) { this.pointer === t && this.cancel(); } }, { key: 'onMove', value(t) { this.pointer === t && void 0 !== this.dragThreshold && t.getDistance() >= this.dragThreshold && this.cancel(); } }, { key: 'click', value(t, e, i) { if (!this.enable) return this; if (void 0 === t) return this.emit('click', this, this.gameObject, e, i), this; this.pointer = void 0; const n = this.lastClickTime; return void 0 !== n && t - n <= this.clickInterval || (this.lastClickTime = t, this.emit('click', this, this.gameObject, e, i)), this; } }, { key: 'cancel', value() { return this.pointer = void 0, this; } }, { key: 'enable', get() { return this._enable; }, set(t) { if (this._enable !== t) { t || this.cancel(); const e = (this._enable = t) ? 'enable' : 'disable'; this.emit(e, this, this.gameObject); } } }]), i; }()); Object.assign(go.prototype, ls); function yo(s, t) { s._buttonBehavior = new go(s, t), s._buttonBehavior.on('click', function (t, e, i, n) { To.call(this, 'button.click', e, i, n); }, this).on('enable', function (t, e) { To.call(this, 'button.enable', e); }, this).on('disable', function (t, e) { To.call(this, 'button.disable', e); }, this), s.on('pointerover', function (t, e, i, n) { To.call(this, 'button.over', s, t, n); }, this).on('pointerout', function (t, e) { To.call(this, 'button.out', s, t, e); }, this); } function mo(t) { if (this.buttons.length === 0) { if (!this.buttonsExpand) switch (this.buttonsAlign) { case 'right': case 'bottom': case 'center': Mo.call(this); }Po.call(this, t, this.buttonProportion, 'center', 0, !0), this.buttonsExpand || this.buttonsAlign === 'center' && Mo.call(this); } else { const e = this.sizerChildren.length - 1; this.sizerChildren[e].isRexSpace ? Eo.call(this, e, t, this.buttonProportion, 'center', 0, !0) : Po.call(this, t, this.buttonProportion, 'center', 0, !0); } return this.buttons.push(t), yo.call(this, t, this.clickConfig), this; } function bo(t, e) { return (t = this.getButton(t)) && (this.buttons.length === 1 ? this.clear(e) : (Bo(this.buttons, t), _o.call(this, t, e))), this; } function xo(t) { Yo(t, !1); } function ko(t) { Yo(t, !0); } function Co(t) { return !!t && !pn(t).hidden; } function wo(t, e) { void 0 === e && (e = !1); let i = Lo(t, 'dataManager', void 0); const s = Lo(t, 'setValueCallback', void 0); const r = Lo(t, 'setValueCallbackScope', void 0); void 0 === i && (this.setDataEnabled(), i = this.data), this.buttons.forEach(function (n) { const t = n.name; s && i.events.on('changedata-'.concat(t), (t, e, i) => { r ? s.call(r, n, e, i) : s(n, e, i); }, this), i.set(t, void 0), i.set(t, e); }), this._dataManager = i; } function So(t) { const e = Fo(t, 'type', void 0); e && Ao.hasOwnProperty(e) && Ao[e].call(this, t); } var Oo = {
    press: 0, pointerdown: 0, release: 1, pointerup: 1,
  }; var To = function (t, e, i, n) { let s; if (typeof e === 'number') { if (s = e, !(e = this.buttons[s])) return; } else if ((s = this.buttons.indexOf(e)) === -1) return; this.eventEmitter !== this && this.emit(t, e, s, i, n), void 0 !== this.groupName ? this.eventEmitter.emit(t, e, this.groupName, s, i, n) : this.eventEmitter.emit(t, e, s, i, n); }; var Po = fr.prototype.add; var Mo = fr.prototype.addSpace; var Eo = fr.prototype.insert; const zo = { addButton(t) { if (yi(t)) for (let e = t, i = 0, n = e.length; i < n; i++)mo.call(this, e[i]); else mo.call(this, t); return this; }, addButtons(t) { for (let e = 0, i = t.length; e < i; e++)mo.call(this, t[e]); return this; } }; var Bo = Phaser.Utils.Array.Remove; var _o = fr.prototype.remove; const jo = fr.prototype.clear; const Do = {
    remove(t, e) { if (yi(t)) for (let i = t, n = 0, s = i.length; n < s; n++)bo.call(this, i[n], e); else bo.call(this, t, e); return this; }, clear(t) { return this.buttons.length = 0, jo.call(this, t), this; }, removeButton(t, e) { return this.remove(t, e), this; }, clearButtons(t) { return this.clear(t), this; },
  }; const Io = function (t, e) { return t ? t.hasOwnProperty('name') ? t.name === e ? t : null : GetElementByName(t, e) : null; }; var Yo = function (t, e) { t && (pn(t).hidden = e, t.setVisible(!e)); }; const Ro = {
    getButton(t) { let e; switch (k(t)) { case 'number': e = this.buttons[t]; break; case 'string': e = (function (t, e) { if (!t) return null; if (yi(t)) { for (var i, n = 0, s = t.length; n < s; n++) if (i = Io(t[n], e)) return i; } else for (const r in t) if (i = Io(t[r], e)) return i; }(this.buttons, t)); break; default: e = t, this.buttons.indexOf(e) === -1 && (e = void 0); } return e; }, setButtonEnable(t, e) { if (void 0 === t || typeof t === 'boolean') { e = t; for (let i = 0, n = this.buttons.length; i < n; i++) this.buttons[i]._buttonBehavior.setEnable(e); } else this.getButton(t)._buttonBehavior.setEnable(e); return this; }, toggleButtonEnable(t) { if (void 0 === t || typeof t === 'boolean') for (let e = 0, i = this.buttons.length; e < i; e++) this.buttons[e]._buttonBehavior.toggleEnable(); else this.getButton(t)._buttonBehavior.toggleEnable(); return this; }, getButtonEnable(t) { return void 0 === t && (t = 0), this.getButton(t)._buttonBehavior.enable; }, emitButtonClick(t) { return To.call(this, 'button.click', t), this; }, showButton(t) { return xo(this.getButton(t)), this; }, hideButton(t) { return ko(this.getButton(t)), this; }, isButtonShown(t) { return Co(this.getButton(t)), this; }, forEachButtton(t, e) { for (let i = 0, n = this.buttons.length; i < n; i++)e ? t.call(e, this.buttons[i], i, this.buttons) : t(this.buttons[i], i, this.buttons); return this; },
  }; var Lo = Phaser.Utils.Objects.GetValue; var Fo = Phaser.Utils.Objects.GetValue; var Ao = {
    radio(t) {
      wo.call(this, t), this._value = void 0, Object.defineProperty(this, 'value', {
        get: function () { return this._value; }.bind(this), set: function (n) { if (n !== this._value) { this._value = n; const s = this._dataManager; this.buttons.forEach((t) => { const e = t.name; const i = s.get(e); e === n ? i || s.set(e, !0) : i && s.set(e, !1); }); } }.bind(this), enumerable: !0, configurable: !0,
      }), this.on('button.click', function (t) { this.value = t.name; }, this);
    },
    checkboxes(t) { wo.call(this, t), this.on('button.click', function (t) { const e = this._dataManager; const i = t.name; const n = e.get(i); e.set(i, !n); }, this); },
  }; const Xo = Phaser.Utils.Objects.GetValue; const Ho = (function () { i(a, fr); const o = S(a); function a(t, e) { let i; B(this, a), void 0 === e && (e = {}); const n = e.space; typeof n === 'number' && (e.space = { item: n }), (i = o.call(this, t, e)).type = 'rexButtons', i.eventEmitter = Xo(e, 'eventEmitter', _(i)), i.groupName = Xo(e, 'groupName', void 0), i.buttons = []; const s = Xo(e, 'background', void 0); const r = Xo(e, 'buttons', void 0); return i.buttonsExpand = Xo(e, 'expand', !1), i.buttonsAlign = Xo(e, 'align', void 0), i.buttonProportion = i.buttonsExpand ? 1 : 0, i.clickConfig = Xo(e, 'click', void 0), s && i.addBackground(s), r && i.addButtons(r), So.call(_(i), e), i.addChildrenMap('background', s), i.addChildrenMap('buttons', i.buttons), i; } return a; }()); Object.assign(Ho.prototype, zo, Do, Ro), c.register('buttons', function (t) { const e = new Ho(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Buttons', Ho); function Uo(t, e) { return (t = this.getButton(t)) && (Go(this.buttons, t), No.call(this, t, e)), this; } const Vo = Br.prototype.add; const Wo = { addButton(t, e, i) { return Vo.call(this, t, e, i, void 0, 0, this.buttonsExpand), this.buttons.push(t), yo.call(this, t, this.clickConfig), this; }, addButtons(t, e) { for (let i = 0, n = t; i < n; i++) this.addButton(t[i], void 0, e); return this; } }; var Go = Phaser.Utils.Array.Remove; var No = Br.prototype.remove; const Jo = Br.prototype.clear; const Ko = {
    remove(t, e) { if (yi(t)) for (let i = t, n = 0, s = i.length; n < s; n++)Uo.call(this, i[n], e); else Uo.call(this, t, e); return this; }, clear(t) { return this.buttons.length = 0, Jo.call(this, t), this; }, removeButton(t, e) { return this.remove(t, e), this; }, clearButtons(t) { return this.clear(t), this; },
  }; const Zo = Phaser.Utils.Objects.GetValue; const qo = (function () { i(m, Br); const y = S(m); function m(t, e) { let i; B(this, m), void 0 === e && (e = {}); let n = Zo(e, 'row', 0); let s = Zo(e, 'col', 0); const r = Zo(e, 'buttons', void 0); const o = Zo(e, 'expand', !0); const a = o ? 1 : 0; if (void 0 !== r) { n = Math.max(n, r.length); for (let h = 0, l = r.length; h < l; h++)s = Math.max(s, r[h].length); }e.row = n, e.column = s, e.columnProportions = a, e.rowProportions = a, (i = y.call(this, t, e)).type = 'rexGridButtons', i.eventEmitter = Zo(e, 'eventEmitter', _(i)), i.groupName = Zo(e, 'groupName', void 0), i.buttons = []; const u = Zo(e, 'background', void 0); i.buttonsExpand = o; let c = Zo(e, 'space', void 0); if (typeof c === 'number' && (c = { itemX: c, itemY: c }), i.clickConfig = Zo(e, 'click', void 0), u && i.addBackground(u), r) for (var d, f = 0, v = r.length; f < v; f++) for (let p = 0, g = r.length; p < g; p++)(d = r[f][p]) && i.addButton(d, p, f); return So.call(_(i), e), i.addChildrenMap('background', u), i.addChildrenMap('buttons', i.buttons), i; } return m; }()); Object.assign(qo.prototype, Wo, Ko, Ro), c.register('gridButtons', function (t) { const e = new qo(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.GridButtons', qo); function $o(t) { return ta.call(this, t), this.buttons.push(t), yo.call(this, t, this.clickConfig), this; } function Qo(t, e) { return (t = this.getButton(t)) && (this.buttons.length === 1 ? this.clear(e) : (ia(this.buttons, t), na.call(this, t, e))), this; } var ta = Nr.prototype.add; const ea = { addButton(t) { if (yi(t)) for (let e = t, i = 0, n = e.length; i < n; i++)$o.call(this, e[i]); else $o.call(this, t); return this; }, addButtons(t) { if (yi(t[0])) for (var e, i = t, n = 0, s = i.length - 1; n <= s; n++) { for (var r = 0, o = (e = i[n]).length; r < o; r++)$o.call(this, e[r]); s < n && ta.addNewLine(this); } else for (r = 0, o = t.length; r < o; r++)$o.call(this, t[r]); return this; } }; var ia = Phaser.Utils.Array.Remove; var na = Nr.prototype.remove; const sa = Nr.prototype.clear; const ra = {
    remove(t, e) { if (yi(t)) for (let i = t, n = 0, s = i.length; n < s; n++)Qo.call(this, i[n], e); else Qo.call(this, t, e); return this; }, clear(t) { return this.buttons.length = 0, sa.call(this, t), this; }, removeButton(t, e) { return this.remove(t, e), this; }, clearButtons(t) { return this.clear(t), this; },
  }; const oa = Phaser.Utils.Objects.GetValue; const aa = (function () { i(a, Nr); const o = S(a); function a(t, e) { let i; B(this, a), void 0 === e && (e = {}); const n = e.space; typeof n === 'number' && (e.space = { item: n, line: n }), (i = o.call(this, t, e)).type = 'rexFixWidthButtons', i.eventEmitter = oa(e, 'eventEmitter', _(i)), i.groupName = oa(e, 'groupName', void 0), i.buttons = []; const s = oa(e, 'background', void 0); const r = oa(e, 'buttons', void 0); return i.buttonsAlign = oa(e, 'align', void 0), i.clickConfig = oa(e, 'click', void 0), s && i.addBackground(s), r && i.addButtons(r), So.call(_(i), e), i.addChildrenMap('background', s), i.addChildrenMap('buttons', i.buttons), i; } return a; }()); Object.assign(aa.prototype, ea, ra, Ro), c.register('fixWidthButtons', function (t) { const e = new aa(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.FixWidthButtons', aa); const ha = Phaser.Utils.Objects.GetValue; const la = (function () {
    i(z, fr); const E = S(z); function z(t, e) {
      let i; B(this, z), void 0 === e && (e = {}), e.orientation = 1, (i = E.call(this, t, e)).type = 'rexDialog', i.eventEmitter = ha(e, 'eventEmitter', _(i)); let n; let s; let r; let o; const a = ha(e, 'background', void 0); const h = ha(e, 'title', void 0); const l = ha(e, 'toolbar', void 0); const u = ha(e, 'toolbarBackground', void 0); const c = ha(e, 'leftToolbar', void 0); const d = ha(e, 'leftToolbarBackground', void 0); const f = ha(e, 'content', void 0); const v = ha(e, 'description', void 0); const p = ha(e, 'choices', void 0); const g = ha(e, 'choicesBackground', void 0); const y = ha(e, 'actions', void 0); const m = ha(e, 'actionsBackground', void 0); const b = ha(e, 'click', void 0); if (a && i.addBackground(a), l && (r = new Ho(t, {
        groupName: 'toolbar', background: u, buttons: l, orientation: 0, space: { item: ha(e, 'space.toolbarItem', 0) }, click: b, eventEmitter: i.eventEmitter,
      })), c && (o = new Ho(t, {
        groupName: 'leftToolbar', background: d, buttons: c, orientation: 0, space: { item: ha(e, 'space.leftToolbarItem', 0) }, click: b, eventEmitter: i.eventEmitter,
      })), h && !l && !c) { var x = ha(e, 'align.title', 'center'); var k = ha(e, 'space.title', 0); (f || v || p || y) && (S = { bottom: k }); var C = ha(e, 'expand.title', !0); i.add(h, 0, x, S, C); } if (l && !h && !c) { k = ha(e, 'space.title', 0); (f || v || p || y) && (S = { bottom: k }); C = ha(e, 'expand.toolbar', !0); i.add(r, 0, 'right', S, C); } if (c && !h && !l) { k = ha(e, 'space.title', 0); (f || v || p || y) && (S = { bottom: k }); C = ha(e, 'expand.leftToolbar', !0); i.add(o, 0, 'left', S, C); } if (h && (l || c)) { const w = new fr(t, { orientation: 0 }); o && w.add(o, 0, 'right', 0, !1); x = ha(e, 'align.title', 'left'); (C = ha(e, 'expand.title', !0)) || x !== 'right' && x !== 'center' || w.addSpace(); var S = { left: ha(e, 'space.titleLeft', 0), right: ha(e, 'space.titleRight', 0) }; const O = C ? 1 : 0; w.add(h, O, 'center', S, C), C || x !== 'left' && x !== 'center' || w.addSpace(), r && w.add(r, 0, 'right', 0, !1); k = ha(e, 'space.title', 0); (f || v || p || y) && (S = { bottom: k }), i.add(w, 0, 'center', S, !0); } if (f) { x = ha(e, 'align.content', 'center'); const T = ha(e, 'space.content', 0); S = { left: ha(e, 'space.contentLeft', 0), right: ha(e, 'space.contentRight', 0), bottom: v || p || y ? T : 0 }, C = ha(e, 'expand.content', !0); i.add(f, 0, x, S, C); } if (v) { x = ha(e, 'align.description', 'center'); const P = ha(e, 'space.description', 0); S = { left: ha(e, 'space.descriptionLeft', 0), right: ha(e, 'space.descriptionRight', 0), bottom: p || y ? P : 0 }, C = ha(e, 'expand.description', !0); i.add(v, 0, x, S, C); } if (p) {
        x = ha(e, 'align.choices', 'center'); n = new Ho(t, {
          groupName: 'choices', background: g, buttons: p, orientation: 1, space: { item: ha(e, 'space.choice', 0) }, click: b, eventEmitter: i.eventEmitter, type: ha(e, 'choicesType', void 0), setValueCallback: ha(e, 'choicesSetValueCallback', void 0), setValueCallbackScope: ha(e, 'choicesSetValueCallbackScope', void 0),
        }); const M = ha(e, 'space.choices', 0); S = { left: ha(e, 'space.choicesLeft', 0), right: ha(e, 'space.choicesRight', 0), bottom: y ? M : 0 }, C = ha(e, 'expand.choices', !0); i.add(n, 0, x, S, C);
      } if (y) {
        s = new Ho(t, {
          groupName: 'actions', background: m, buttons: y, orientation: 0, space: { item: ha(e, 'space.action', 0) }, expand: ha(e, 'expand.actions', !1), align: ha(e, 'align.actions', 'center'), click: b, eventEmitter: i.eventEmitter,
        }); S = { left: ha(e, 'space.actionsLeft', 0), right: ha(e, 'space.actionsRight', 0) }; i.add(s, 0, 'center', S, !0);
      } return i.addChildrenMap('background', a), i.addChildrenMap('title', h), i.addChildrenMap('toolbar', l), i.addChildrenMap('leftToolbar', c), i.addChildrenMap('content', f), i.addChildrenMap('description', v), i.addChildrenMap('choices', p), i.addChildrenMap('actions', y), i.addChildrenMap('choicesSizer', n), i.addChildrenMap('actionsSizer', s), i.addChildrenMap('toolbarSizer', r), i.addChildrenMap('leftToolbarSizer', o), i;
    } return z;
  }()); Object.assign(la.prototype, {
    getChoice(t) { return this.childrenMap.choicesSizer.getButton(t); }, getAction(t) { return this.childrenMap.actionsSizer.getButton(t); }, getToolbar(t) { return this.childrenMap.toolbarSizer.getButton(t); }, getLeftToolbar(t) { return this.childrenMap.leftToolbarSizer.getButton(t); }, setChoiceEnable(t, e) { return this.childrenMap.choicesSizer.setButtonEnable(t, e), this; }, setActionEnable(t, e) { return this.childrenMap.actionsSizer.setButtonEnable(t, e), this; }, setToolbarEnable(t, e) { return this.childrenMap.toolbarSizer.setButtonEnable(t, e), this; }, setLeftToolbarEnable(t, e) { return this.childrenMap.leftToolbarSizer.setButtonEnable(t, e), this; }, toggleChoiceEnable(t) { return this.childrenMap.choicesSizer.toggleButtonEnable(t), this; }, toggleActionEnable(t) { return this.childrenMap.actionsSizer.toggleButtonEnable(t), this; }, toggleToolbarEnable(t) { return this.childrenMap.toolbarSizer.toggleButtonEnable(t), this; }, toggleLeftToolbarEnable(t) { return this.childrenMap.leftToolbarSizer.toggleButtonEnable(t), this; }, getChoiceEnable(t) { return this.childrenMap.choicesSizer.getButtonEnable(t); }, getActionEnable(t) { return this.childrenMap.actionsSizer.getButtonEnable(t); }, getToolbarEnable(t) { return this.childrenMap.toolbarSizer.getButtonEnable(t); }, getLeftToolbarEnable(t) { return this.childrenMap.leftToolbarSizer.getButtonEnable(t); }, emitChoiceClick(t) { return this.childrenMap.choicesSizer.emitButtonClick(t), this; }, emitActionClick(t) { return this.childrenMap.actionsSizer.emitButtonClick(t), this; }, emitToolbarClick(t) { return this.childrenMap.toolbarSizer.emitButtonClick(t), this; }, emitLeftToolbarClick(t) { return this.childrenMap.leftToolbarSizer.emitButtonClick(t), this; }, showChoice(t) { return this.childrenMap.choicesSizer.showButton(t), this; }, showAction(t) { return this.childrenMap.actionsSizer.showButton(t), this; }, showToolbar(t) { return this.childrenMap.toolbarSizer.showButton(t), this; }, showLeftToolbar(t) { return this.childrenMap.leftToolbarSizer.showButton(t), this; }, hideChoice(t) { return this.childrenMap.choicesSizer.hideButton(t), this; }, hideAction(t) { return this.childrenMap.actionsSizer.hideButton(t), this; }, hideToolbar(t) { return this.childrenMap.toolbarSizer.hideButton(t), this; }, hideLeftToolbar(t) { return this.childrenMap.leftToolbarSizer.hideButton(t), this; }, addChoice(t) { return this.childrenMap.choicesSizer.addButton(t), this; }, addAction(t) { return this.childrenMap.actionsSizer.addButton(t), this; }, addToolbar(t) { return this.childrenMap.toolbarSizer.addButton(t), this; }, addLeftToolbar(t) { return this.childrenMap.leftToolbarSizer.addButton(t), this; }, removeChoice(t, e) { return this.childrenMap.choicesSizer.removeButton(t, e), this; }, removeAction(t, e) { return this.childrenMap.actionsSizer.removeButton(t, e), this; }, removeToolbar(t, e) { return this.childrenMap.toolbarSizer.removeButton(t, e), this; }, removeLeftToolbar(t, e) { return this.childrenMap.leftToolbarSizer.removeButton(t, e), this; }, clearChoices(t) { return this.childrenMap.choicesSizer.clearButtons(t), this; }, clearActions(t) { return this.childrenMap.actionsSizer.clearButtons(t), this; }, clearToolbar(t) { return this.childrenMap.toolbarSizer.clearButtons(t), this; }, clearLeftToolbar(t) { return this.childrenMap.leftToolbarSizer.clearButtons(t), this; }, forEachChoice(t, e) { return this.childrenMap.choicesSizer.forEachButtton(t, e), this; }, forEachAction(t, e) { return this.childrenMap.actionsSizer.forEachButtton(t, e), this; }, forEachToolbar(t, e) { return this.childrenMap.toolbarSizer.forEachButtton(t, e), this; }, forEachLeftToolbar(t, e) { return this.childrenMap.leftToolbarSizer.forEachButtton(t, e), this; },
  }), c.register('dialog', function (t) { const e = new la(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Dialog', la); const ua = {
    getButtonsSizer(t) { return this.childrenMap[''.concat(t, 'ButtonsSizer')]; }, getButton(t, e) { const i = this.getButtonsSizer(t); return i ? i.getButton(e) : void 0; }, setButtonEnable(t, e, i) { return this.getButtonsSizer(t).setButtonEnable(e, i), this; }, setLeftButtonEnable(t, e) { return this.childrenMap.leftButtonsSizer.setButtonEnable(t, e), this; }, setRightButtonEnable(t, e) { return this.childrenMap.rightButtonsSizer.setButtonEnable(t, e), this; }, setTopButtonEnable(t, e) { return this.childrenMap.topButtonsSizer.setButtonEnable(t, e), this; }, setBottomButtonEnable(t, e) { return this.childrenMap.bottomButtonsSizer.setButtonEnable(t, e), this; }, toggleButtonEnable(t, e) { return this.getButtonsSizer(t).toggleButtonEnable(e), this; }, toggleLeftButtonEnable(t) { return this.childrenMap.leftButtonsSizer.toggleButtonEnable(t), this; }, toggleRightButtonEnable(t) { return this.childrenMap.rightButtonsSizer.toggleButtonEnable(t), this; }, toggleTopButtonEnable(t) { return this.childrenMap.topButtonsSizer.toggleButtonEnable(t), this; }, toggleBottomButtonEnable(t) { return this.childrenMap.bottomButtonsSizer.toggleButtonEnable(t), this; }, getButtonEnable(t, e) { return this.getButtonsSizer(t).getButtonEnable(e); }, getLeftButtonEnable(t) { return this.childrenMap.leftButtonsSizer.getButtonEnable(t); }, getRightButtonEnable(t) { return this.childrenMap.rightButtonsSizer.getButtonEnable(t); }, getTopButtonEnable(t) { return this.childrenMap.topButtonsSizer.getButtonEnable(t); }, getBottomButtonEnable(t) { return this.childrenMap.bottomButtonsSizer.getButtonEnable(t); }, emitButtonClick(t, e) { const i = this.getButtonsSizer(t); return i && i.emitButtonClick(e), this; }, emitLeftButtonClick(t) { return this.childrenMap.leftButtonsSizer.emitButtonClick(t), this; }, emitRightButtonClick(t) { return this.childrenMap.rightButtonsSizer.emitButtonClick(t), this; }, emitTopButtonClick(t) { return this.childrenMap.topButtonsSizer.emitButtonClick(t), this; }, emitBottomButtonClick(t) { return this.childrenMap.bottomButtonsSizer.emitButtonClick(t), this; }, getLeftButton(t) { return this.childrenMap.leftButtonsSizer.getButton(t); }, getRightButton(t) { return this.childrenMap.rightButtonsSizer.getButton(t); }, getTopButton(t) { return this.childrenMap.topButtonsSizer.getButton(t); }, getBottomButton(t) { return this.childrenMap.bottomButtonsSizer.getButton(t); }, showButton(t, e) { return xo(this.getButton(t, e)), this; }, showLeftButton(t) { return xo(this.getLeftButton(t)), this; }, showRightButton(t) { return xo(this.getRightButton(t)), this; }, showTopButton(t) { return xo(this.getTopButton(t)), this; }, showBottomButton(t) { return xo(this.getBottomButton(t)), this; }, hideButton(t, e) { return ko(this.getButton(t, e)), this; }, hideLeftButton(t) { return ko(this.getLeftButton(t)), this; }, hideRightButton(t) { return ko(this.getRightButton(t)), this; }, hideTopButton(t) { return ko(this.getTopButton(t)), this; }, hideBottomButton(t) { return ko(this.getBottomButton(t)), this; }, addButton(t, e) { return this.getButtonsSizer(t).addButton(e), this; }, addLeftButton(t) { return this.addButton('left', t), this; }, addRightButton(t) { return this.addButton('right', t), this; }, addTopButton(t) { return this.addButton('top', t), this; }, removeButton(t, e, i) { return this.getButtonsSizer(t).removeButton(e, i), this; }, removeLeftButton(t, e) { return this.removeButton('left', t, e), this; }, removeRightButton(t, e) { return this.removeButton('right', t, e), this; }, removeTopButton(t, e) { return this.removeButton('top', t, e), this; }, removeBottomButton(t, e) { return this.removeButton('bottom', t, e), this; }, clearButtons(t, e) { return this.getButtonsSizer(t).clearButtons(e), this; }, clearLeftButtons(t) { return this.clearButtons('left', t), this; }, clearRightButtons(t) { return this.clearButtons('right', t), this; }, clearTopButtons(t) { return this.clearButtons('top', t), this; }, clearBottomButtonss(t) { return this.clearButtons('bottom', t), this; }, forEachLeftButton(t, e) { return this.childrenMap.leftButtonsSizer.forEachButtton(t, e), this; }, forEachRightButton(t, e) { return this.childrenMap.rightButtonsSizer.forEachButtton(t, e), this; }, forEachTopButton(t, e) { return this.childrenMap.topButtonsSizer.forEachButtton(t, e), this; }, forEachBottomButton(t, e) { return this.childrenMap.bottomButtonsSizer.forEachButtton(t, e), this; },
  }; const ca = Phaser.Utils.Objects.GetValue; const da = (function () {
    i(M, Br); const P = S(M); function M(t, e) {
      let i; B(this, M), void 0 === e && (e = {}), e.column = 3, e.row = 3, (i = P.call(this, t, e)).type = 'rexTabs', i.eventEmitter = ca(e, 'eventEmitter', _(i)); let n; let s; let r; let o; const a = ca(e, 'background', void 0); const h = ca(e, 'panel', void 0); const l = ca(e, 'leftButtons', void 0); const u = ca(e, 'leftButtonsBackground', void 0); const c = ca(e, 'rightButtons', void 0); const d = ca(e, 'rightButtonsBackground', void 0); const f = ca(e, 'topButtons', void 0); const v = ca(e, 'topButtonsBackground', void 0); const p = ca(e, 'bottomButtons', void 0); const g = ca(e, 'bottomButtonsBackground', void 0); const y = ca(e, 'click', void 0); if (a && i.addBackground(a), h && i.add(h, 1, 1, 'center', 0, !0), l) {
        const m = ca(e, 'space.leftButtonsOffset', 0); const b = ca(e, 'space.leftButton', 0); n = new Ho(t, {
          groupName: 'left', background: u, buttons: l, orientation: 1, space: { item: b }, align: ca(e, 'align.leftButtons', void 0), click: y, eventEmitter: i.eventEmitter,
        }); var x = { top: m }; i.add(n, 0, 1, 'top', x, !1);
      } if (c) {
        const k = ca(e, 'space.rightButtonsOffset', 0); const C = ca(e, 'space.rightButton', 0); s = new Ho(t, {
          groupName: 'right', background: d, buttons: c, orientation: 1, space: { item: C }, align: ca(e, 'align.rightButtons', void 0), click: y, eventEmitter: i.eventEmitter,
        }); x = { top: k }; i.add(s, 2, 1, 'top', x, !1);
      } if (f) {
        const w = ca(e, 'space.topButtonsOffset', 0); const S = ca(e, 'space.topButton', 0); r = new Ho(t, {
          groupName: 'top', background: v, buttons: f, orientation: 0, space: { item: S }, align: ca(e, 'align.topButtons', void 0), click: y, eventEmitter: i.eventEmitter,
        }); x = { left: w }; i.add(r, 1, 0, 'left', x, !1);
      } if (p) {
        const O = ca(e, 'space.bottomButtonsOffset', 0); const T = ca(e, 'space.bottomButton', 0); o = new Ho(t, {
          groupName: 'bottom', background: g, buttons: p, orientation: 0, space: { item: T }, align: ca(e, 'align.bottomButtons', void 0), click: y, eventEmitter: i.eventEmitter,
        }); x = { left: O }; i.add(o, 1, 2, 'left', x, !1);
      } return i.addChildrenMap('background', a), i.addChildrenMap('panel', h), i.addChildrenMap('leftButtons', l), i.addChildrenMap('rightButtons', c), i.addChildrenMap('topButtons', f), i.addChildrenMap('bottomButtons', p), i.addChildrenMap('leftButtonsSizer', n), i.addChildrenMap('rightButtonsSizer', s), i.addChildrenMap('topButtonsSizer', r), i.addChildrenMap('bottomButtonsSizer', o), i;
    } return M;
  }()); Object.assign(da.prototype, ua), c.register('tabs', function (t) { const e = new da(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Tabs', da); function fa(t, e, i) { let n; let s; let r; return t.y === e.y ? (n = Math.min(t.x, e.x), s = Math.max(t.x, e.x), r = ya(i.x, n, s)) : t.x === e.x && (n = Math.min(t.y, e.y), s = Math.max(t.y, e.y), r = ya(i.y, n, s)), r; } function va(t, e, i) { this.enable && (ma.x = e, ma.y = i, this.value = fa(this.getStartPoint(), this.getEndPoint(), ma)); } function pa(t) { this.enable && t.isDown && (ba.x = t.worldX, ba.y = t.worldY, this.value = fa(this.getStartPoint(), this.getEndPoint(), ba)); } function ga(t, e) { void 0 === e && (e = xa); const i = this.childrenMap.thumb; const n = i.x; const s = i.y; return Vn(i, this, t), e.x = i.x, e.y = i.y, i.x = n, i.y = s, e; } var ya = Phaser.Math.Percent; var ma = {}; var ba = {}; var xa = {}; const ka = Phaser.Display.Align.LEFT_CENTER; const Ca = Phaser.Display.Align.TOP_CENTER; const wa = {}; const Sa = Phaser.Display.Align.RIGHT_CENTER; const Oa = Phaser.Display.Align.BOTTOM_CENTER; const Ta = {}; const Pa = Phaser.Math.Linear; const Ma = {}; const Ea = Phaser.Display.Align.LEFT_CENTER; const za = Phaser.Display.Align.TOP_CENTER; const Ba = Phaser.Utils.Objects.GetValue; const _a = Phaser.Math.Clamp; const ja = Phaser.Math.Linear; const Da = Phaser.Math.Percent; const Ia = Phaser.Math.Snap.To; const Ya = (function () { i(c, fr); const u = S(c); function c(t, e) { let i; B(this, c), (i = u.call(this, t, e)).type = 'rexSlider', i.eventEmitter = Ba(e, 'eventEmitter', _(i)); const n = Ba(e, 'background', void 0); const s = Ba(e, 'track', void 0); const r = Ba(e, 'indicator', void 0); const o = Ba(e, 'thumb', void 0); n && i.addBackground(n), s && i.add(s, 1, 'center', 0, !0), r && i.pin(r), o && i.pin(o); let a = Ba(e, 'input', 0); switch (typeof a === 'string' && (a = Ra[a]), a) { case 0: o && (o.setInteractive(), i.scene.input.setDraggable(o), o.on('drag', va, _(i))); break; case 1: i.setInteractive().on('pointerdown', pa, _(i)).on('pointermove', pa, _(i)); }i.addChildrenMap('background', n), i.addChildrenMap('track', s), i.addChildrenMap('indicator', r), i.addChildrenMap('thumb', o); const h = Ba(e, 'valuechangeCallback', null); if (h !== null) { const l = Ba(e, 'valuechangeCallbackScope', void 0); i.eventEmitter.on('valuechange', h, l); } return i.setEnable(Ba(e, 'enable', void 0)), i.setGap(Ba(e, 'gap', void 0)), i.setValue(Ba(e, 'value', 0)), i; } return w(c, [{ key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'setGap', value(t) { return this.gap = t, this; } }, { key: 'setValue', value(t, e, i) { return t == null || (void 0 !== e && (t = Da(t, e, i)), this.value = t), this; } }, { key: 'addValue', value(t, e, i) { return void 0 !== e && (t = Da(t, e, i)), this.value += t, this; } }, { key: 'getValue', value(t, e) { let i = this.value; return void 0 !== t && (i = ja(t, e, i)), i; } }, { key: '_layout', value(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; const n = this.getElement('track'); return this.orientation === 1 ? ks(n, void 0, 0) : ks(n, 0, void 0), g(p(c.prototype), '_layout', this).call(this, t, e, i), this.updateThumb(), this.updateIndicator(), this; } }, { key: 'value', get() { return this._value; }, set(t) { void 0 !== this.gap && (t = Ia(t, this.gap)); const e = this._value; this._value = _a(t, 0, 1), e !== this._value && (this.updateThumb(this._value), this.updateIndicator(this._value), this.eventEmitter.emit('valuechange', this._value, e, this.eventEmitter)); } }]), c; }()); var Ra = { drag: 0, click: 1, none: -1 }; const La = {
    getStartPoint(t) { if (void 0 === t && (t = wa), this.childrenMap.thumb) { const e = this.orientation === 0 ? ka : Ca; ga.call(this, e, t); } else this.orientation === 0 ? (t.x = this.left + 1, t.y = this.centerY) : (t.x = this.centerX, t.y = this.top + 1); return t; }, getEndPoint(t) { if (void 0 === t && (t = Ta), this.childrenMap.thumb) { const e = this.orientation === 0 ? Sa : Oa; ga.call(this, e, t); } else this.orientation === 0 ? (t.x = this.right - 1, t.y = this.centerY) : (t.x = this.centerX, t.y = this.bottom - 1); return t; }, updateThumb(t) { let e; let i; let n; let s; const r = this.childrenMap.thumb; return void 0 === r || (void 0 === t && (t = this.value), e = t, i = this.getStartPoint(), n = this.getEndPoint(), void 0 === (s = r) && (s = Ma), s.x = Pa(i.x, n.x, e), s.y = Pa(i.y, n.y, e), this.resetChildPositionState(r)), this; }, updateIndicator(t) { let e; let i; const n = this.childrenMap.indicator; if (void 0 === n) return this; void 0 === t && (t = this.value); const s = this.childrenMap.thumb; if (s) if (this.orientation === 0) { const r = kn(s); e = s.x - r * s.originX + r - this.left; } else { const o = Cn(s); i = s.y - o * s.originY + o - this.top; } else this.orientation === 0 ? e = this.width * t : i = this.height * t; ks(n, e, i); const a = this.orientation === 0 ? Ea : za; Vn(n, this, a), this.resetChildPositionState(n); },
  }; Object.assign(Ya.prototype, La), c.register('slider', function (t) { const e = new Ya(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Slider', Ya); function Fa(t) { let e = Xa(t, 'scrollMode', 0); return typeof e === 'string' && (e = Aa[e]), e; } var Aa = {
    v: 0, vertical: 0, h: 1, horizontal: 1,
  }; var Xa = Phaser.Utils.Objects.GetValue; const Ha = function (t, e, i) { if (t && typeof t !== 'number') { if (t.hasOwnProperty(e)) return t[e]; if (e.indexOf('.') === -1) return i; for (var n = e.split('.'), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break; }r = s[n[o]], s = s[n[o]]; } return r; } return i; }; const Ua = (function () {
    function o(t) { B(this, o); const e = Ha(t, 'states', void 0); e && this.addStates(e); const i = Ha(t, 'extend', void 0); if (i) for (const n in i) this.hasOwnProperty(n) && void 0 !== this[n] || (this[n] = i[n]); const s = Ha(t, 'eventEmitter', void 0); const r = Ha(t, 'EventEmitterClass', void 0); this.setEventEmitter(s, r), this._stateLock = !1, this.resetFromJSON(t); } return w(o, [{ key: 'shutdown', value() { this.destroyEventEmitter(); } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'resetFromJSON', value(t) { this.setEnable(Ha(t, 'enable', !0)), this.start(Ha(t, 'start', void 0)); const e = Ha(t, 'init', void 0); return e && e.call(this), this; } }, {
      key: 'toJSON',
      value() {
        return {
          curState: this.state, prevState: this.prevState, enable: this.enable, start: this._start,
        };
      },
    }, { key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'start', value(t) { return this._start = t, this._prevState = void 0, this._state = t, this; } }, { key: 'goto', value(t) { return t != null && (this.state = t), this; } }, { key: 'next', value() { let t; const e = this[`next_${this.state}`]; return e && (t = typeof e === 'string' ? e : e.call(this)), this.goto(t), this; } }, { key: 'addState', value(t, e) { const i = Ha(e, 'next', void 0); i && (this[`next_${t}`] = i); const n = Ha(e, 'exit', void 0); n && (this[`exit_${t}`] = n); const s = Ha(e, 'enter', void 0); return s && (this[`enter_${t}`] = s), this; } }, { key: 'addStates', value(t) { for (const e in t) this.addState(e, t[e]); return this; } }, { key: 'update', value(t, e, i) { void 0 === i && (i = 'update'); const n = this[`${i}_${this.state}`]; n && n.call(this, t, e); } }, { key: 'preupdate', value(t, e) { this.update(t, e, 'preupdate'); } }, { key: 'postupdate', value(t, e) { this.update(t, e, 'postupdate'); } }, { key: 'state', set(t) { if (this.enable && !this._stateLock && this._state !== t) { if (this._prevState = this._state, this._state = t, this._stateLock = !0, this.emit('statechange', this), this._prevState != null) { const e = `exit_${this._prevState}`; const i = this[e]; i && i.call(this), this.emit(e, this); } if (this._stateLock = !1, this._state != null) { const n = `enter_${this._state}`; const s = this[n]; s && s.call(this), this.emit(n, this); } } }, get() { return this._state; } }, { key: 'prevState', get() { return this._prevState; } }]), o;
  }()); Object.assign(Ua.prototype, ls); const Va = (function () { i(s, Ua); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, e)).parent = t, i.init(), i; } return w(s, [{ key: 'init', value() { this.start('IDLE'); } }, { key: 'next_IDLE', value() { let t; const e = this.parent; return e.dragState.isDown && (t = e.dragThreshold === 0 ? 'DRAG' : 'DRAGBEGIN'), t; } }, { key: 'update_IDLE', value() { this.next(); } }, { key: 'next_DRAGBEGIN', value() { const t = this.parent; const e = t.dragState; return e.isDown ? e.pointer.getDistance() >= t.dragThreshold ? 'DRAG' : 'DRAGBEGIN' : 'IDLE'; } }, { key: 'update_DRAGBEGIN', value() { this.next(); } }, { key: 'next_DRAG', value() { let t; const e = this.parent; return e.dragState.isUp && (t = e.outOfBounds ? 'BACK' : e.slidingEnable ? 'SLIDE' : 'IDLE'), t; } }, { key: 'update_DRAG', value() { const t = this.parent; t.dragState.justMoved && t.dragging(), this.next(); } }, { key: 'next_SLIDE', value() { let t; const e = this.parent; return e.dragState.isDown ? t = 'DRAG' : e.isSliding || (t = 'IDLE'), t; } }, { key: 'enter_SLIDE', value() { this.parent.onSliding(); } }, { key: 'exit_SLIDE', value() { this.parent.stop(); } }, { key: 'update_SLIDE', value(t, e) { this.parent.sliding(t, e), this.next(); } }, { key: 'next_BACK', value() { let t; const e = this.parent; return e.dragState.isDown ? t = 'DRAG' : e.isPullBack || (t = 'IDLE'), t; } }, { key: 'enter_BACK', value() { this.parent.onPullBack(); } }, { key: 'exit_BACK', value() { this.parent.stop(); } }, { key: 'update_BACK', value(t, e) { this.parent.pullBack(t, e), this.next(); } }]), s; }()); const Wa = Phaser.Utils.Objects.GetValue; const Ga = Phaser.Math.Distance.Between; const Na = (function () { function i(t, e) { B(this, i), this.gameObject = t, this.scene = Zn(t), this.setEventEmitter(Wa(e, 'eventEmitter', void 0)), this._enable = void 0, t.setInteractive(Wa(e, 'inputConfig', void 0)), this.resetFromJSON(e), this.boot(); } return w(i, [{ key: 'resetFromJSON', value(t) { return this.pointer = void 0, this.isInTouched = !1, this.holdStartTime = void 0, this.x = void 0, this.y = void 0, this.preX = void 0, this.preY = void 0, this.localX = void 0, this.localY = void 0, this.justMoved = !1, this.setEnable(Wa(t, 'enable', !0)), this.holdThreshold = Wa(t, 'holdThreshold', 50), this; } }, { key: 'boot', value() { this.gameObject.on('pointerdown', this.onPointIn, this), this.gameObject.on('pointerup', this.onPointOut, this), this.gameObject.on('pointerout', this.onPointOut, this), this.gameObject.on('pointermove', this.onPointerMove, this), this.gameObject.on('destroy', this.destroy, this), this.scene.events.on('preupdate', this.preupdate, this); } }, { key: 'shutdown', value() { this.scene && this.scene.events.off('preupdate', this.preupdate, this), this.pointer = void 0, this.gameObject = void 0, this.scene = void 0, this.destroyEventEmitter(); } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'toggleEnable', value() { return this.setEnable(!this.enable), this; } }, { key: 'onPointIn', value(t, e, i) { this.enable && t.isDown && void 0 === this.pointer && (this.pointer = t, this.localX = e, this.localY = i); } }, { key: 'onPointOut', value(t) { this.enable && this.pointer === t && (this.pointer = void 0); } }, { key: 'onPointerMove', value(t, e, i) { this.enable && t.isDown && this.pointer === t && (this.localX = e, this.localY = i); } }, { key: 'preupdate', value(t) { if (this.enable) { const e = this.pointer; this.justMoved = !1, e && !this.isInTouched ? (this.x = e.x, this.y = e.y, this.preX = e.x, this.preY = e.y, this.isInTouched = !0, this.holdStartTime = void 0, this.emit('touchstart', e, this.localX, this.localY)) : e && this.isInTouched ? this.x === e.x && this.y === e.y ? void 0 === this.holdStartTime ? this.holdStartTime = t : t - this.holdStartTime > this.holdThreshold && (this.preX = this.x, this.preY = this.y) : (this.preX = this.x, this.preY = this.y, this.x = e.x, this.y = e.y, this.holdStartTime = void 0, this.justMoved = !0, this.emit('touchmove', e, this.localX, this.localY)) : !e && this.isInTouched && (this.isInTouched = !1, this.holdStartTime = void 0, this.emit('touchend', e)); } } }, { key: 'enable', get() { return this._enable; }, set(t) { this._enable !== t && (t || (this.isInTouched = !1, this.pointer = void 0), this._enable = t); } }, { key: 'isDown', get() { return this.pointer && this.pointer.isDown; } }, { key: 'isUp', get() { return !this.isDown; } }, { key: 'dx', get() { return this.x - this.preX; } }, { key: 'dy', get() { return this.y - this.preY; } }, { key: 'dt', get() { return this.scene.sys.game.loop.delta; } }, { key: 'speed', get() { return this.x === this.preX && this.y === this.preY ? 0 : Ga(this.preX, this.preY, this.x, this.y) / (0.001 * this.dt); } }, { key: 'speedX', get() { return this.dx / (0.001 * this.dt); } }, { key: 'speedY', get() { return this.dy / (0.001 * this.dt); } }]), i; }()); Object.assign(Na.prototype, ls); const Ja = Phaser.Utils.Objects.GetValue; const Ka = (function () { function e(t) { B(this, e), this.resetFromJSON(t); } return w(e, [{ key: 'resetFromJSON', value(t) { return this.setValue(Ja(t, 'value', 0)), this.setSpeed(Ja(t, 'speed', 0)), this.setAcceleration(Ja(t, 'acceleration', 0)), this; } }, { key: 'reset', value() { this.setValue(0), this.setSpeed(0), this.setAcceleration(0); } }, { key: 'setValue', value(t) { return this.value = t, this; } }, { key: 'setSpeed', value(t) { return this.speed = t, this; } }, { key: 'setAcceleration', value(t) { return this.acceleration = t, this; } }, { key: 'updateSpeed', value(t) { return this.acceleration !== 0 && (this.speed += this.acceleration * t, this.speed < 0 && (this.speed = 0)), this; } }, { key: 'getDeltaValue', value(t) { return this.updateSpeed(t), this.speed <= 0 ? 0 : this.speed * t; } }, { key: 'update', value(t) { return this.updateSpeed(t), this.speed > 0 && (this.value += this.getDeltaValue(t)), this; } }, { key: 'isMoving', get() { return this.speed > 0; } }]), e; }()); const Za = (function () { function t() { B(this, t), this.value, this.dir, this.movement = new Ka(); } return w(t, [{ key: 'init', value(t, e, i, n, s) { return this.value = t, this.end = s, this.dir = void 0 !== s ? t < s : e, this.movement.setSpeed(i).setAcceleration(-n), this; } }, { key: 'stop', value() { this.movement.reset(); } }, { key: 'update', value(t) { let e = this.movement.getDeltaValue(t); return this.dir || (e = -e), void 0 === this.end ? this.value += e : e === 0 ? this.value = this.end : (this.value += e, this.dir ? this.value > this.end && (this.value = this.end) : this.value < this.end && (this.value = this.end)), this; } }, { key: 'isMoving', get() { return this.movement.isMoving; } }]), t; }()); const qa = Phaser.Utils.Objects.GetValue; const $a = (function () { function a(t, e) { B(this, a), this.gameObject = t, this.scene = Zn(t), this.setEventEmitter(qa(e, 'eventEmitter', void 0)); const i = qa(e, 'enable', !0); const n = { enable: i, eventEmitter: !1 }; this._state = new Va(this, n); const s = { inputConfig: qa(e, 'inputConfig', void 0), enable: i, eventEmitter: !1 }; this.dragState = new Na(t, s), this._enable = void 0, this._value = void 0, this._slowDown = new Za(); let r = qa(e, 'valuechangeCallback', null); if (r !== null) { var o = qa(e, 'valuechangeCallbackScope', void 0); this.on('valuechange', r, o); } if ((r = qa(e, 'overmaxCallback', null)) !== null) { o = qa(e, 'overmaxCallbackScope', void 0); this.on('overmax', r, o); } if ((r = qa(e, 'overminCallback', null)) !== null) { o = qa(e, 'overminCallbackScope', void 0); this.on('overmin', r, o); } this.resetFromJSON(e), this.boot(); } return w(a, [{ key: 'resetFromJSON', value(t) { this.setOrientationMode(qa(t, 'orientation', 0)), this.setDragThreshold(qa(t, 'threshold', 10)), this.setSlidingDeceleration(qa(t, 'slidingDeceleration', 5e3)), this.setBackDeceleration(qa(t, 'backDeceleration', 2e3)); const e = qa(t, 'bounds', void 0); return e ? this.setBounds(e) : this.setBounds(qa(t, 'max', 0), qa(t, 'min', 0)), this.setValue(qa(t, 'value', this.maxValue || 0)), this.setEnable(qa(t, 'enable', !0)), this; } }, { key: 'boot', value() { this.scene.events.on('update', this._state.update, this._state), this.gameObject.on('destroy', this.destroy, this); } }, { key: 'shutdown', value() { this.destroyEventEmitter(), this.scene && this.scene.events.off('update', this._state.update, this._state), this.gameObject = void 0, this.scene = void 0, this._state.destroy(), this.dragState.destroy(); } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'toggleEnable', value() { return this.setEnable(!this.enable), this; } }, { key: 'setOrientationMode', value(t) { return typeof t === 'string' && (t = Qa[t]), this.orientationMode = t, this; } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'setSlidingDeceleration', value(t) { return this.slidingDeceleration = t, this; } }, { key: 'setBackDeceleration', value(t) { return this.backDeceleration = t, this; } }, { key: 'setBounds', value(t, e) { if (Array.isArray(t)) { const i = t; t = i[0], e = i[1]; } return t < e ? (this.minValue = t, this.maxValue = e) : (this.minValue = e, this.maxValue = t), this; } }, { key: 'setValue', value(t) { this.value = t; } }, { key: 'overMax', value(t) { return this.maxValue != null && t > this.maxValue; } }, { key: 'overMin', value(t) { return this.minValue != null && t < this.minValue; } }, { key: 'dragging', value() { this.value += this.dragDelta; } }, { key: 'onSliding', value() { const t = this.value; const e = this.dragSpeed; if (e === 0) return this._slowDown.stop(), void this._state.next(); const i = this.slidingDeceleration; this._slowDown.init(t, e > 0, Math.abs(e), i); } }, { key: 'sliding', value(t, e) { e *= 0.001; const i = this._slowDown.update(e).value; this.overMax(i) ? (this.value = this.maxValue, this._slowDown.stop()) : this.overMin(i) ? (this.value = this.minValue, this._slowDown.stop()) : this.value = i; } }, { key: 'onPullBack', value() { const t = this.value; const e = this.outOfMinBound ? this.minValue : this.maxValue; const i = Math.abs(e - t); const n = this.backDeceleration; const s = Math.sqrt(2 * n * i); this._slowDown.init(t, void 0, s, n, e); } }, { key: 'pullBack', value(t, e) { e *= 0.001, this.value = this._slowDown.update(e).value, this._slowDown.isMoving || this._state.next(); } }, { key: 'stop', value() { this._slowDown.stop(); } }, { key: 'enable', get() { return this._enable; }, set(t) { if (this._enable !== t) return this._enable = t, this._state.setEnable(t), this.dragState.setEnable(t), this; } }, { key: 'value', get() { return this._value; }, set(t) { if (t !== this._value) { const e = this._value; const i = this.overMax(t); const n = this.overMin(t); i && this.emit('overmax', t, e), n && this.emit('overmin', t, e), this.backEnable || (i && (t = this.maxValue), n && (t = this.minValue)), this._value = t, this.emit('valuechange', t, e); } } }, { key: 'state', get() { return this._state.state; } }, { key: 'isDragging', get() { return this.dragState.isInTouched; } }, { key: 'outOfMaxBound', get() { return this.overMax(this.value); } }, { key: 'outOfMinBound', get() { return this.overMin(this.value); } }, { key: 'outOfBounds', get() { return this.outOfMinBound || this.outOfMaxBound; } }, { key: 'backEnable', get() { return typeof this.backDeceleration === 'number'; } }, { key: 'isPullBack', get() { return this._slowDown.isMoving; } }, { key: 'slidingEnable', get() { return typeof this.slidingDeceleration === 'number'; } }, { key: 'isSliding', get() { return this._slowDown.isMoving; } }, { key: 'dragDelta', get() { return this.orientationMode === 0 ? this.dragState.dy : this.orientationMode === 1 ? this.dragState.dx : 0; } }, { key: 'dragSpeed', get() { return this.orientationMode === 0 ? this.dragState.speedY : this.orientationMode === 1 ? this.dragState.speedX : 0; } }]), a; }()); Object.assign($a.prototype, ls); var Qa = {
    y: 0, v: 0, vertical: 0, x: 1, h: 1, horizontal: 1,
  }; const th = Phaser.Utils.Objects.GetValue; const eh = {
    right: 0, left: 1, bottom: 0, top: 1,
  }; const ih = Phaser.Utils.Objects.GetValue; const nh = (function () {
    i(v, fr); const f = S(v); function v(t, e) { let i; B(this, v), void 0 === e && (e = {}); const n = Fa(e); e.orientation = n === 0 ? 1 : 0, (i = f.call(this, t, e)).type = ih(e, 'type', 'rexScrollable'); const s = ih(e, 'background', void 0); const r = function (t) { let e; let i; let n; const s = this.scene; const r = Fa(t); const o = new fr(s, { orientation: r }); const a = th(t, 'child.gameObject', void 0); let h = th(t, 'slider', void 0); let l = th(t, 'scroller', !0); if (a) { let u; let c = th(t, 'space.child', 0); if (this.childPadding = {}, typeof c !== 'number') { const d = c; r === 0 ? (c = th(d, 'right', 0), this.childPadding.top = th(d, 'top', 0), this.childPadding.bottom = th(d, 'bottom', 0)) : (c = th(d, 'bottom', 0), this.childPadding.top = th(d, 'left', 0), this.childPadding.bottom = th(d, 'right', 0)); } else this.childPadding.top = 0, this.childPadding.bottom = 0; if (h)!0 === h && (h = {}), typeof (i = th(h, 'position', 0)) === 'string' && (i = eh[i]), u = r === 0 ? i === 0 ? { left: c } : { right: c } : i === 0 ? { top: c } : { bottom: c }, h.orientation = o.orientation === 0 ? 1 : 0, e = new Ya(s, h); l && (!0 === l && (l = {}), l.orientation = r, n = new $a(a, l)), e && i === 1 && o.add(e, 0, 'center', u, !0); const f = th(t, 'child.proportion', 1); const v = th(t, 'child.expand', !0); o.add(a, f, 'center', 0, v), e && i === 0 && o.add(e, 0, 'center', u, !0); } return e && e.on('valuechange', function (t) { this.t = t, this.emit('scroll', this); }, this), n && n.on('valuechange', function (t) { this.childOY = t, this.emit('scroll', this); }, this), this.addChildrenMap('child', a), this.addChildrenMap('slider', e), this.addChildrenMap('scroller', n), o; }.call(_(i), e); const o = ih(e, 'header', void 0); const a = ih(e, 'footer', void 0); if (s && i.addBackground(s), o) { var h = ih(e, 'align.header', 'center'); const l = ih(e, 'space.header', 0); c = n === 0 ? { bottom: l } : { right: l }; var u = ih(e, 'expand.header', !0); i.add(o, 0, h, c, u); } if (r && i.add(r, 1, 'center', 0, !0), a) { h = ih(e, 'align.footer', 'center'); var c; const d = ih(e, 'space.footer', 0); c = n === 0 ? { top: d } : { left: d }; u = ih(e, 'expand.footer', !0); i.add(a, 0, h, c, u); } return i.addChildrenMap('background', s), i.addChildrenMap('header', o), i.addChildrenMap('footer', a), i; } return w(v, [{ key: '_layout', value(t, e, i) { return this.rexSizer.hidden || !this.dirty || (g(p(v.prototype), '_layout', this).call(this, t, e, i), this.resizeController()), this; } }, { key: 'setChildOY', value(t) { return this.childOY = t, this; } }, { key: 'setT', value(t) { return this.t = t, this; } }, { key: 'scrollToTop', value() { return this.t = 0, this; } }, { key: 'scrollToBottom', value() { return this.t = 1, this; } }, { key: 'setSliderEnable', value(t) { return void 0 === t && (t = !0), this.sliderEnable = t, this; } }, { key: 'setScrollerEnable', value(t) { return void 0 === t && (t = !0), this.scrollerEnable = t, this; } }, {
      key: 't',
      set(t) { const e = this.childPadding; if (e.top !== 0 || e.bottom !== 0) { const i = this.childrenMap.child; const n = i.topChildOY - i.bottomChildOY; t = ((n + e.top + e.bottom) * t - e.top) / n; } this.childrenMap.child.t = t, this.updateController(); },
      get() {
        let { t } = this.childrenMap.child; const
          e = this.childPadding; if (e.top !== 0 || e.bottom !== 0) { const i = this.childrenMap.child; const n = i.topChildOY - i.bottomChildOY; const s = n + e.top + e.bottom; t = (n * t + e.top) / s; } return t;
      },
    }, { key: 'childOY', set(t) { this.childrenMap.child.childOY = t, this.updateController(); }, get() { return this.childrenMap.child.childOY; } }, { key: 'topChildOY', get() { return this.childrenMap.child.topChildOY + this.childPadding.top; } }, { key: 'bottomChildOY', get() { return this.childrenMap.child.bottomChildOY - this.childPadding.bottom; } }, { key: 'sliderEnable', get() { const t = this.childrenMap.slider; if (t) return t.enable; }, set(t) { const e = this.childrenMap.slider; e && e.setEnable(t); } }, { key: 'scrollerEnable', get() { const t = this.childrenMap.scroller; if (t) return t.enable; }, set(t) { const e = this.childrenMap.scroller; e && e.setEnable(t); } }]), v;
  }()); const sh = { resizeController() { const t = this.topChildOY; const e = this.bottomChildOY; const i = this.childrenMap.scroller; const n = this.childrenMap.slider; return i && i.setBounds(e, t), n && n.setEnable(e !== t), this.updateController(), this; }, updateController() { const t = this.childrenMap.scroller; const e = this.childrenMap.slider; t && t.setValue(this.childOY), e && e.setValue(this.t); } }; Object.assign(nh.prototype, sh); const rh = {
    enableData() { return void 0 === this.data && (this.data = {}), this; }, getData(t, e) { return this.enableData(), void 0 === t ? this.data : Ha(this.data, t, e); }, setData(t, e) { return this.enableData(), this.data[t] = e, this; }, incData(t, e, i) { return void 0 === i && (i = 0), this.enableData(), this.setData(t, this.getData(t, i) + e), this; }, mulData(t, e, i) { return void 0 === i && (i = 0), this.enableData(), this.setData(t, this.getData(t, i) * e), this; }, clearData() { return this.data && dt(this.data), this; }, resetData(t) { if (this.clearData(), t) for (const e in this.enableData(), t) this.data[e] = t[e]; return this; }, cloneData() { return this.data ? ft(this.data) : {}; },
  }; const oh = (function () { function i(t, e) { B(this, i), this.container = null, this._deltaHeight = 0, this.setParent(t); } return w(i, [{ key: 'setParent', value(t) { this.parent = t, this.parentContainer = t.getParentContainer(); } }, { key: 'destroy', value(t) { void 0 === t && (t = !1), t || this.destroyContainer(), this.deltaHeight = 0, this.data = void 0, this.container = null, this.parent = void 0, this.parentContainer = void 0; } }, { key: 'getContainer', value() { return this.container; } }, { key: 'setContainer', value(t) { return t ? (this.container && this.container.destroy(), this.container = t, this.parentContainer.add(t)) : this.destroyContainer(), this; } }, { key: 'destroyContainer', value() { return this.container && (this.container.destroy(), this.container = null), this; } }, { key: 'popContainer', value() { if (this.container) { const t = this.container; return this.container = null, this.parentContainer.remove(t), t; } return null; } }, { key: 'setXY', value(t, e) { return this.container && this.parentContainer.setChildLocalPosition(this.container, t, e), this; } }, { key: 'setDeltaHeight', value(t) { return this.deltaHeight = t, this; } }, { key: 'setDeltaWidth', value(t) { return this.deltaHeight = t, this; } }, { key: 'setHeight', value(t) { return this.height = t, this; } }, { key: 'setWidth', value(t) { return this.width = t, this; } }, { key: 'table', get() { return this.parent; } }, { key: 'scrollMode', get() { return this.parentContainer.scrollMode; } }, { key: 'colIndx', get() { return this.parent.cellIndxeToColIndex(this.index); } }, { key: 'rowIndx', get() { return this.parent.cellIndxeToRowIndex(this.index); } }, { key: 'deltaHeight', get() { return this._deltaHeight; }, set(t) { t == null && (t = 0); const e = this.parent; this._deltaHeight === 0 && t !== 0 ? e.nonZeroDeltaHeightCount++ : this._deltaHeight !== 0 && t === 0 && e.nonZeroDeltaHeightCount--, this._deltaHeight = t; } }, { key: 'deltaWidth', get() { return this.deltaHeight; }, set(t) { this.deltaHeight = t; } }, { key: 'height', get() { return this.scrollMode === 0 ? this.deltaHeight + this.parent.defaultCellHeight : this.parent.defaultCellWidth; }, set(t) { this.scrollMode !== 1 && this.setDeltaHeight(t - this.parent.defaultCellHeight); } }, { key: 'width', get() { return this.scrollMode === 0 ? this.parent.defaultCellWidth : this.deltaHeight + this.parent.defaultCellHeight; }, set(t) { this.scrollMode !== 0 && this.setDeltaHeight(t - this.parent.defaultCellHeight); } }, { key: 'scene', get() { return this.parentContainer.scene; } }]), i; }()); Object.assign(oh.prototype, rh); function ah(t) { return t.hasOwnProperty('geometryMask') ? t.geometryMask : t.bitmapMask; } function hh(t, e, i) { if (e) { void 0 === i && (i = t.getAllChildren()); for (var n, s, r = t.getBounds(), o = ah(e), a = 0, h = i.length; a < h; a++) if (!(n = i[a]).hasOwnProperty('isRexContainerLite') && n !== o && t.getLocalState(n).visible) if (n.getBounds) switch (s = n.getBounds(s), mh(r, s)) { case 4: bh(t, n); break; case 0: gh(r, s) || yh(r, s) ? xh(t, n, e) : kh(t, n); break; default: xh(t, n, e); } else xh(t, n, e); } } function lh(t) { if (this.emit('cellinvisible', t), this.cellContainersPool) { const e = t.popContainer(); e && this.cellContainersPool.killAndHide(e); }t.destroyContainer(); } function uh() { const t = this.preVisibleCells; const e = this.visibleCells; t.iterate(function (t) { e.contains(t) || lh.call(this, t); }, this); } function ch(t) { let e; let i = null; (e = t.getContainer()) ? (i = e, t.popContainer()) : this.cellContainersPool && (i = this.cellContainersPool.getFirstDead()) !== null && i.setActive(!0).setVisible(!0), this.emit('cellvisible', t, i, this), this.cellContainersPool && ((e = t.getContainer()) ? i === null ? this.cellContainersPool.add(e) : i !== e && (this.cellContainersPool.add(e), this.cellContainersPool.killAndHide(i)) : i !== null && this.cellContainersPool.killAndHide(i)); } function dh(t, e) { e -= this.y + this.topLeftY, t -= this.x + this.topLeftX; const i = this.tableOY - (this.scrollMode === 0 ? e : t); const n = this.tableOX - (this.scrollMode === 0 ? t : e); const s = this.table; const r = s.heightToRowIndex(-i); const o = s.widthToColIndex(-n); const a = s.colRowToCellIndex(o, r); return a !== null && this.isCellVisible(a) ? a : null; } const fh = Phaser.Utils.Objects.GetValue; const vh = Phaser.Utils.Array.SpliceOne; const ph = (function () { function i(t, e) { B(this, i), this.parent = t, this.cells = [], this.cellPool = new _t(), this.resetFromJSON(e); } return w(i, [{ key: 'resetFromJSON', value(t) { return this.colCount = void 0, this._nonZeroDeltaHeightCount = 0, this.resetTotalRowsHeight(), this.setDefaultCellHeight(fh(t, 'cellHeight', 30)), this.setDefaultCellWidth(fh(t, 'cellWidth', 30)), this.initCells(fh(t, 'cellsCount', 0)), this.setColumnCount(fh(t, 'columns', 1)), this; } }, { key: 'destroy', value(t) { for (let e = 0, i = this.cells.length; e < i; e++) this.freeCell(this.cells[e], t); this.cellPool.destroy(), this.cells = void 0, this.parent = void 0; } }, { key: 'setDefaultCellHeight', value(t) { return this.defaultCellHeight = t, this; } }, { key: 'setDefaultCellWidth', value(t) { return this.defaultCellWidth = t, this; } }, { key: 'initCells', value(t) { const e = this.cells; e.length = t; for (let i = 0; i < t; i++)e[i] = null; return this; } }, { key: 'insertNewCells', value(t, e) { const i = this.cells; if (t === i.length) { const n = t + e; i.legth = n; for (var s = t; s < n; s++)i[s] = null; } else { let r; const o = []; o.length = e; for (s = 0; s < e; s++)o[s] = null; (r = this.cells).splice.apply(r, [t, 0].concat(o)); } return this.resetTotalRowsHeight(), this; } }, { key: 'removeCells', value(t, e) { for (var i = t + e, n = t; n < i; n++) this.freeCell(n); return i === this.cells.length ? this.cells.length = t : (e === 1 ? vh(this.cells, t) : this.cells.splice(t, e), this.buildCellIndex(t)), this.resetTotalRowsHeight(), this; } }, { key: 'setColumnCount', value(t) { return this.colCount = t, this.resetTotalRowsHeight(), this; } }, { key: 'isValidCellIdx', value(t) { return t >= 0 && t < this.cells.length; } }, { key: 'heightToRowIndex', value(t, e) { if (this.defaultCellHeightMode) { var i = t / this.defaultCellHeight; return i = e ? Math.ceil(i) : Math.floor(i); } let n; const s = this.rowCount; let r = t; for (i = 0; ;) { if (n = i >= 0 && i < s, !((r -= this.getRowHeight(i)) > 0 && n)) { if (r === 0) return i; if (e) { const o = i; (n = (i += 1) >= 0 && i < s) || (i = o); } return i; }i += 1; } } }, { key: 'widthToColIndex', value(t, e) { let i = t / this.defaultCellWidth; return i = e ? Math.ceil(i) : Math.floor(i); } }, { key: 'colRowToCellIndex', value(t, e) { return t >= this.colCount ? null : e * this.colCount + t; } }, { key: 'rowIndexToHeight', value(t, e) { if (this.defaultCellHeightMode) return (e - t + 1) * this.defaultCellHeight; for (var i = 0, n = t; n <= e; n++)i += this.getRowHeight(n); return i; } }, { key: 'colIndexToWidth', value(t, e) { return (e - t + 1) * this.defaultCellWidth; } }, { key: 'getRowHeight', value(t) { const e = this.colCount; if (e <= 1) return this.getCellHeight(this.colRowToCellIndex(0, t)); for (var i, n = 0, s = 0; s < e; s++)n < (i = this.getCellHeight(this.colRowToCellIndex(s, t))) && (n = i); return n; } }, { key: 'getColWidth', value() { return this.defaultCellWidth; } }, { key: 'getCellHeight', value(t) { if (!this.isValidCellIdx(t)) return 0; let e; if (this.defaultCellHeightMode)e = this.defaultCellHeight; else { const i = this.getCell(t, !1); const n = i ? i.deltaHeight : 0; e = this.defaultCellHeight + n; } return e; } }, { key: 'resetTotalRowsHeight', value() { this._totalRowsHeight = null; } }, { key: 'cellIndxeToColIndex', value(t) { return t % this.colCount; } }, { key: 'cellIndxeToRowIndex', value(t) { return Math.floor(t / this.colCount); } }, { key: 'getCell', value(t, e) { if (!this.isValidCellIdx(t)) return null; if (void 0 === e && (e = !0), this.cells[t] === null && e) { const i = this.newCell(t); this.cells[t] = i; } return this.cells[t]; } }, { key: 'newCell', value(t) { let e = this.cellPool.pop(); return e === null ? e = new oh(this) : e.setParent(this), e.index = t, e; } }, { key: 'buildCellIndex', value(t) { void 0 === t && (t = 0); for (var e, i = this.cells, n = t, s = i.length; n < s; n++)(e = i[n]) && (e.index = n); return this; } }, { key: 'getParentContainer', value() { return this.parent; } }, { key: 'freeCell', value(t, e) { return typeof t === 'number' && (t = this.cells[t]), t && (t.destroy(e), e || this.cellPool.push(t)), this; } }, { key: 'nonZeroDeltaHeightCount', get() { return this._nonZeroDeltaHeightCount; }, set(t) { this._nonZeroDeltaHeightCount !== t && (this._nonZeroDeltaHeightCount = t, this.resetTotalRowsHeight()); } }, { key: 'defaultCellHeightMode', get() { return this.nonZeroDeltaHeightCount === 0; } }, { key: 'rowCount', get() { return Math.ceil(this.cells.length / this.colCount); } }, { key: 'cellsCount', get() { return this.cells.length; } }, { key: 'totalRowsHeight', get() { return this._totalRowsHeight === null && (this._totalRowsHeight = this.rowIndexToHeight(0, this.rowCount - 1)), this._totalRowsHeight; } }, { key: 'totalColumnWidth', get() { return this.colCount * this.defaultCellWidth; } }]), i; }()); var gh = Phaser.Geom.Intersects.RectangleToRectangle; var yh = Phaser.Geom.Rectangle.Overlaps; var mh = function (t, e) { let i = 0; const n = e.top; const s = e.bottom; const r = e.left; const o = e.right; return i += t.contains(r, n) ? 1 : 0, i += t.contains(r, s) ? 1 : 0, i += t.contains(o, n) ? 1 : 0, i += t.contains(o, s) ? 1 : 0; }; var bh = function (t, e) { t.setChildMaskVisible(e, !0), e.clearMask && e.clearMask(); }; var xh = function (t, e, i) { t.setChildMaskVisible(e, !0), e.setMask && e.setMask(i); }; var kh = function (t, e) { t.setChildMaskVisible(e, !1), e.clearMask && e.clearMask(); }; const Ch = function (t) { const e = this.scrollMode === 0 ? this.topLeftX : this.topLeftY; return this.tableOX + this.table.colIndexToWidth(0, t - 1) + e; }; const wh = function (t) { const e = this.scrollMode === 0 ? this.topLeftY : this.topLeftX; return this.tableOY + this.table.rowIndexToHeight(0, t - 1) + e; }; const Sh = function () { const t = this.preVisibleCells; this.preVisibleCells = this.visibleCells, this.visibleCells = t, this.visibleCells.clear(); }; const Oh = Phaser.Math.Clamp; const Th = {
    setTableOY(t) { const e = this.table; const i = this.topTableOY; const n = this.bottomTableOY; const s = t > this.topTableOY; const r = t < this.bottomTableOY; this.clampTableOXY && (e.rowCount < e.heightToRowIndex(this.instHeight, !0) ? t = 0 : s ? t = i : r && (t = n)); return this._tableOY !== t && (this._tableOY = t), s && (this.execeedTopState || this.emit('execeedtop', this, t, i)), this.execeedTopState = s, r && (this.execeedBottomState || this.emit('execeedbottom', this, t, n)), this.execeedBottomState = r, this; }, setTableOX(t) { const e = this.table; const i = this.leftTableOX; const n = this.rightTableOX; const s = t > this.leftTableOX; const r = t < this.rightTableOX; this.clampTableOXY && (e.colCount < e.widthToColIndex(this.instWidth, !0) ? t = 0 : s ? t = i : r && (t = n)); return this._tableOX !== t && (this._tableOX = t), s && (this.execeedLeftState || this.emit('execeedleft', this, t, i)), this.execeedLeftState = s, r && (this.execeedRightState || this.emit('execeedright', this, t, n)), this.execeedRightState = r, this; }, maskCells() { if (!this.cellsMask) return this; if (this.maskUpdateMode === 1 && (this.alpha === 0 || !this.visible)) return this; for (var t, e = [], i = this.visibleCells.entries, n = 0, s = i.length; n < s; n++)(t = i[n].getContainer()) && (t.hasOwnProperty('isRexContainerLite') ? t.getAllChildren(e) : e.push(t)); return hh(this, this.cellsMask, e), this; }, updateTable(t) { return void 0 === t && (t = !1), t && (Sh.call(this), uh.call(this)), Sh.call(this), function () { if (this.cellsCount !== 0) { const t = this.table; let e = t.heightToRowIndex(-this.tableOY); e < 0 && (e = 0); let i = e; let n = t.widthToColIndex(-this.tableOX); n < 0 && (n = 0); for (let s = n, r = t.colRowToCellIndex(s, i), o = this.bottomBound, a = this.rightBound, h = t.cellsCount - 1, l = t.colCount - 1, u = Ch.call(this, s), c = u, d = wh.call(this, i); d < o && r <= h;) { if (this.table.isValidCellIdx(r)) { const f = t.getCell(r, !0); this.visibleCells.set(f), this.preVisibleCells.contains(f) || ch.call(this, f), this.scrollMode === 0 ? f.setXY(c, d) : f.setXY(d, c); }c < a && s < l ? (c += t.getColWidth(s), s += 1) : (c = u, d += t.getRowHeight(i), s = n, i += 1), r = t.colRowToCellIndex(s, i); } } }.call(this), uh.call(this), this.maskUpdateMode === 0 && this.maskCells(), this; }, isCellVisible(t) { const e = this.table.getCell(t, !1); return e && this.visibleCells.contains(e); }, pointToCellIndex: dh, pointToCellContainer(t, e) { const i = dh.call(this, t, e); if (i !== null) return this.getCellContainer(i); }, eachVisibleCell(t, e) { return this.visibleCells.each(t, e), this; }, iterateVisibleCell(t, e) { return this.visibleCells.iterate(t, e), this; }, eachCell(t, e) { return this.table.cells.slice().forEach(t, e), this; }, iterateCell(t, e) { return this.table.cells.forEach(t, e), this; }, setCellsCount(t) { const e = this.cellsCount; return e === t || (t < e ? this.removeCells(t, e - t) : this.insertNewCells(e, t - e)), this; }, insertNewCells(t, e) { return k(t) === 'object' && (t = t.index), void 0 === e && (e = 1), e <= 0 || (t = Oh(t, 0, this.cellsCount), this.table.insertNewCells(t, e)), this; }, removeCells(t, e) { if (k(t) === 'object' && (t = t.index), void 0 === e && (e = 1), t < 0 && (e += t, t = 0), e <= 0) return this; if (t > this.cellsCount) return this; for (var i, n = t, s = t + e; n < s; n++)(i = this.getCell(n, !1)) && (this.visibleCells.contains(i) && (lh.call(this, i), this.visibleCells.delete(i)), this.preVisibleCells.delete(i)); return this.table.removeCells(t, e), this; }, setColumnCount(t) { return this.table.colCount === t || this.table.setColumnCount(t), this; }, setGridSize(t, e) { return this.setCellsCount(t * e), this.table.setColumnCount(t), this; }, updateVisibleCell(t) { const e = this.table.getCell(t, !1); return e && e.container && ch.call(this, e), this; },
  }; const Ph = Phaser.GameObjects.Group; const Mh = Phaser.GameObjects.Components; const Eh = Phaser.Structs.Set; const zh = Phaser.Utils.Objects.GetValue; const Bh = (function () { i(f, Ii); const d = S(f); function f(t, e, i, n, s, r) { let o; B(this, f), void 0 === r && (r = {}), (o = d.call(this, t, e, i, n, s)).type = 'rexGridTable', o._tableOX = 0, o._tableOY = 0, o.visibleCells = new Eh(), o.preVisibleCells = new Eh(), o.execeedTopState = !1, o.execeedBottomState = !1, o.execeedLeftState = !1, o.execeedRightState = !1, zh(r, 'reuseCellContainer', !1) && (o.cellContainersPool = new Ph(t)); let a = zh(r, 'cellVisibleCallback', null); if (a !== null) { var h = zh(r, 'cellVisibleCallbackScope', void 0); o.on('cellvisible', a, h); } if ((a = zh(r, 'cellInvisibleCallback', null)) !== null) { h = zh(r, 'cellInvisibleCallbackScope', void 0); o.on('cellinvisible', a, h); } if (o.setCellsMask(zh(r, 'mask', !0)), o.setScrollMode(zh(r, 'scrollMode', 0)), o.setClampMode(zh(r, 'clamplTableOXY', !0)), o.scrollMode === 0) { var l = zh(r, 'cellWidth', void 0); if (o.expandCellSize = void 0 === l, void 0 === l) { const u = zh(r, 'columns', 1); r.cellWidth = o.width / u; } } else { l = zh(r, 'cellHeight', void 0); const c = zh(r, 'cellWidth', void 0); o.expandCellSize = void 0 === l, r.cellWidth = l, r.cellHeight = c; } return o.table = new ph(_(o), r), o.updateTable(), o; } return w(f, [{ key: 'destroy', value(t) { this.scene && (this.maskUpdateMode === 1 && this.scene.game.events.off('poststep', this.maskCells, this), this.table.destroy(t), this.table = void 0, this.cellContainersPool && (this.cellContainersPool.destroy(!0), this.cellContainersPool = void 0), g(p(f.prototype), 'destroy', this).call(this, t)); } }, { key: 'setScrollMode', value(t) { return typeof t === 'string' && (t = jh[t.toLowerCase()]), this.scrollMode = t, this; } }, { key: 'setClampMode', value(t) { return void 0 === t && (t = !0), this.clampTableOXY = t, this; } }, { key: 'setTableOXY', value(t, e) { return this.setTableOY(e).setTableOX(t), this; } }, { key: 'addTableOY', value(t) { return this.setTableOY(this.tableOY + t), this; } }, { key: 'addTableOX', value(t) { return this.setTableOX(this.tableOX + t), this; } }, { key: 'addTableOXY', value(t, e) { return this.addTableOY(e).addTableOX(t), this; } }, { key: 'setTableOYByPercentage', value(t) { return this.setTableOY(-this.tableVisibleHeight * t), this; } }, { key: 'getTableOYPercentage', value() { const t = this.tableVisibleHeight; return t === 0 ? 0 : this.tableOY / -t; } }, { key: 'getCell', value(t) { return this.table.getCell(t, !0); } }, { key: 'getCellContainer', value(t) { let e; const i = this.table.getCell(t, !1); return i && (e = i.getContainer()), e; } }, { key: 'setCellHeight', value(t, e) { return (typeof t === 'number' ? this.table.getCell(t, !0) : t).height = e, this; } }, { key: 'setCellWidth', value(t, e) { return (typeof t === 'number' ? this.table.getCell(t, !0) : t).width = e, this; } }, { key: 'setCellsMask', value(t) { let e; let i; let n; if (!0 === t ? (e = !0, n = i = 0) : !1 === t ? e = !1 : (e = zh(t, 'mask', !0), i = zh(t, 'padding', 0), n = zh(t, 'updateMode', 0)), this.maskUpdateMode = n, e) { const s = new lo(this, 0, i); this.cellsMask = s.createGeometryMask(), this.add(s), typeof n === 'string' && (n = Dh[n]), n === 1 && this.scene.game.events.on('poststep', this.maskCells, this); } return this; } }, { key: 'resize', value(t, e) { return this.width === t && this.height === e || (g(p(f.prototype), 'resize', this).call(this, t, e), this.cellsMask && ks(ah(this.cellsMask), t, e), this.expandCellSize && this.table.setDefaultCellWidth(this.instWidth / this.table.colCount), this.updateTable(!0)), this; } }, { key: 'tableOY', get() { return this._tableOY; }, set(t) { this.setTableOY(t).updateTable(); } }, { key: 'tableOX', get() { return this._tableOX; }, set(t) { this.setTableOX(t).updateTable(); } }, { key: 't', set(t) { this.setTableOYByPercentage(t).updateTable(); }, get() { return this.getTableOYPercentage(); } }, { key: 'cellsCount', get() { return this.table.cellsCount; } }, { key: 'columnCount', get() { return this.table.colCount; } }, { key: 'instHeight', get() { return this.scrollMode === 0 ? this.height : this.width; } }, { key: 'instWidth', get() { return this.scrollMode === 0 ? this.width : this.height; } }, { key: 'tableHeight', get() { return this.table.totalRowsHeight; } }, { key: 'tableWidth', get() { return this.table.totalColumnWidth; } }, { key: 'topTableOY', get() { return 0; } }, { key: 'bottomTableOY', get() { return -this.tableVisibleHeight; } }, { key: 'leftTableOX', get() { return 0; } }, { key: 'rightTableOX', get() { return -this.tableVisibleWidth; } }, { key: 'tableVisibleHeight', get() { const t = this.tableHeight; const e = this.instHeight; return e < t ? t - e : 0; } }, { key: 'tableVisibleWidth', get() { const t = this.tableWidth; const e = this.instWidth; return e < t ? t - e : 0; } }, { key: 'bottomLeftY', get() { return -(this.displayHeight * this.originY) + this.displayHeight; } }, { key: 'topRightX', get() { return -(this.displayWidth * this.originX) + this.displayWidth; } }, { key: 'topLeftX', get() { return -(this.displayWidth * this.originX); } }, { key: 'topLeftY', get() { return -(this.displayHeight * this.originY); } }, { key: 'bottomBound', get() { return this.scrollMode === 0 ? this.bottomLeftY : this.topRightX; } }, { key: 'rightBound', get() { return this.scrollMode === 0 ? this.topRightX : this.bottomLeftY; } }]), f; }()); Object.assign(Bh.prototype, Mh.GetBounds, Th); function _h(t, e, i, n, s, r) { let o; if ((o = void 0 === s ? n : i.pointToCellIndex(n, s)) != null) { const a = i.getCellContainer(o); a && t.emit(e, a, o, r); } } var jh = {
    v: 0, vertical: 0, h: 1, horizontal: 1,
  }; var Dh = { update: 0, everyTick: 1 }; const Ih = function (t) { const e = this.childrenMap.child; const i = e.pointToCellIndex(t.x, t.y); if (i !== e.input.lastOverCellIndex) { const n = e.input.lastOverCellIndex; e.input.lastOverCellIndex = i, _h(this.eventEmitter, 'cell.out', e, n, void 0, t), _h(this.eventEmitter, 'cell.over', e, i, void 0, t); } }; const Yh = function (t) { const e = this.childrenMap.child; const i = e.input.lastOverCellIndex; e.input.lastOverCellIndex = void 0, _h(this.eventEmitter, 'cell.out', e, i, void 0, t); }; const Rh = Phaser.Utils.Objects.GetValue; const Lh = Phaser.Utils.Objects.GetValue; const Fh = (function () { function i(t, e) { B(this, i), this.parent = t, this._isRunning = !1, this.tickingState = !1, this.setEventEmitter(Lh(e, 'eventEmitter', void 0)), this.setTickingMode(Lh(e, 'tickingMode', 1)); } return w(i, [{ key: 'boot', value() { this.tickingMode !== 2 || this.tickingState || this.startTicking(); } }, { key: 'shutdown', value() { this.destroyEventEmitter(), this.tickingState && this.stopTicking(); } }, { key: 'setTickingMode', value(t) { typeof t === 'string' && (t = Ah[t]), this.tickingMode = t; } }, { key: 'startTicking', value() { this.tickingState = !0; } }, { key: 'stopTicking', value() { this.tickingState = !1; } }, { key: 'start', value() { return this.isRunning = !0, this; } }, { key: 'pause', value() { return this.isRunning = !1, this; } }, { key: 'resume', value() { return this.isRunning = !0, this; } }, { key: 'stop', value() { return this.isRunning = !1, this; } }, { key: 'complete', value() { this.isRunning = !1, this.emit('complete', this.parent, this); } }, { key: 'isRunning', get() { return this._isRunning; }, set(t) { this._isRunning !== t && (this._isRunning = t, this.tickingMode === 1 && t != this.tickingState && (t ? this.startTicking() : this.stopTicking())); } }]), i; }()); Object.assign(Fh.prototype, ls); var Ah = { no: 0, lazy: 1, always: 2 }; const Xh = Phaser.Utils.Objects.GetValue; const Hh = (function () { i(r, Fh); const s = S(r); function r(t, e) { let i; B(this, r); const n = Zn(t); return n === t && (t = void 0), (i = s.call(this, n, e)).scene = n, (i.gameObject = t) && t.setInteractive(Xh(e, 'inputConfig', void 0)), i._enable = void 0, i.resetFromJSON(e), i.boot(), i; } return w(r, [{ key: 'resetFromJSON', value(t) { return this.setEnable(Xh(t, 'enable', !0)), void 0 === this.gameObject ? this.bounds = Xh(t, 'bounds', void 0) : this.bounds = void 0, this.tracerState = Uh, this.pointer = void 0, this.lastPointer = void 0, this.movedState = !1, this.isTouchingAnyObject = !1, this; } }, { key: 'boot', value() { g(p(r.prototype), 'boot', this).call(this), this.gameObject ? this.gameObject.on('pointerdown', this.onPointerDown, this) : this.scene.input.on('pointerdown', this.onPointerDown, this), this.scene.input.on('pointerup', this.onPointerUp, this), this.scene.input.on('pointermove', this.onPointerMove, this), this.scene.events.once('shutdown', this.destroy, this); } }, { key: 'shutdown', value() { this.gameObject ? this.gameObject.off('pointerdown', this.onPointerDown, this) : this.scene && this.scene.input.off('pointerdown', this.onPointerDown, this), this.scene && (this.scene.input.off('pointerup', this.onPointerUp, this), this.scene.input.off('pointermove', this.onPointerMove, this), this.scene.events.off('destroy', this.destroy, this), this.scene = void 0), this.scene = void 0, this.gameObject = void 0, this.bounds = void 0, this.pointer = void 0, this.lastPointer = void 0, this.movedState = !1, g(p(r.prototype), 'shutdown', this).call(this); } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'toggleEnable', value() { return this.setEnable(!this.enable), this; } }, { key: 'onPointerDown', value(t, e) { this.enable && void 0 === this.pointer && (this.bounds && !this.bounds.contains(t.x, t.y) || this.pointer === t || (this.pointer = t, this.lastPointer = t, this.movedState = !1, this.tracerState = Vh, void 0 === this.gameObject && (this.isTouchingAnyObject = e.length > 0), this.onDragStart())); } }, { key: 'onPointerUp', value(t) { this.enable && (this.bounds && !this.bounds.contains(t.x, t.y) || this.pointer !== t || (this.pointer = void 0, this.movedState = !1, this.tracerState = Uh, this.onDragEnd())); } }, { key: 'onPointerMove', value(t) { if (this.enable && t.isDown) { const e = !this.bounds || this.bounds.contains(t.x, t.y); const i = this.pointer === t; !i && e || (i && !e ? this.onPointerUp(t) : (this.movedState || (this.movedState = t.x !== t.downX || t.y !== t.downY), this.movedState && this.onDrag())); } } }, { key: 'dragCancel', value() { return this.tracerState === Vh && this.onDragEnd(), this.pointer = void 0, this.tracerState = Uh, this; } }, { key: 'onDragStart', value() { this.emit('dragstart', this); } }, { key: 'onDragEnd', value() { this.emit('dragend', this); } }, { key: 'onDrag', value() { this.emit('drag', this); } }, { key: 'preUpdate', value() {} }, { key: 'postUpdate', value() {} }, { key: 'startTicking', value() { g(p(r.prototype), 'startTicking', this).call(this), this.scene.events.on('preupdate', this.preUpdate, this), this.scene.events.on('postupdate', this.postUpdate, this); } }, { key: 'stopTicking', value() { g(p(r.prototype), 'stopTicking', this).call(this), this.scene && (this.scene.events.off('preupdate', this.preUpdate, this), this.scene.events.off('postupdate', this.postUpdate, this)); } }, { key: 'setRecongizedStateObject', value(t) { return this.recongizedState = t, this; } }, { key: 'cancel', value() { return this.state = Wh, this; } }, { key: 'enable', get() { return this._enable; }, set(t) { if (this._enable !== t) return t || this.dragCancel(), this._enable = t, this; } }, { key: 'state', get() { return this.recongizedState.state; }, set(t) { this.recongizedState.state = t; } }]), r; }()); var Uh = 0; var Vh = 1; var Wh = 'IDLE'; const Gh = Phaser.Utils.Objects.GetValue; const Nh = Phaser.Math.Distance.Between; const Jh = (function () { i(o, Hh); const r = S(o); function o(t, e) { let i; B(this, o); const n = _(i = r.call(this, t, e)); const s = { states: { IDLE: { enter() { n.stop(), n.tapsCount = 0, n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0; }, exit() { const t = n.lastPointer; n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY; } }, BEGIN: { enter() { n.start(), n.tapsCount = 0, n.emit('tappingstart', n, n.gameObject, n.lastPointer); } }, RECOGNIZED: { enter() { n.start(), n.emit('tap', n, n.gameObject, n.lastPointer), n.emit(''.concat(n.tapsCount, 'tap'), n, n.gameObject, n.lastPointer); } } }, init() { this.state = Kh; }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Ua(s)), i; } return w(o, [{ key: 'resetFromJSON', value(t) { g(p(o.prototype), 'resetFromJSON', this).call(this, t), this.setMaxHoldTime(Gh(t, 'time', 250)), this.setTapInterval(Gh(t, 'tapInterval', 200)), this.setDragThreshold(Gh(t, 'threshold', 9)), this.setTapOffset(Gh(t, 'tapOffset', 10)); const e = Gh(t, 'taps', void 0); return void 0 !== e ? this.setTaps(e) : (this.setMaxTaps(Gh(t, 'maxTaps', void 0)), this.setMinTaps(Gh(t, 'minTaps', void 0))), this; } }, { key: 'onDragStart', value() { switch (this.state) { case Kh: this.state = Zh; break; case Zh: var t = this.lastPointer; Nh(t.upX, t.upY, t.x, t.y) > this.tapOffset && (this.state = qh, this.state = Zh); break; case qh: this.state = Zh; } } }, { key: 'onDragEnd', value() { this.state === Zh && (this.tapsCount++, this.emit('tapping', this, this.gameObject, this.lastPointer), void 0 !== this.maxTaps && this.tapsCount === this.maxTaps && (this.state = qh)); } }, { key: 'onDrag', value() { this.state !== Kh && this.pointer.getDistance() > this.dragThreshold && (this.state = Kh); } }, { key: 'preUpdate', value(t) { if (this.state === Zh) { const e = this.lastPointer; if (e.isDown)t - e.downTime > this.holdTime && (this.state = Kh); else t - e.upTime > this.tapInterval && (void 0 === this.minTaps || this.tapsCount >= this.minTaps ? this.state = qh : this.state = Kh); } } }, { key: 'postUpdate', value() { this.state === qh && (this.state = Kh); } }, { key: 'setMaxHoldTime', value(t) { return this.holdTime = t, this; } }, { key: 'setTapInterval', value(t) { return this.tapInterval = t, this; } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'setTapOffset', value(t) { return this.tapOffset = t, this; } }, { key: 'setMaxTaps', value(t) { return this.maxTaps = t, this; } }, { key: 'setMinTaps', value(t) { return this.minTaps = t, this; } }, { key: 'setTaps', value(t, e) { return void 0 === e && (e = t), this.setMinTaps(t).setMaxTaps(e), this; } }, { key: 'isTapped', get() { return this.state === qh; } }]), o; }()); var Kh = 'IDLE'; var Zh = 'BEGIN'; var qh = 'RECOGNIZED'; const $h = Phaser.Utils.Objects.GetValue; const Qh = Phaser.Utils.Objects.GetValue; const tl = (function () { i(o, Hh); const r = S(o); function o(t, e) { let i; B(this, o); const n = _(i = r.call(this, t, e)); const s = { states: { IDLE: { enter() { n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0; }, exit() { const t = n.lastPointer; n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY; } }, BEGIN: { enter() { n.start(); }, exit() { n.stop(); } }, RECOGNIZED: { enter() { n.emit('pressstart', n, n.gameObject, n.lastPointer); }, exit() { n.emit('pressend', n, n.gameObject, n.lastPointer); } } }, init() { this.state = el; }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Ua(s)), i; } return w(o, [{ key: 'resetFromJSON', value(t) { return g(p(o.prototype), 'resetFromJSON', this).call(this, t), this.setDragThreshold(Qh(t, 'threshold', 9)), this.setMinHoldTime(Qh(t, 'time', 251)), this; } }, { key: 'onDragStart', value() { this.state = il, this.holdTime === 0 && (this.state = nl); } }, { key: 'onDragEnd', value() { this.state = el; } }, { key: 'onDrag', value() { this.state !== el && this.pointer.getDistance() > this.dragThreshold && (this.state = el); } }, { key: 'preUpdate', value(t) { this.state === il && t - this.pointer.downTime >= this.holdTime && (this.state = nl); } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'setMinHoldTime', value(t) { return this.holdTime = t, this; } }, { key: 'isPressed', get() { return this.state === nl; } }]), o; }()); var el = 'IDLE'; var il = 'BEGIN'; var nl = 'RECOGNIZED'; const sl = Phaser.Utils.Objects.GetValue; const rl = Phaser.Math.Distance.Between; const ol = Phaser.Math.Angle.Between; const al = {
    getDt() { return this.scene.sys.game.loop.delta; }, getVelocity() { const t = this.pointer.position; const e = this.pointer.prevPosition; return rl(e.x, e.y, t.x, t.y) / (0.001 * this.getDt()); }, getVelocityX() { const t = this.pointer.position; const e = this.pointer.prevPosition; return Math.abs(t.x - e.x) / (0.001 * this.getDt()); }, getVelocityY() { const t = this.pointer.position; const e = this.pointer.prevPosition; return Math.abs(t.y - e.y) / (0.001 * this.getDt()); }, getVelocityAngle() { const t = this.pointer.position; const e = this.pointer.prevPosition; return ol(e.x, e.y, t.x, t.y); },
  }; const hl = {
    'up&down': 0, 'left&right': 1, '4dir': 2, '8dir': 3,
  }; const ll = {}; const ul = Phaser.Utils.Objects.GetValue; const cl = Phaser.Math.RadToDeg; const dl = (function () { i(o, Hh); const r = S(o); function o(t, e) { let i; B(this, o); const n = _(i = r.call(this, t, e)); const s = { states: { IDLE: { enter() { n.x = 0, n.y = 0, n.worldX = 0, n.worldY = 0; }, exit() { const t = n.lastPointer; n.x = t.x, n.y = t.y, n.worldX = t.worldX, n.worldY = t.worldY; } }, BEGIN: { enter() { n.validDrag = !1; } }, RECOGNIZED: { enter() { n.start(), n.updateDirectionStates(), n.emit('swipe', n, n.gameObject, n.lastPointer); }, exit() { n.stop(), n.clearDirectionStates(); } } }, init() { this.state = vl; }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Ua(s)), i.clearDirectionStates(), i; } return w(o, [{ key: 'resetFromJSON', value(t) { return g(p(o.prototype), 'resetFromJSON', this).call(this, t), this.setDragThreshold(ul(t, 'threshold', 10)), this.setMinDragVelocity(ul(t, 'velocityThreshold', 1e3)), this.setDirectionMode(ul(t, 'dir', '8dir')), this; } }, { key: 'onDragStart', value() { this.state = pl; } }, { key: 'onDragEnd', value() { this.state = vl; } }, { key: 'onDrag', value() { this.state === pl && (this.vaildDrag || (this.vaildDrag = this.dragThreshold === 0 || this.pointer.getDistance() >= this.dragThreshold), this.vaildDrag && this.dragVelocity > this.minDragVelocity && (this.state = gl)); } }, { key: 'postUpdate', value() { this.state === gl && (this.state = vl); } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'setMinDragVelocity', value(t) { return this.minDragVelocity = t, this; } }, { key: 'setDirectionMode', value(t) { return typeof t === 'string' && (t = hl[t]), this.dirMode = t, this; } }, { key: 'updateDirectionStates', value() { return (function (t, e, i) { switch (void 0 === i ? i = {} : !0 === i && (i = ll), i.left = !1, i.right = !1, i.up = !1, i.down = !1, t = (t + 360) % 360, e) { case 0: t < 180 ? i.down = !0 : i.up = !0; break; case 1: t > 90 && t <= 270 ? i.left = !0 : i.right = !0; break; case 2: t > 45 && t <= 135 ? i.down = !0 : t > 135 && t <= 225 ? i.left = !0 : t > 225 && t <= 315 ? i.up = !0 : i.right = !0; break; case 3: t > 22.5 && t <= 67.5 ? (i.down = !0, i.right = !0) : t > 67.5 && t <= 112.5 ? i.down = !0 : t > 112.5 && t <= 157.5 ? (i.down = !0, i.left = !0) : t > 157.5 && t <= 202.5 ? i.left = !0 : t > 202.5 && t <= 247.5 ? (i.left = !0, i.up = !0) : t > 247.5 && t <= 292.5 ? i.up = !0 : (t > 292.5 && t <= 337.5 && (i.up = !0), i.right = !0); } }(cl(this.getVelocityAngle()), this.dirMode, this)), this; } }, { key: 'clearDirectionStates', value() { return this.left = !1, this.right = !1, this.up = !1, this.down = !1, this; } }, { key: 'isSwiped', get() { return this.state === gl; } }, { key: 'dragVelocity', get() { let t; switch (this.dirMode) { case 0: t = this.getVelocityY(); break; case 1: t = this.getVelocityX(); break; default: t = this.getVelocity(); } return t; } }]), o; }()); Object.assign(dl.prototype, al); function fl(t, e) { t.setInteractive(), function (e) { e.on('pointerdown', function (t) { _h(this.eventEmitter, 'cell.down', e, t.x, t.y, t); }, this).on('pointerup', function (t) { _h(this.eventEmitter, 'cell.up', e, t.x, t.y, t); }, this); }.call(this, t, e), function (t) { t.on('pointermove', Ih, this).on('pointerover', Ih, this).on('pointerout', Yh, this); }.call(this, t, e), function (t, e) { let i = Rh(e, 'button', void 0); !1 !== i && (void 0 === i && (i = {}), i.threshold = 10, t._click = new go(t, i), t._click.on('click', function (t, e, i) { _h(this.eventEmitter, 'cell.click', e, i.x, i.y, i); }, this)); }.call(this, t, e), function (t, e) { const i = $h(e, 'tap', void 0); !1 !== i && (t._tap = new Jh(t, i), t._tap.on('tap', function (t, e, i) { const n = 'cell.'.concat(t.tapsCount, 'tap'); _h(this.eventEmitter, n, t.gameObject, t.x, t.y, i); }, this)); }.call(this, t, e), function (n, t) { const e = sl(t, 'press', void 0); !1 !== e && (n._press = new tl(n, e), n._press.on('pressstart', function (t, e, i) { _h(this.eventEmitter, 'cell.pressstart', n, t.x, t.y, i); }, this).on('pressend', function (t, e, i) { _h(this.eventEmitter, 'cell.pressend', n, t.x, t.y, i); }, this)); }.call(this, t, e), function (s, t) { let e = yl(t, 'swipe', void 0); !1 !== e && (void 0 === e && (e = {}), e.dir = '4dir', s._swipe = new dl(s, e), s._swipe.on('swipe', function (t, e, i) { const n = t.left ? 'left' : t.right ? 'right' : t.up ? 'up' : 'down'; _h(this.eventEmitter, 'cell.swipe'.concat(n), s, t.x, t.y, i); }, this)); }.call(this, t, e); } var vl = 'IDLE'; var pl = 'BEGIN'; var gl = 'RECOGNIZED'; var yl = Phaser.Utils.Objects.GetValue; const ml = Phaser.Utils.Objects.GetValue; const bl = (function () { i(p, nh); const v = S(p); function p(t, e) { let i; B(this, p), void 0 === e && (e = {}); const n = Fa(e); let s = ml(e, 'table', void 0); void 0 === s && (s = {}), s.scrollMode = n, s.clamplTableOXY = ml(e, 'clamplChildOY', !1); let r; let o; let a; const h = ml(s, 'width', void 0); const l = ml(s, 'height', void 0); const u = new Bh(t, 0, 0, h, l, s); t.add.existing(u), o = n === 0 ? (r = void 0 === h ? 1 : 0, void 0 === l) : (r = void 0 === l ? 1 : 0, void 0 === h), a = u, Object.defineProperty(a, 'childOY', { configurable: !0, get() { return a.tableOY; }, set(t) { a.tableOY = t; } }), Object.defineProperty(a, 'topChildOY', { get() { return a.topTableOY; } }), Object.defineProperty(a, 'bottomChildOY', { get() { return a.bottomTableOY; } }), e.type = 'rexGridTable', e.child = { gameObject: u, proportion: r, expand: o }; const c = ml(e, 'space', void 0); c && (c.child = c.table), (i = v.call(this, t, e)).addChildrenMap('table', u), i.eventEmitter = ml(e, 'eventEmitter', _(i)); const d = ml(e, 'createCellContainerCallback', vt); const f = ml(e, 'createCellContainerCallbackScope', void 0); return i.setCreateCellContainerCallback(d, f), function (t) { t.on('cellvisible', function (t, e, i) { const n = this.createCellContainerCallback; const s = this.createCellContainerCallbackScope; t.item = this.items[t.index], (e = s ? n.call(s, t, e, i) : n(t, e, i)) && (e.setOrigin && e.setOrigin(0), e.isRexSizer && e.layout()), t.item = void 0, t.setContainer(e); }, this); }.call(_(i), u), ml(s, 'interactive', !0) && fl.call(_(i), u, s), i.setItems(ml(e, 'items', [])), i; } return w(p, [{ key: 'setCreateCellContainerCallback', value(t, e) { return this.createCellContainerCallback = t, this.createCellContainerCallbackScope = e, this; } }, { key: 'refresh', value() { return this.setItems(this.items), this; } }, { key: 'getCellContainer', value(t) { return this.childrenMap.child.getCellContainer(t); } }, { key: 'updateVisibleCell', value(t) { return this.childrenMap.child.updateVisibleCell(t); } }]), p; }()); const xl = { setItems(t) { void 0 === t ? this.items.length = 0 : this.items = t; const e = this.childrenMap.child; return e.setCellsCount(this.items.length), e.updateTable(!0), this.resizeController(), this; } }; Object.assign(bl.prototype, xl), c.register('gridTable', function (t) { const e = new bl(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.GridTable', bl); function kl(t, e) { return e.orientation = t.orientation, e; } const Cl = {
    expandSubMenu(t, e) {
      let i; this.collapseSubMenu(), i = this.root.toggleOrientation ? this.orientation === 0 ? 1 : 0 : this.orientation; const n = new this.constructor(this.scene, {
        items: e, orientation: i, createBackgroundCallback: this.root.createBackgroundCallback, createBackgroundCallbackScope: this.root.createBackgroundCallbackScope, createButtonCallback: this.root.createButtonCallback, createButtonCallbackScope: this.root.createButtonCallbackScope, easeIn: this.root.easeIn, easeOut: this.root.easeOut, _rootMenu: this.root, _parentMenu: this, _parentButton: t,
      }); return this.pin(n), this.childrenMap.subMenu = n, this.root.emit('expand', n, t, this), this;
    },
    collapse() { return this.root.emit('collapse', this, this.parentButton, this.parentMenu), this.scaleDownDestroy(kl(this, this.root.easeOut)), this.collapseSubMenu(), this; },
    collapseSubMenu() { if (void 0 === this.childrenMap.subMenu) return this; const t = this.childrenMap.subMenu; return this.childrenMap.subMenu = void 0, this.remove(t), t.collapse(), this; },
  }; const wl = Phaser.Utils.Objects.GetValue; const Sl = (function () { i(x, Ho); const b = S(x); function x(t, e) { let i; B(this, x), void 0 === e && (e = {}), e.hasOwnProperty('orientation') || (e.orientation = 1); let n; let s; let r; let o; let a; const h = e._rootMenu; const l = e._parentMenu; const u = e._parentButton; const c = wl(e, 'items', void 0); const d = wl(e, 'createBackgroundCallback', void 0); const f = wl(e, 'createBackgroundCallbackScope', void 0); e.background = (n = t, s = c, o = f, (r = d) && (s.scene = n, a = o ? r.call(o, s) : r(s), s.scene = void 0), a); const v = wl(e, 'createButtonCallback', void 0); const p = wl(e, 'createButtonCallbackScope', void 0); e.buttons = (function (t, e, i, n) { let s; let r; const o = []; if (e && i) for (let a = 0, h = e.length; a < h; a++)(s = e[a]).scene = t, r = n ? i.call(n, s, a, e) : i(s, a, e), s.scene = void 0, o.push(r); return o; }(t, c, v, p)), (i = b.call(this, t, e)).type = 'rexMenu', i.items = c, i.root = void 0 === h ? _(i) : h, i.parentMenu = l, i.parentButton = u; const g = i.root === _(i); g && (void 0 === (m = e.bounds) && (m = gn(t)), i.bounds = m, i.expandEventName = wl(e, 'expandEvent', 'button.click'), i.toggleOrientation = wl(e, 'toggleOrientation', !1), i.easeIn = wl(e, 'easeIn', 0), typeof i.easeIn === 'number' && (i.easeIn = { duration: i.easeIn }), i.easeOut = wl(e, 'easeOut', 0), typeof i.easeOut === 'number' && (i.easeOut = { duration: i.easeOut }), i.createBackgroundCallback = d, i.createBackgroundCallbackScope = f, i.createButtonCallback = v, i.createButtonCallbackScope = p, i._isPassedEvent = !1); i.setOrigin(0).layout(); let y; var m = i.root.bounds; if (g)i.expandOrientation = [i.y < m.centerY ? 1 : 3, i.x < m.centerX ? 0 : 2]; else switch (i.root.expandOrientation[l.orientation]) { case 0: i.alignTop(u.top).alignLeft(u.right); break; case 1: i.alignLeft(u.left).alignTop(u.bottom); break; case 2: i.alignTop(u.top).alignRight(u.left); break; case 3: i.alignLeft(u.left).alignBottom(u.top); } return i.pushIntoBounds(m), (y = _(i)).on(y.root.expandEventName, function (t, e) { if (!this._isPassedEvent) { const i = this.items[e].children; i && this.expandSubMenu(t, i); } }, y).on('button.click', function (t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit('button.click', t, e, i, n), this.root._isPassedEvent = !1); }, y).on('button.over', function (t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit('button.over', t, e, i, n), this.root._isPassedEvent = !1); }, y).on('button.out', function (t, e, i, n) { this !== this.root && (this.root._isPassedEvent = !0, this.root.emit('button.out', t, e, i, n), this.root._isPassedEvent = !1); }, y), i.popUp(kl(_(i), i.root.easeIn)), i; } return w(x, [{ key: 'isInTouching', value(t) { return !!g(p(x.prototype), 'isInTouching', this).call(this, t) || !!this.childrenMap.subMenu && this.childrenMap.subMenu.isInTouching(t); } }]), x; }()); Object.assign(Sl.prototype, Cl), c.register('menu', function (t) { const e = new Sl(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Menu', Sl); function Ol(t) { return t instanceof Tl; } var Tl = Phaser.GameObjects.Text; const Pl = Phaser.Utils.Objects.GetValue; const Ml = Phaser.Math.Clamp; const El = (function () {
    function i(t, e) { B(this, i), this.gameObject = t, this.scene = Zn(t), this.setTextObjectType(), this.lines = void 0, this.resetFromJSON(e), this.boot(); } return w(i, [{ key: 'resetFromJSON', value(t) { return this.setText(Pl(t, 'text', '')), this.setStartIdx(Pl(t, 'start', 0)), this.setPageIdx(Pl(t, 'page', -1)), this; } }, {
      key: 'toJSON',
      value() {
        return {
          text: this.text, start: this.startLineIdx, page: this.pageIndex, pageCount: this.pageCount,
        };
      },
    }, { key: 'boot', value() { this.gameObject.on('destroy', this.destroy, this); } }, { key: 'shutdown', value() { return void 0 === this.lines || (this.textObjectType === 0 ? this.lines.length = 0 : this.lines.destroy()), this.gameObject = void 0, this.scene = void 0, this; } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setTextObjectType', value() { return this.textObjectType = Ol(this.gameObject) ? 0 : 1, this; } }, { key: 'setText', value(t, e) { return void 0 === e && (e = !0), this.text = zl(t), this.textObjectType === 0 ? this.lines = this.gameObject.getWrappedText(this.text) : this.lines = this.gameObject.getPenManager(this.text, this.lines), this.pageCount = Math.ceil(this.totalLinesCount / this.pageLinesCount), e && this.resetPageIdx(), this; } }, { key: 'appendText', value(t) { return this.setText(this.text.concat(zl(t))), this; } }, { key: 'getPage', value(t) { return void 0 === t && (t = this.pageIndex), this.setPageIdx(t).getLines(); } }, { key: 'getNextPage', value() { return this.getPage(this.pageIndex + 1); } }, { key: 'getPreviousPage', value() { return this.getPage(this.pageIndex - 1); } }, { key: 'showPage', value() { return this.displayText(this.getPage()), this; } }, { key: 'showNextPage', value() { return this.displayText(this.getNextPage()), this; } }, { key: 'showPreviousPage', value() { return this.displayText(this.getPreviousPage()), this; } }, { key: 'show', value() { return this.displayText(this.getLines()), this; } }, { key: 'showNextLine', value() { return this.displayText(this.setStartIdx(this.startLineIdx + 1).getLines()), this; } }, { key: 'showPreviousLine', value() { return this.displayText(this.setStartIdx(this.startLineIdx - 1).getLines()), this; } }, { key: 'setStartIdx', value(t) { return t = Ml(t, 0, this.totalLinesCount - 1), this.startLineIdx = t, this; } }, { key: 'resetPageIdx', value() { this.pageIndex = -1; } }, { key: 'setPageIdx', value(t) { return t = Ml(t, 0, this.pageCount - 1), this.pageIndex = t, this.setStartIdx(this.pageIndex * this.pageLinesCount), this; } }, { key: 'getLines', value(t) { void 0 === t && (t = this.startLineIdx); let e; const i = t + this.pageLinesCount; if (this.textObjectType === 0)e = this.lines.slice(t, i).join('\n'); else { const n = this.lines.getLineStartIndex(t); const s = this.lines.getLineEndIndex(i - 1); e = this.lines.getSliceTagText(n, s, !0); } return e; } }, { key: 'displayText', value(t) { this.gameObject.setText(t); } }, { key: 'isFirstPage', get() { return this.pageIndex <= 0; } }, { key: 'isLastPage', get() { return this.pageIndex >= this.pageCount - 1; } }, { key: 'totalLinesCount', get() { return this.textObjectType === 0 ? this.lines.length : this.lines.linesCount; } }, { key: 'pageLinesCount', get() { const t = this.gameObject.style.maxLines; return t > 0 ? t : this.totalLinesCount; } }]), i;
  }()); var zl = function (t) { return Array.isArray(t) ? t = t.join('\n') : typeof t === 'number' && (t = t.toString()), t; }; const Bl = Phaser.Utils.Objects.GetFastValue; const _l = Phaser.Utils.Objects.GetValue; const jl = (function () {
    function i(t, e) { B(this, i), this.gameObject = t, this.scene = Zn(t), this.setEventEmitter(_l(e, 'eventEmitter', void 0)), this.timer = null, this.resetFromJSON(e), this.boot(); } return w(i, [{ key: 'resetFromJSON', value(t) { this.setTypeMode(_l(t, 'typeMode', 0)), this.setTypeSpeed(_l(t, 'speed', 333)), this.setTextCallback = Bl(t, 'setTextCallback', null), this.setTextCallbackScope = Bl(t, 'setTextCallbackScope', null), this.typingIdx = Bl(t, 'typingIdx', 0), this.text = Dl(Bl(t, 'text', '')), this.textLen = Bl(t, 'textLen', 0), this.insertIdx = Bl(t, 'insertIdx', null); const e = Bl(t, 'elapsed', null); return e !== null && this.start(void 0, void 0, this.typingIdx, e), this; } }, {
      key: 'toJSON',
      value() {
        let t; const e = this.getTimer(); return t = e ? e.elapsed : null, {
          typeMode: this.typeMode, speed: this.speed, setTextCallback: this.setTextCallback, setTextCallbackScope: this.setTextCallbackScope, typingIdx: this.typingIdx, text: this.text, textLen: this.textLen, insertIdx: this.insertIdx, elapsed: t,
        };
      },
    }, { key: 'boot', value() { return this.gameObject.once && this.gameObject.on('destroy', this.destroy, this), this; } }, { key: 'shutdown', value() { return this.destroyEventEmitter(), this.freeTimer(), this.gameObject = void 0, this.scene = void 0, this; } }, { key: 'destroy', value() { return this.shutdown(), this; } }, { key: 'setTypeMode', value(t) { return typeof t === 'string' && (t = Il[t]), this.typeMode = t, this; } }, { key: 'setTypeSpeed', value(t) { return this.speed = t, this; } }, { key: 'start', value(t, e, i, n) { return void 0 !== t && this.setTypingContent(t), void 0 !== e && (this.speed = e), void 0 === i && (i = 0), this.typingIdx = i + 1, this.speed === 0 ? this.stop(!0) : this.startTimer(n), this; } }, { key: 'appendText', value(t) { const e = this.text.concat(Dl(t)); return this.isTyping ? this.setTypingContent(e) : this.start(e, void 0, this.textLen), this; } }, { key: 'stop', value(t) { return this.getTimer() && this.freeTimer(), t && (this.typingIdx = this.textLen, this.setText(this.text), this.emit('type'), this.emit('complete', this, this.gameObject)), this; } }, { key: 'pause', value() { const t = this.getTimer(); return t && (t.paused = !0), this; } }, { key: 'resume', value() { const t = this.getTimer(); return t && (t.paused = !1), this; } }, { key: 'setTypingContent', value(t) { return this.text = Dl(t), this.textLen = this.getTextLength(this.text), this; } }, { key: 'onTyping', value() { const t = this.getTypingString(this.text, this.typingIdx, this.textLen, this.typeMode); this.setText(t), this.emit('type'), this.isLastChar ? (this.freeTimer(), this.emit('complete', this, this.gameObject)) : (this.timer.delay = this.speed, this.typingIdx++); } }, { key: 'getTypingString', value(t, e, i, n) { let s; if (n === 0) { var r = 0; var o = e; this.insertIdx = o, s = this.getSubString(t, r, o); } else if (n === 1) { r = (o = i) - e; this.insertIdx = 0, s = this.getSubString(t, r, o); } else if (n === 2) { const a = i / 2; o = (r = Math.floor(a - e / 2)) + e; this.insertIdx = e % 2 ? e : 0, s = this.getSubString(t, r, o); } else if (n === 3) { let h; const l = Math.floor(e / 2); if (l > 0) { r = (o = i) - l; h = this.getSubString(t, r, o); } else h = ''; let u; const c = e - l; if (c > 0) { o = (r = 0) + c; this.insertIdx = o, u = this.getSubString(t, r, o); } else u = '', this.insertIdx = 0; s = u + h; } return s; } }, {
      key: 'startTimer',
      value(t) {
        let e; return this.timer && this.freeTimer(), e = void 0 === t ? 0 : (this.speed, t), this.timer = this.scene.time.addEvent({
          delay: 0, startAt: e, loop: !0, callback: this.onTyping, callbackScope: this,
        }), this;
      },
    }, { key: 'getTimer', value() { return this.timer; } }, { key: 'freeTimer', value() { return this.timer && (this.timer.remove(), this.timer = null), this; } }, { key: 'setText', value(t) { this.setTextCallback && (t = this.setTextCallbackScope ? this.setTextCallback.call(this.setTextCallbackScope, t, this.isLastChar, this.insertIdx) : this.setTextCallback(t, this.isLastChar, this.insertIdx)), this.gameObject.setText(t); } }, { key: 'getTextLength', value(t) { const e = this.gameObject; return e.getPlainText ? e.getPlainText(t).length : t.length; } }, { key: 'getSubString', value(t, e, i) { const n = this.gameObject; return n.getSubString ? n.getSubString(t, e, i) : t.slice(e, i); } }, { key: 'isTyping', get() { return this.getTimer() !== null; } }, { key: 'isLastChar', get() { return this.typingIdx === this.textLen; } }]), i;
  }()); Object.assign(jl.prototype, ls); var Dl = function (t) { return Array.isArray(t) ? t = t.join('\n') : typeof t === 'number' && (t = t.toString()), t; }; var Il = {
    'left-to-right': 0, 'right-to-left': 1, 'middle-to-sides': 2, 'sides-to-middle': 3,
  }; const Yl = Phaser.Utils.Objects.GetValue; const Rl = (function () { i(r, fo); const s = S(r); function r(t, e) { let i; B(this, r), void 0 === e && (e = { text: Ll(t) }), (i = s.call(this, t, e)).type = 'rexTextBox'; const n = i.childrenMap.text; return i.page = new El(n, Yl(e, 'page', void 0)), i.typing = new jl(n, Yl(e, 'type', void 0)), i.typing.on('complete', i.onPageEnd, _(i)).on('type', i.onType, _(i)), i.textWidth = n.width, i.textHeight = n.height, i; } return w(r, [{ key: 'start', value(t, e) { return this.page.setText(t), void 0 !== e && this.typing.setTypeSpeed(e), this.typeNextPage(), this; } }, { key: 'typeNextPage', value() { if (this.page.isLastPage) this.emit('complete'); else { const t = this.page.getNextPage(); this.typing.start(t); } return this; } }, { key: 'pause', value() { return this.typing.pause(), this; } }, { key: 'resume', value() { return this.typing.resume(), this; } }, { key: 'stop', value(t) { return this.typing.stop(t), this; } }, { key: 'onType', value() { const t = this.childrenMap.text; this.textWidth === t.width && this.textHeight === t.height || (this.textWidth = t.width, this.textHeight = t.height, this.getTopmostSizer().layout()), this.emit('type'); } }, { key: 'onPageEnd', value() { this.emit('pageend'); } }, { key: 'isTyping', get() { return this.typing.isTyping; } }, { key: 'isLastPage', get() { return this.page.isLastPage; } }, { key: 'isFirstPage', get() { return this.page.isFirstPage; } }, { key: 'pageCount', get() { return this.page.pageCount; } }, { key: 'pageIndex', get() { return this.page.pageIndex; } }]), r; }()); var Ll = function (t) { return t.add.text(0, 0, '', { wordWrap: { width: 200 }, maxLines: 5 }); }; c.register('textBox', function (t) { const e = new Rl(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.TextBox', Rl); const Fl = Phaser.Utils.Objects.GetValue; const Al = Phaser.Math.Percent; const Xl = Phaser.Math.Linear; const Hl = (function () { i(g, fr); const p = S(g); function g(t, e) { let i; B(this, g), (i = p.call(this, t, e)).type = 'rexNumberBar'; let n; const s = Fl(e, 'background', void 0); const r = Fl(e, 'icon', void 0); let o = Fl(e, 'iconMask', void 0); const a = Fl(e, 'slider', void 0); const h = Fl(e, 'text', void 0); const l = Fl(e, 'space.icon', 0); const u = Fl(e, 'space.slider', 0); s && i.addBackground(s), r && (i.orientation === 0 ? (a || h) && (c = { right: l }) : (a || h) && (c = { bottom: l }), i.add(r, 0, 'center', c), o = o && i.addChildMask(r, r, 1)); if (a) { var c; let d; if (a.orientation = i.orientation, a.eventEmitter = _(i), a.value = null, a.hasOwnProperty('input') || (a.input = -1), n = new Ya(t, a), i.orientation === 0 ? h && (c = { right: u }) : h && (c = { bottom: u }), i.orientation === 0)d = void 0 === Fl(a, 'width', void 0) ? 1 : 0; else d = void 0 === Fl(a, 'height', void 0) ? 1 : 0; i.add(n, d, 'center', c); }h && i.add(h), i.addChildrenMap('background', s), i.addChildrenMap('icon', r), i.addChildrenMap('iconMask', o), i.addChildrenMap('slider', n), i.addChildrenMap('text', h); const f = Fl(e, 'valuechangeCallback', null); if (f !== null) { const v = Fl(e, 'valuechangeCallbackScope', void 0); i.on('valuechange', f, v); } return i.setEnable(Fl(e, 'enable', void 0)), i.setValue(Fl(e, 'value', 0)), i; } return w(g, [{ key: 'setEnable', value(t) { return this.childrenMap.slider || (void 0 === t && (t = !0), this.childrenMap.slider.enable = t), this; } }, { key: 'setValue', value(t, e, i) { return void 0 !== e && (t = Al(t, e, i)), this.value = t, this; } }, { key: 'addValue', value(t, e, i) { return void 0 !== e && (t = Al(t, e, i)), this.value += t, this; } }, { key: 'getValue', value(t, e) { let i = this.value; return void 0 !== t && (i = Xl(t, e, i)), i; } }, { key: 'setText', value(t) { return this.text = t, this; } }, { key: 'value', get() { return this.childrenMap.slider ? this.childrenMap.slider.value : 0; }, set(t) { this.childrenMap.slider && (this.childrenMap.slider.value = t); } }, { key: 'text', get() { const t = this.childrenMap.text; return void 0 === t ? '' : t.text ? t.text : t.getData('text'); }, set(t) { const e = this.childrenMap.text; void 0 !== e && (e.setText ? e.setText(t) : e.setData('text', t)); } }]), g; }()); const Ul = { addChildMask: ao }; Object.assign(Hl.prototype, Ul), c.register('numberBar', function (t) { const e = new Hl(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.NumberBar', Hl); const Vl = Ii.prototype.setChildVisible; const Wl = { addPage(t, e, i, n, s) { return t.setVisible(!1), this.add(t, e, i, n, s), this; }, getPage(t) { return void 0 !== t && this.sizerChildren.hasOwnProperty(t) ? this.sizerChildren[t] : null; }, swapPage(t) { this._previousKey = this._currentKey; const e = this.previousPage; e && (this.swapMode === 0 ? (Vl.call(this, e, !1), this.emit('pageinvisible', e, this._previousKey, this)) : e.destroy()), t && !this.sizerChildren.hasOwnProperty(t) && this.emit('createpage', t, this), this._currentKey = t; const i = this.currentPage; return i && (Vl.call(this, i, !0), this.emit('pagevisible', i, this._currentKey, this)), this; } }; const Gl = Phaser.Utils.Objects.GetValue; const Nl = (function () { i(s, oo); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t, e)).type = 'rexPages', i.childrenMap = i.sizerChildren, i._previousKey = void 0, i._currentKey = void 0, i.setSwapMode(Gl(e, 'swapMode', 0)), i; } return w(s, [{ key: 'setSwapMode', value(t) { return typeof t === 'string' && (t = Jl[t]), this.swapMode = t, this; } }, { key: 'previousKey', get() { return this._previousKey; } }, { key: 'currentKey', get() { return this._currentKey; }, set(t) { this.swapPage(t); } }, { key: 'currentPage', get() { return this.getPage(this.currentKey); } }, { key: 'previousPage', get() { return this.getPage(this.previousKey); } }, { key: 'keys', get() { return Object.keys(this.sizerChildren); } }]), s; }()); Object.assign(Nl.prototype, Wl); var Jl = { invisible: 0, destroy: 1 }; c.register('pages', function (t) { const e = new Nl(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Pages', Nl); function Kl(t) { return (t - this.textLineSpacing) / (this.textLineHeight + this.textLineSpacing); } function Zl(t) { return t * (this.textLineHeight + this.textLineSpacing) - this.textLineSpacing; } function ql() { const t = this.textObject.rexSizer; this.textObject.y += t.offsetY - t.preOffsetY, t.preOffsetY = t.offsetY, this.resetChildPositionState(this.textObject); } const $l = Phaser.Display.Align.TOP_LEFT; const Ql = {
    addChildMask: ao, setTextObject(t, e) { void 0 === e && (e = !0), this.add(t); const i = this.getSizerConfig(t); return i.align = $l, i.padding = Wn(0), i.expand = !0, this.textObject = t, this.textObjectType = Ol(t) ? 0 : 1, i.preOffsetY = 0, i.offsetY = 0, e && (this.textMask = this.addChildMask(this.textObject, this)), this; }, setText(t) { return void 0 !== t && (this.text = t), this.textObjectType === 0 ? this.lines = this.textObject.getWrappedText(this.text) : this.lines = this.textObject.getPenManager(this.text, this.lines), this.updateTextObject(), this; }, updateTextObject() { const t = Math.max(Math.floor(Kl.call(this, -this.textOY)), 0); const e = Zl.call(this, t) + this.textOY; return this.textObject.setText(function (t) { let e; const i = t + this.textObject.style.maxLines; if (this.textObjectType === 0)e = this.lines.slice(t, i).join('\n'); else { const n = this.lines.getLineStartIndex(t); const s = this.lines.getLineEndIndex(i - 1); e = this.lines.getSliceTagText(n, s, !0); } return e; }.call(this, t)), this.textObject.rexSizer.offsetY = e, ql.call(this), this; }, _layout(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; let n; let s; let r; this.preLayout(t), void 0 === e && (e = this.minWidth), void 0 === i && (i = this.minHeight), this.resize(e, i); let o; let a; let h; let l; const u = this.left; const c = this.top; return (n = this.textObject).rexSizer.hidden || (o = u + (r = (s = n.rexSizer).padding).left, a = c + r.top, h = this.width - r.left - r.right, l = this.height - r.top - r.bottom, function (t, e, i) { if (i += this.textLineHeight + this.textLineSpacing, t.width !== e || t.height !== i) { t.setFixedSize(e, i); const n = t.style; const s = Math.max(e, 0); const r = Math.ceil(Kl.call(this, i)) + 1; this.textObjectType === 0 ? n.wordWrapWidth = s : n.wrapWidth = s, n.maxLines = r, this.setText(); } }.call(this, n, h, l), xn.setPosition(o, a).setSize(h, l), Vn(n, xn, s.align), s.preOffsetY = 0, ql.call(this), this.textMask && (this.textMask.setPosition().resize(), this.resetChildPositionState(this.textMask))), this.layoutBackgrounds(), this.postLayout(); },
  }; const tu = Phaser.Utils.Objects.IsPlainObject; const eu = Phaser.Utils.Objects.GetValue; const iu = (function () { i(c, $s); const u = S(c); function c(t, e, i, n, s, r) { let o; B(this, c), tu(e) ? (e = eu(r = e, 'x', 0), i = eu(r, 'y', 0), n = eu(r, 'width', void 0), s = eu(r, 'height', void 0)) : tu(n) && (n = eu(r = n, 'width', void 0), s = eu(r, 'height', void 0)), (o = u.call(this, t, e, i, n, s, r)).type = 'rexTextBlock', o.textObject = void 0, o.textMask = void 0, o.textObjectType = void 0, o.lines = void 0, o.text = eu(r, 'content', ''), o._textOY = 0, o.execeedTopState = !1, o.execeedBottomState = !1, o.setClampMode(eu(r, 'clamplTextOY', !0)); const a = eu(r, 'background', void 0); let h = eu(r, 'text', void 0); void 0 === h && (h = nu(t)); const l = eu(r, 'textMask', !0); return a && o.addBackground(a), o.setTextObject(h, l), o.addChildrenMap('background', a), o.addChildrenMap('text', h), o; } return w(c, [{ key: 'destroy', value(t) { this.scene && (this.textObject = void 0, (this.textMask = void 0) === this.lines || (this.textObjectType === 0 ? this.lines.length = 0 : this.lines.destroy()), g(p(c.prototype), 'destroy', this).call(this, t)); } }, { key: 'setClampMode', value(t) { return void 0 === t && (t = !0), this.clampTextOY = t, this; } }, { key: 'textOYExceedTop', value(t) { return void 0 === t && (t = this.textOY), t > this.topTextOY; } }, { key: 'textOYExeceedBottom', value(t) { return void 0 === t && (t = this.textOY), t < this.bottomTextOY; } }, { key: 'setTextOY', value(t) { return this.textOY = t, this; } }, { key: 'setTextOYByPercentage', value(t) { return this.t = t, this; } }, { key: 'textLineHeight', get() { const t = this.textObject.style; return t.metrics.fontSize + t.strokeThickness; } }, { key: 'textLineSpacing', get() { return this.textObject.lineSpacing; } }, { key: 'linesCount', get() { return void 0 === this.lines ? 0 : this.textObjectType === 0 ? this.lines.length : this.lines.linesCount; } }, { key: 'visibleLinesCount', get() { return Math.floor(Kl.call(this, this.textObject.height)); } }, { key: 'topTextOY', get() { return 0; } }, { key: 'bottomTextOY', get() { return -this.textVisibleHeight; } }, { key: 'textHeight', get() { return Zl.call(this, this.linesCount); } }, { key: 'textObjectHeight', get() { return this.textObject.height - this.textLineHeight - this.textLineSpacing; } }, { key: 'textVisibleHeight', get() { const t = this.textHeight; const e = this.textObjectHeight; return e < t ? t - e : 0; } }, { key: 'textOY', get() { return this._textOY; }, set(t) { const e = this.topTextOY; const i = this.bottomTextOY; const n = this.textOYExceedTop(t); const s = this.textOYExeceedBottom(t); this.clampTextOY && (this.visibleLinesCount > this.linesCount ? t = 0 : n ? t = e : s && (t = i)), this._textOY !== t && (this._textOY = t, this.updateTextObject()), n && (this.execeedTopState || this.emit('execeedtop', this, t, e)), this.execeedTopState = n, s && (this.execeedBottomState || this.emit('execeedbottom', this, t, i)), this.execeedBottomState = s; } }, { key: 't', set(t) { this.textOY = -this.textVisibleHeight * t; }, get() { const t = this.textVisibleHeight; return t === 0 ? 0 : this.textOY / -t; } }]), c; }()); var nu = function (t) { return t.add.text(0, 0, ''); }; Object.assign(iu.prototype, Ql), c.register('textBlock', function (t, e, i, n, s, r) { const o = new iu(this.scene, t, e, i, n, s, r); return this.scene.add.existing(o), o; }), ut(window, 'RexPlugins.UI.TextBlock', iu); const su = Phaser.Utils.Objects.GetValue; const ru = (function () {
    i(v, nh); const f = S(v); function v(t, e) {
      let i; B(this, v), void 0 === e && (e = {}); const n = su(e, 'text', void 0); const s = su(e, 'textWidth', void 0); const r = su(e, 'textHeight', void 0); const o = su(e, 'textMask', !0); const a = su(e, 'content', ''); const h = new iu(t, {
        width: s, height: r, text: n, textMask: o, content: a, clamplTextOY: su(e, 'clamplChildOY', !1),
      }); t.add.existing(h); let l; const u = void 0 === s ? 1 : 0; const c = void 0 === r; l = h, Object.defineProperty(l, 'childOY', { configurable: !0, get() { return l.textOY; }, set(t) { l.textOY = t; } }), Object.defineProperty(l, 'topChildOY', { get() { return l.topTextOY; } }), Object.defineProperty(l, 'bottomChildOY', { get() { return l.bottomTextOY; } }), e.scrollMode = 0, e.type = 'rexTextArea', e.child = { gameObject: h, proportion: u, expand: c }; const d = su(e, 'space', void 0); return d && (d.child = d.text), (i = f.call(this, t, e)).addChildrenMap('text', n), i;
    } return w(v, [{ key: 'text', get() { return this.childrenMap.child.text; } }, { key: 'linesCount', get() { return this.childrenMap.child.linesCount; } }, { key: 'contentHeight', get() { return this.childrenMap.child.textHeight; } }]), v;
  }()); const ou = { setText(t) { return this.childrenMap.child.setText(t), this.resizeController(), this; }, appendText(t) { return this.setText(this.text + t), this; } }; Object.assign(ru.prototype, ou), c.register('textArea', function (t) { const e = new ru(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.TextArea', ru); const au = Phaser.Utils.Objects.GetValue; const hu = Phaser.Display.Align.TOP_LEFT; const lu = { update: 0, everyTick: 1 }; const uu = {
    addChildMask: ao, enableChildrenMask(t) { const e = this.addChildMask(null, this, 0, t); return this.childrenMask = e.createGeometryMask(), this; }, maskChildren(t) { return void 0 === t && (t = this.getAllChildren()), hh(this, this.childrenMask, t), this; }, layoutChildrenMask() { if (void 0 === this.childrenMask) return this; const t = ah(this.childrenMask); return t.setPosition().resize(), this.resetChildPositionState(t), this; },
  }; const cu = {
    setChild(t, e, i) { t.setOrigin && t.setOrigin(0), this.add(t); let n; let s; let r; const o = this.getSizerConfig(t); return o.align = hu, o.expand = e, this.child = t, !0 === i ? (n = !0, r = s = 0) : !1 === i ? n = !1 : (n = au(i, 'mask', !0), s = au(i, 'padding', 0), r = au(o, 'updateMode', 0)), this.maskUpdateMode = r, n && (typeof r === 'string' && (r = lu[r]), r === 1 && this.scene.game.events.on('poststep', this.maskChildren, this), this.enableChildrenMask(s)), this; }, getChildrenWidth() { if (this.rexSizer.hidden) return 0; const t = this.child; return !t.rexSizer.hidden && this.scrollMode === 0 ? t.isRexSizer ? Math.max(t.minWidth, t.childrenWidth) : kn(t) : 0; }, getChildrenHeight() { if (this.rexSizer.hidden) return 0; const t = this.child; return t.rexSizer.hidden || this.scrollMode === 0 ? 0 : t.isRexSizer ? Math.max(t.minHeight, t.childrenHeight) : Cn(t); }, getChildrenSizers(t) { return void 0 === t && (t = []), this.child && this.child.isRexSizer && t.push(this.child), t; }, resetChildPosition() { let t = this.left; let e = this.top; this.scrollMode === 0 ? e += this.childOY : t += this.childOY, this.child.setPosition(t, e), this.resetChildPositionState(this.child), this.maskUpdateMode === 0 && this.maskChildren(); }, _layout(t, e, i) { if (this.rexSizer.hidden || !this.dirty) return this; this.preLayout(t), void 0 === e && (e = Math.max(this.childrenWidth, this.minWidth)), void 0 === i && (i = Math.max(this.childrenHeight, this.minHeight)), this.resize(e, i); let n; let s; const r = this.child; return r.rexSizer.hidden || (this.scrollMode === 0 ? n = this.width : s = this.height, r.isRexSizer ? r._layout(this, n, s) : ks(r, n, s), this.layoutChildrenMask(), this.resetChildPosition()), this.postLayout(); },
  }; Object.assign(cu, uu); const du = Phaser.Utils.Objects.IsPlainObject; const fu = Phaser.Utils.Objects.GetValue; const vu = (function () { i(c, $s); const u = S(c); function c(t, e, i, n, s, r) { let o; B(this, c), du(e) ? (e = fu(r = e, 'x', 0), i = fu(r, 'y', 0), n = fu(r, 'width', void 0), s = fu(r, 'height', void 0)) : du(n) && (n = fu(r = n, 'width', void 0), s = fu(r, 'height', void 0)), (o = u.call(this, t, e, i, n, s, r)).type = 'rexScrollableBlock', o.child = void 0, o.childrenMask = void 0, o._childOY = 0, o.execeedTopState = !1, o.execeedBottomState = !1, o.setScrollMode(fu(r, 'scrollMode', !0)), o.setClampMode(fu(r, 'clamplChildOY', !0)); const a = fu(r, 'child', void 0); const h = fu(r, 'expand', !0); const l = fu(r, 'mask', void 0); return o.setChild(a, h, l), o; } return w(c, [{ key: 'destroy', value(t) { this.scene && (this.maskUpdateMode === 1 && this.scene.game.events.off('poststep', this.maskChildren, this), this.child = void 0, this.childrenMask && (this.childrenMask.destroy(), this.childrenMask = void 0), g(p(c.prototype), 'destroy', this).call(this, t)); } }, { key: 'setScrollMode', value(t) { return typeof t === 'string' && (t = Aa[t.toLowerCase()]), this.scrollMode = t, this; } }, { key: 'setClampMode', value(t) { return void 0 === t && (t = !0), this.clampChildOY = t, this; } }, { key: 'childOYExceedTop', value(t) { return void 0 === t && (t = this.childOY), t > this.topChildOY; } }, { key: 'childOYExeceedBottom', value(t) { return void 0 === t && (t = this.childOY), t < this.bottomChildOY; } }, { key: 'setChildOY', value(t) { return this.childOY = t, this; } }, { key: 'setChildOYByPercentage', value(t) { return this.t = t, this; } }, { key: 'instHeight', get() { return this.scrollMode === 0 ? this.height : this.width; } }, { key: 'instWidth', get() { return this.scrollMode === 0 ? this.width : this.height; } }, { key: 'childHeight', get() { return (this.scrollMode === 0 ? Cn : kn)(this.child); } }, { key: 'childWidth', get() { return (this.scrollMode === 0 ? kn : Cn)(this.child); } }, { key: 'topChildOY', get() { return 0; } }, { key: 'bottomChildOY', get() { return -this.visibleHeight; } }, { key: 'visibleHeight', get() { const t = this.childHeight; const e = this.instHeight; return e < t ? t - e : 0; } }, { key: 'childOY', get() { return this._childOY; }, set(t) { const e = this.topChildOY; const i = this.bottomChildOY; const n = this.childOYExceedTop(t); const s = this.childOYExeceedBottom(t); this.clampChildOY && (this.instHeight > this.childHeight ? t = 0 : n ? t = e : s && (t = i)), this._childOY !== t && (this._childOY = t, this.resetChildPosition()), n && (this.execeedTopState || this.emit('execeedtop', this, t, e)), this.execeedTopState = n, s && (this.execeedBottomState || this.emit('execeedbottom', this, t, i)), this.execeedBottomState = s; } }, { key: 't', set(t) { this.childOY = -this.visibleHeight * t; }, get() { const t = this.visibleHeight; return t === 0 ? 0 : this.childOY / -t; } }]), c; }()); Object.assign(vu.prototype, cu), c.register('scrollableBlock', function (t) { const e = new vu(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.ScrollableBlock', vu); const pu = Phaser.Utils.Objects.GetValue; const gu = (function () { i(d, nh); const c = S(d); function d(t, e) { let i; B(this, d), void 0 === e && (e = {}); const n = Fa(e); let s = pu(e, 'panel', void 0); void 0 === s && (s = {}), s.scrollMode = n, s.clamplChildOY = pu(e, 'clamplChildOY', !1); const r = new vu(t, s); t.add.existing(r); let o; let a; const h = pu(s, 'width', void 0); const l = pu(s, 'height', void 0); a = n === 0 ? (o = void 0 === h ? 1 : 0, void 0 === l) : (o = void 0 === l ? 1 : 0, void 0 === h), e.type = 'rexScrollablePanel', e.child = { gameObject: r, proportion: o, expand: a }; const u = pu(e, 'space', void 0); return u && (u.child = u.panel), (i = c.call(this, t, e)).addChildrenMap('panel', i.childrenMap.child.child), i; } return d; }()); c.register('scrollablePanel', function (t) { const e = new gu(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.ScrollablePanel', gu); function yu(t) { return Kn(t) ? t.events : t.on ? t : void 0; } function mu(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = e.length), t.length = n - i; for (let s = 0, r = t.length; s < r; s++)t[s] = e[s + i]; return t; } function bu(t) { return typeof t !== 'string' || (t === '' ? t = null : Eu.test(t) ? t = parseFloat(t) : screen === 'false' ? t = !1 : t === 'true' && (t = !0)), t; } function xu(t, e, i) { let n; const s = zu(i, 'reverse', !1); if (yi(t[0])) if (s) for (r = (o = t.length) - 1; r >= 0; r--)n = xu(t[r], e, i); else for (var r = 0, o = t.length; r < o; r++)n = xu(t[r], e, i); else n = Bu(t, e, i); return n; } const ku = {
    popUp: 0, fadeIn: 1, scaleDown: 0, fadeOut: 1,
  }; const Cu = function (t, e) { t.popUp(e); }; const wu = function (t, e) { t.scaleDown(e); }; const Su = function (t, e) { t.fadeIn(e); }; const Ou = function (t, e) { t.fadeOut(e); }; const Tu = Phaser.Utils.Objects.GetValue; const Pu = (function () {
    i(s, Fh); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t, e)).parent = t, i.scene = Zn(t), i.resetFromJSON(e), i.boot(), i; } return w(s, [{ key: 'resetFromJSON', value(t) { return this.isRunning = Tu(t, 'isRunning', !1), this.timeScale = Tu(t, 'timeScale', 1), this.now = Tu(t, 'now', 0), this; } }, {
      key: 'toJSON',
      value() {
        return {
          isRunning: this.isRunning, timeScale: this.timeScale, now: this.now, tickingMode: this.tickingMode,
        };
      },
    }, { key: 'boot', value() { g(p(s.prototype), 'boot', this).call(this); const t = yu(this.parent); t && t.on('destroy', this.destroy, this); } }, { key: 'shutdown', value() { g(p(s.prototype), 'shutdown', this).call(this), this.parent = void 0, this.scene = void 0; } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'start', value(t) { return void 0 === t && (t = 0), this.now = t, g(p(s.prototype), 'start', this).call(this), this; } }, { key: 'seek', value(t) { return this.now = t, this; } }, { key: 'tick', value(t) { return t *= this.timeScale, this.now += t, this.emit('update', this.now, t), this; } }]), s;
  }()); const Mu = (function () { i(e, Pu); const t = S(e); function e() { return B(this, e), t.apply(this, arguments); } return w(e, [{ key: 'startTicking', value() { g(p(e.prototype), 'startTicking', this).call(this), this.scene.events.on('update', this.update, this); } }, { key: 'stopTicking', value() { g(p(e.prototype), 'stopTicking', this).call(this), this.scene && this.scene.events.off('update', this.update, this); } }, { key: 'update', value(t, e) { return this.isRunning && this.timeScale !== 0 && this.tick(e), this; } }]), e; }()); var Eu = /^\s*-?(\d*\.?\d+|\d+\.?\d*)(e[-+]?\d+)?\s*$/i; var zu = Phaser.Utils.Objects.GetValue; var Bu = function (t, e, i) { let n; let s = zu(i, 'argsConvert', void 0); let r = zu(i, 'argsConvertScope', void 0); const o = t[0]; if (_u = mu(_u, t, 1), s) { !0 === s && (s = bu, r = void 0); for (let a = 0, h = _u.length; a < h; a++)_u[a] = r ? s.call(r, _u[a], t) : s(_u[a], t); } return typeof o === 'string' ? (n = e[o]) == null && (n = zu(e, o, null)) : n = o, n.apply(e, _u); }; var _u = []; const ju = Phaser.Utils.Objects.GetValue; const Du = (function () {
    function n(t, e) { B(this, n), this.parent = t, this.scene = Zn(t), this.setEventEmitter(ju(e, 'eventEmitter', void 0)); const i = ju(e, 'clockClass', Mu); this.clock = new i(t, { eventEmitter: this.getEventEmitter() }), this.clock.on('update', this.update, this), this.resetFromJSON(e), this.boot(); } return w(n, [{ key: 'resetFromJSON', value(t) { return this.clock.resetFromJSON(ju(t, 'clock', void 0)), this.state = ju(t, 'state', 0), this.commands = ju(t, 'commands', []), this.scope = ju(t, 'scope', void 0), this.setTimeUnit(ju(t, 'timeUnit', 0)), this.setDtMode(ju(t, 'dtMode', 0)), this.index = ju(t, 'index', 0), this.nextTime = ju(t, 'nextTime', 0), this; } }, {
      key: 'toJSON',
      value() {
        return {
          clock: this.clock.toJSON(), state: this.state, commands: this.commands, scope: this.scope, timeUnit: this.timeUnit, dtMode: this.dtMode, index: this.index, nextTime: this.nextTime,
        };
      },
    }, { key: 'boot', value() { const t = yu(this.parent); t && t.on('destroy', this.destroy, this); } }, { key: 'shutdown', value() { this.clock.shutdown(), this.parent = void 0, this.scene = void 0, this.commands = void 0; } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'load', value(t, e, i) { this.stop(); const n = ju(i, 'timeUnit', void 0); void 0 !== n && this.setTimeUnit(n); const s = ju(i, 'dtMode', void 0); return void 0 !== s && this.setDtMode(s), t = t.filter((t) => { const e = t[0]; return !isNaN(e); }).map((t) => (typeof t[0] === 'string' && (t[0] = parseFloat(t[0])), t)), this.dtMode === 0 && t.sort((t, e) => { const i = t[0]; const n = e[0]; return n < i ? 1 : i < n ? -1 : 0; }), this.commands = t, this.scope = e, this; } }, { key: 'start', value(t) { return void 0 === t && (t = 0), this.stop(), this.index = 0, this.state = 1, this.nextTime = this.getNextDt(0), this.clock.start(t), this.update(t), this; } }, { key: 'pause', value() { return this.clock.pause(), this; } }, { key: 'resume', value() { return this.clock.resume(), this; } }, { key: 'stop', value() { return this.clock.stop(), this.state = 0, this; } }, { key: 'seek', value(t) { return this.clock.seek(t), this; } }, { key: 'setTimeScale', value(t) { return this.clock.timeScale = t, this; } }, { key: 'update', value(t) { if (this.nextTime > t) return this; for (let e = this.commands.length - 1; ;) { const i = this.commands[this.index]; let n = i[1]; if (yi(n) || (n = mu(Iu, i, 1)), xu(n, this.scope), this.emit('runcommand', n, this.scope), this.index === e) return this.complete(), this; if (this.index++, this.nextTime = this.getNextDt(this.nextTime), this.nextTime > t) return this; } } }, { key: 'complete', value() { this.clock.complete(), this.state = 2; } }, { key: 'getNextDt', value(t) { let e = this.commands[this.index][0]; return this.timeUnit === 1 && (e *= 1e3), this.dtMode === 1 && (e += t), e; } }, { key: 'setDtMode', value(t) { return typeof t === 'string' && (t = Ru[t]), this.dtMode = t, this; } }, { key: 'setTimeUnit', value(t) { return typeof t === 'string' && (t = Yu[t]), this.timeUnit = t, this; } }, { key: 'isPlaying', get() { return this.clock.isRunning; } }, { key: 'completed', get() { return this.state === 2; } }]), n;
  }()); Object.assign(Du.prototype, ls); var Iu = []; var Yu = { ms: 0, s: 1, sec: 1 }; var Ru = {
    abs: 0, absolute: 0, inc: 1, increment: 1,
  }; const Lu = Phaser.Utils.Objects.GetValue; const Fu = (function () { i(s, fo); const n = S(s); function s(t, e) { let i; return B(this, s), void 0 === e && (e = { text: createDefaultTextObject(t) }), (i = n.call(this, t, e)).type = 'rexToast', i.setTransitInTime(Lu(e, 'duration.in', 200)), i.setDisplayTime(Lu(e, 'duration.hold', 1200)), i.setTransitOutTime(Lu(e, 'duration.out', 200)), i.setTransitInCallback(Lu(e, 'transitIn', ku.popUp)), i.setTransitOutCallback(Lu(e, 'transitOut', ku.scaleDown)), i.player = new Du(_(i), { dtMode: 1 }), i.messages = [], i.setVisible(!1), i; } return w(s, [{ key: 'destroy', value(t) { this.scene && (this.player.destroy(), this.player = void 0, this.messages = void 0, g(p(s.prototype), 'destroy', this).call(this, t)); } }, { key: 'setDisplayTime', value(t) { return this.displayTime = t, this; } }, { key: 'setTransitOutTime', value(t) { return this.transitOutTime = t, this; } }, { key: 'setTransitInTime', value(t) { return this.transitInTime = t, this; } }, { key: 'setTransitInCallback', value(t) { switch (typeof t === 'string' && (t = ku[t]), t) { case ku.popUp: t = Cu; break; case ku.fadeIn: t = Su; } return this.transitInCallback = t, this; } }, { key: 'setTransitOutCallback', value(t) { switch (typeof t === 'string' && (t = ku[t]), t) { case ku.scaleDown: t = wu; break; case ku.fadeOut: t = Ou; } return this.transitOutCallback = t, this; } }, { key: 'show', value(t) { if (void 0 === t) { if (this.messages.length === 0) return this; t = this.messages.shift(); } if (this.player.isPlaying) return this.messages.push(t), this; this.setScale(1, 1).setVisible(!0), typeof t === 'string' ? this.setText(t) : t(this), this.layout(); const e = [[0, [this.transitInCallback, this, this.transitInTime]], [this.transitInTime, [vt]], [this.displayTime, [this.transitOutCallback, this, this.transitOutTime]], [this.transitOutTime, [this.setVisible, !1]], [30, [vt]]]; return this.player.load(e, this).once('complete', function () { this.show(); }, this).start(), this; } }]), s; }()); c.register('toast', function (t) { const e = new Fu(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Toast', Fu); function Au(s, r) { return function (t, e, i, n) { e !== 'panel' && i.moveChild(t, n ? 0 : s, r); }; } function Xu(s, r) { return function (t, e, i, n) { e === 'panel' && i.moveChild(t, n ? 0 : s, r); }; } const Hu = {
    visible: { show() { return function (t, e, i, n) { e !== 'panel' && i.setChildVisible(t, !0); }; }, hide() { return function (t, e, i, n) { e !== 'panel' && i.setChildVisible(t, !1); }; } }, fade: { show(s, r) { return void 0 === r && (r = 1), function (t, e, i, n) { e !== 'panel' && i.fadeChild(t, n ? 0 : s, r); }; }, hide(s, r) { return void 0 === r && (r = 0), function (t, e, i, n) { e !== 'panel' && i.fadeChild(t, n ? 0 : s, r); }; } }, move: { show: Au, hide: Au }, 'move-panel': { show: Xu, hide: Xu },
  }; const Uu = Ii.prototype.setChildVisible; const Vu = { setChildVisible(t, e) { if (typeof t === 'string') { var i = t; t = this.sizerChildren[i]; } else i = no(this.sizerChildren, t); return void 0 === e && (e = this.currentChildKey === i), Uu.call(this, t, e), this; } }; const Wu = { fadeChild(t, e, i) { let n; return typeof t === 'string' ? (n = t, t = this.sizerChildren[n]) : n = no(this.sizerChildren, t), void 0 === e && (e = 500), void 0 === i && (i = this.currentChildKey === n ? 1 : 0), t.fadeIn(e, { start: t.alpha, end: i }), this; }, fadeChildPromise(t, e, i) { return typeof t === 'string' && (t = this.sizerChildren[key]), this.fadeChild(t, e, i), t._fade ? ps(t._fade) : Promise.resolve(); } }; const Gu = { moveChild(t, e, i, n) { let s; typeof t === 'string' ? (s = t, t = this.sizerChildren[s]) : s = no(this.sizerChildren, t), void 0 === e && (e = 500); let r; let o; let a; let h; const l = this.currentChildKey === s; if (void 0 === n) switch (s) { case 'leftSide': case 'rightSide': n = kn(t); break; case 'topSide': case 'bottomSide': n = Cn(t); break; default: if (l) switch (this.previousChildKey) { case 'leftSide': case 'rightSide': n = kn(this.sizerChildren[this.previousChildKey]); break; case 'topSide': case 'bottomSide': n = Cn(this.sizerChildren[this.previousChildKey]); break; default: n = 0; } else switch (this.currentChildKey) { case 'leftSide': case 'rightSide': n = kn(this.sizerChildren[this.currentChildKey]); break; case 'topSide': case 'bottomSide': n = Cn(this.sizerChildren[this.currentChildKey]); break; default: n = 0; } } if (l) switch (s) { case 'panel': switch (this.previousChildKey) { case 'leftSide': r = !0; break; case 'rightSide': o = !0; break; case 'topSide': a = !0; break; case 'bottomSide': h = !0; } break; case 'leftSide': o = !0; break; case 'rightSide': r = !0; break; case 'topSide': h = !0; break; case 'bottomSide': a = !0; } else switch (s) { case 'panel': switch (this.currentChildKey) { case 'leftSide': o = !0; break; case 'rightSide': r = !0; break; case 'topSide': h = !0; break; case 'bottomSide': a = !0; } break; case 'leftSide': r = !0; break; case 'rightSide': o = !0; break; case 'topSide': a = !0; break; case 'bottomSide': h = !0; } return r ? t.moveTo(e, '-='.concat(n), void 0, i) : o ? t.moveTo(e, '+='.concat(n), void 0, i) : a ? t.moveTo(e, void 0, '-='.concat(n), i) : h ? t.moveTo(e, void 0, '+='.concat(n), i) : t.moveTo(0), this; }, moveChildPromise(t, e, i, n) { return typeof t === 'string' && (t = this.sizerChildren[key]), this.moveChild(t, e, i, n), t._easeMove ? ps(t._easeMove) : Promise.resolve(); } }; const Nu = {}; Object.assign(Nu, Vu, Wu, Gu); const Ju = Phaser.Utils.Objects.GetValue; const Ku = (function () { i(C, oo); const k = S(C); function C(t, e) { let i; B(this, C), (i = k.call(this, t, e)).type = 'rexSides', i.childrenMap = i.sizerChildren, i.previousChildKey = void 0, i.currentChildKey = void 0; let n; let s; let r; let o; let a; let h; const l = Ju(e, 'showChildCallback', void 0); if (l) if (ms(l)) { const u = Ju(e, 'showChildCallbackScope', void 0); i.on('showchild', l, u); const c = Ju(e, 'hideChildCallback', void 0); const d = Ju(e, 'hideChildCallbackScope', void 0); i.on('hidechild', c, d); } else { const f = (h = O(typeof (n = l) === 'string' ? [n] : n), s = h[0], r = h.slice(1), a = Hu.hasOwnProperty(s) ? (o = Hu[s].show.apply(null, r), Hu[s].hide.apply(null, r)) : o = vt, { show: o, hide: a }); i.on('showchild', f.show), i.on('hidechild', f.hide); } const v = Ju(e, 'background', void 0); const p = Ju(e, 'panel', void 0); const g = Ju(e, 'leftSide', void 0); const y = Ju(e, 'rightSide', void 0); const m = Ju(e, 'topSide', void 0); const b = Ju(e, 'bottomSide', void 0); if (v && i.addBackground(v), p && i.add(p, 'panel', 'center', 0, !0), g) { var x = Ju(e, 'expand.left', !0); i.add(g, 'leftSide', 'left-top', 0, { height: x }); } if (y) { x = Ju(e, 'expand.right', !0); i.add(y, 'rightSide', 'right-top', 0, { height: x }); } if (m) { x = Ju(e, 'expand.top', !0); i.add(m, 'topSide', 'left-top', 0, { width: x }); } if (b) { x = Ju(e, 'expand.bottom', !0); i.add(b, 'bottomSide', 'left-bottom', 0, { width: x }); } return i; } return w(C, [{ key: 'reset', value() { return this.previousChildKey = void 0, this.currentChildKey = 'panel', this.showChild('panel', !0), this.hideChild('leftSide', !0), this.hideChild('rightSide', !0), this.hideChild('topSide', !0), this.hideChild('bottomSide', !0), this; } }]), C; }()); Object.assign(Ku.prototype, {
    showChild(t, e) { const i = this.sizerChildren[t]; return i && (this.emit('showchild', i, t, this, e), this.resetChildState(i)), this; }, hideChild(t, e) { const i = this.sizerChildren[t]; return i && (this.emit('hidechild', i, t, this, e), this.resetChildState(i)), this; }, swapChild(t, e) { return this.currentChildKey === t || (this.currentChildKey === 'panel' || t === 'panel' ? (this.previousChildKey = this.currentChildKey, this.currentChildKey = t, this.hideChild(this.previousChildKey, e), this.showChild(this.currentChildKey, e)) : (this.swapChild('panel', e), this.swapChild(t, e))), this; }, showPanel(t) { return this.swapChild('panel', t), this; }, showLeftSide() { return this.swapChild('leftSide'), this; }, showRightSide() { return this.swapChild('rightSide'), this; }, showTopSide() { return this.swapChild('topSide'), this; }, showBottomSide() { return this.swapChild('bottomSide'), this; }, hideLeftSide() { return this.currentChildKey == 'leftSide' && this.showPanel(), this; }, hideRightSide() { return this.currentChildKey == 'rightSide' && this.showPanel(), this; }, hideTopSide() { return this.currentChildKey == 'topSide' && this.showPanel(), this; }, hideBottomSide() { return this.currentChildKey == 'bottomSide' && this.showPanel(), this; }, toggleLeftSide() { const t = this.currentChildKey !== 'panel' ? 'panel' : 'leftSide'; return this.swapChild(t), this; }, toggleRightSide() { const t = this.currentChildKey !== 'panel' ? 'panel' : 'rightSide'; return this.swapChild(t), this; }, toggleTopSide() { const t = this.currentChildKey !== 'panel' ? 'panel' : 'topSide'; return this.swapChild(t), this; }, toggleBottomSide() { const t = this.currentChildKey !== 'panel' ? 'panel' : 'bottomSide'; return this.swapChild(t), this; },
  }, Nu), c.register('sides', function (t) { const e = new Ku(this.scene, t); return this.scene.add.existing(e), e; }), ut(window, 'RexPlugins.UI.Sides', Ku), c.register('click', function (t, e) { return qn(t) || (e = t, t = this.scene), new go(t, e); }), ut(window, 'RexPlugins.UI.Click', go), c.register('tap', function (t, e) { return qn(t) || (e = t, t = this.scene), new Jh(t, e); }), ut(window, 'RexPlugins.UI.Tap', Jh), c.register('press', function (t, e) { return qn(t) || (e = t, t = this.scene), new tl(t, e); }), ut(window, 'RexPlugins.UI.Press', tl), c.register('swipe', function (t, e) { return qn(t) || (e = t, t = this.scene), new dl(t, e); }), ut(window, 'RexPlugins.UI.Swipe', dl); const Zu = Phaser.Utils.Objects.GetValue; const qu = (function () { i(o, Hh); const r = S(o); function o(t, e) { let i; B(this, o); const n = _(i = r.call(this, t, e)); const s = { states: { IDLE: {}, BEGIN: { enter() { const t = n.pointer; n.startX = t.x, n.startY = t.y, n.startWorldX = t.worldX, n.startWorldY = t.worldY; } }, RECOGNIZED: { enter() { n.emit('panstart', n, n.gameObject, n.lastPointer); }, exit() { const t = n.lastPointer; n.endX = t.x, n.endY = t.y, n.endWorldX = t.worldX, n.endWorldY = t.worldY, n.emit('panend', n, n.gameObject, n.lastPointer); } } }, init() { this.state = $u; }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Ua(s)), i; } return w(o, [{ key: 'resetFromJSON', value(t) { return g(p(o.prototype), 'resetFromJSON', this).call(this, t), this.setDragThreshold(Zu(t, 'threshold', 10)), this; } }, { key: 'onDragStart', value() { this.state = Qu, this.dragThreshold === 0 && (this.state = tc); } }, { key: 'onDragEnd', value() { this.state = $u; } }, { key: 'onDrag', value() { switch (this.state) { case Qu: this.pointer.getDistance() >= this.dragThreshold && (this.state = tc); break; case tc: var t = this.pointer.position; var e = this.pointer.prevPosition; this.dx = t.x - e.x, this.dy = t.y - e.y; var i = this.pointer; this.x = i.x, this.y = i.y, this.worldX = i.worldX, this.worldY = i.worldY, this.emit('pan', this, this.gameObject, this.lastPointer); } } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'isPan', get() { return this.state === tc; } }]), o; }()); var $u = 'IDLE'; var Qu = 'BEGIN'; var tc = 'RECOGNIZED'; c.register('pan', function (t, e) { return qn(t) || (e = t, t = this.scene), new qu(t, e); }), ut(window, 'RexPlugins.UI.Pan', qu); const ec = Phaser.Utils.Objects.GetValue; const ic = Phaser.Utils.Array.SpliceOne; const nc = Phaser.Math.Distance.Between; const sc = Phaser.Math.Angle.Between; const rc = (function () { function n(t, e) { B(this, n); const i = t.input.manager.pointersTotal - 1; i < 2 && t.input.addPointer(2 - i), this.scene = t, this.setEventEmitter(ec(e, 'eventEmitter', void 0)), this._enable = void 0, this.pointers = [], this.movedState = {}, this.resetFromJSON(e), this.boot(); } return w(n, [{ key: 'resetFromJSON', value(t) { return this.setEnable(ec(t, 'enable', !0)), this.bounds = ec(t, 'bounds', void 0), this.tracerState = ac, this.pointers.length = 0, dt(this.movedState), this; } }, { key: 'boot', value() { this.scene.input.on('pointerdown', this.onPointerDown, this), this.scene.input.on('pointerup', this.onPointerUp, this), this.scene.input.on('pointermove', this.onPointerMove, this), this.scene.events.once('shutdown', this.destroy, this); } }, { key: 'shutdown', value() { this.destroyEventEmitter(), this.pointers.length = 0, dt(this.movedState), this.scene && (this.scene.input.off('pointerdown', this.onPointerDown, this), this.scene.input.off('pointerup', this.onPointerUp, this), this.scene.input.off('pointermove', this.onPointerMove, this), this.scene.events.off('destroy', this.destroy, this), this.scene = void 0), this.scene = void 0; } }, { key: 'destroy', value() { this.shutdown(); } }, { key: 'setEnable', value(t) { return void 0 === t && (t = !0), this.enable = t, this; } }, { key: 'toggleEnable', value() { return this.setEnable(!this.enable), this; } }, { key: 'onPointerDown', value(t) { if (this.enable && (this.pointers.length !== 2 && (!this.bounds || this.bounds.contains(t.x, t.y)) && this.pointers.indexOf(t) === -1)) switch (this.movedState[t.id] = !1, this.pointers.push(t), this.tracerState) { case ac: this.tracerState = hc, this.onDrag1Start(); break; case hc: this.tracerState = lc, this.onDrag2Start(); } } }, { key: 'onPointerUp', value(t) { if (this.enable && (!this.bounds || this.bounds.contains(t.x, t.y))) { const e = this.pointers.indexOf(t); if (e !== -1) switch (delete this.movedState[t.id], ic(this.pointers, e), this.tracerState) { case hc: this.tracerState = ac, this.onDrag1End(); break; case lc: this.tracerState = hc, this.onDrag2End(), this.onDrag1Start(); } } } }, { key: 'onPointerMove', value(t) { if (this.enable && t.isDown) { const e = !this.bounds || this.bounds.contains(t.x, t.y); const i = this.pointers.indexOf(t) !== -1; if (i || !e) if (i && !e) this.onPointerUp(t); else if (this.movedState[t.id] || (this.movedState[t.id] = t.x !== t.downX || t.y !== t.downY), this.movedState[t.id]) switch (this.tracerState) { case hc: this.onDrag1(); break; case lc: this.onDrag2(); } } } }, { key: 'dragCancel', value() { return this.tracerState === lc && this.onDrag2End(), this.pointers.length = 0, dt(this.movedState), this.tracerState = ac, this; } }, { key: 'onDrag1Start', value() { this.emit('drag1start', this); } }, { key: 'onDrag1End', value() { this.emit('drag1end', this); } }, { key: 'onDrag1', value() { this.emit('drag1', this); } }, { key: 'onDrag2Start', value() { this.emit('drag2start', this); } }, { key: 'onDrag2End', value() { this.emit('drag2end', this); } }, { key: 'onDrag2', value() { this.emit('drag2', this); } }, { key: 'setRecongizedStateObject', value(t) { return this.recongizedState = t, this; } }, { key: 'cancel', value() { return this.state = uc, this; } }, { key: 'enable', get() { return this._enable; }, set(t) { if (this._enable !== t) return t || this.dragCancel(), this._enable = t, this; } }, { key: 'distanceBetween', get() { if (this.tracerState !== lc) return 0; const t = this.pointers[0]; const e = this.pointers[1]; return nc(t.x, t.y, e.x, e.y); } }, { key: 'angleBetween', get() { if (this.tracerState !== lc) return 0; const t = this.pointers[0]; const e = this.pointers[1]; return sc(t.x, t.y, e.x, e.y); } }, { key: 'drag1Vector', get() { const t = this.pointers[0]; if (t && this.movedState[t.id]) { const e = t.position; const i = t.prevPosition; oc.x = e.x - i.x, oc.y = e.y - i.y; } else oc.x = 0, oc.y = 0; return oc; } }, { key: 'centerX', get() { if (this.tracerState !== lc) return 0; const t = this.pointers[0].position; const e = this.pointers[1].position; return (t.x + e.x) / 2; } }, { key: 'centerY', get() { if (this.tracerState !== lc) return 0; const t = this.pointers[0].position; const e = this.pointers[1].position; return (t.y + e.y) / 2; } }, { key: 'prevCenterX', get() { if (this.tracerState !== lc) return 0; const t = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position; const e = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position; return (t.x + e.x) / 2; } }, { key: 'prevCenterY', get() { if (this.tracerState !== lc) return 0; const t = this.movedState[this.pointers[0].id] ? this.pointers[0].prevPosition : this.pointers[0].position; const e = this.movedState[this.pointers[1].id] ? this.pointers[1].prevPosition : this.pointers[1].position; return (t.y + e.y) / 2; } }, { key: 'movementCenterX', get() { return this.centerX - this.prevCenterX; } }, { key: 'movementCenterY', get() { return this.centerY - this.prevCenterY; } }, { key: 'state', get() { return this.recongizedState.state; }, set(t) { this.recongizedState.state = t; } }]), n; }()); Object.assign(rc.prototype, ls); var oc = {}; var ac = 0; var hc = 1; var lc = 2; var uc = 'IDLE'; const cc = Phaser.Utils.Objects.GetValue; const dc = (function () { i(o, rc); const r = S(o); function o(t, e) { let i; B(this, o); const n = _(i = r.call(this, t, e)); const s = { states: { IDLE: { enter() { n.prevDistance = void 0, n.scaleFactor = 1; } }, BEGIN: {}, RECOGNIZED: { enter() { n.emit('pinchstart', n); }, exit() { n.emit('pinchend', n); } } }, init() { this.state = fc; }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Ua(s)), i; } return w(o, [{ key: 'resetFromJSON', value(t) { return g(p(o.prototype), 'resetFromJSON', this).call(this, t), this.setDragThreshold(cc(t, 'threshold', 0)), this; } }, { key: 'onDrag2Start', value() { this.scaleFactor = 1, this.prevDistance = this.distanceBetween, this.state = vc, this.dragThreshold === 0 && (this.state = pc); } }, { key: 'onDrag2End', value() { this.state = fc; } }, { key: 'onDrag2', value() { switch (this.state) { case vc: if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) { var t = this.distanceBetween; this.scaleFactor = t / this.prevDistance, this.prevDistance = t, this.state = pc; } break; case pc: t = this.distanceBetween; this.scaleFactor = t / this.prevDistance, this.emit('pinch', this), this.prevDistance = t; } } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'isPinch', get() { return this.state === pc; } }]), o; }()); var fc = 'IDLE'; var vc = 'BEGIN'; var pc = 'RECOGNIZED'; c.register('pinch', function (t) { return new dc(this.scene, t); }), ut(window, 'RexPlugins.UI.Pinch', dc); function gc(t, e, i, n) { return yc(t, e, i, n), t.rotation += n, t; } var yc = Phaser.Math.RotateAround; const mc = {}; const bc = Phaser.Utils.Objects.GetValue; const xc = Phaser.Math.Angle.WrapDegrees; const kc = Phaser.Math.Angle.ShortestBetween; const Cc = Phaser.Math.RadToDeg; const wc = Phaser.Math.DegToRad; const Sc = (function () { i(o, rc); const r = S(o); function o(t, e) { let i; B(this, o); const n = _(i = r.call(this, t, e)); const s = { states: { IDLE: { enter() { n.prevAngle = void 0, n.angle = 0; } }, BEGIN: {}, RECOGNIZED: { enter() { n.emit('rotatestart', n); }, exit() { n.emit('rotateend', n); } } }, init() { this.state = Tc; }, eventEmitter: !1 }; return i.setRecongizedStateObject(new Ua(s)), i; } return w(o, [{ key: 'resetFromJSON', value(t) { return g(p(o.prototype), 'resetFromJSON', this).call(this, t), this.setDragThreshold(bc(t, 'threshold', 0)), this; } }, { key: 'onDrag2Start', value() { this.prevAngle = xc(Cc(this.angleBetween)), this.state = Pc, this.rotationThreshold === 0 && (this.state = Mc); } }, { key: 'onDrag2End', value() { this.state = Tc; } }, { key: 'onDrag2', value() { switch (this.state) { case Pc: if (this.pointers[0].getDistance() >= this.dragThreshold && this.pointers[1].getDistance() >= this.dragThreshold) { var t = xc(Cc(this.angleBetween)); this.angle = kc(this.prevAngle, t), this.prevAngle = t, this.state = Mc; } break; case Mc: t = xc(Cc(this.angleBetween)); this.angle = kc(this.prevAngle, t), this.prevAngle = t, this.emit('rotate', this); } } }, { key: 'setDragThreshold', value(t) { return this.dragThreshold = t, this; } }, { key: 'isRotation', get() { return this.state === Mc; } }, { key: 'rotation', get() { return wc(this.angle); } }]), o; }()); const Oc = { spinObject(t, e) { if (!this.isRotation) return this; void 0 === e && (e = this.pointers[0].camera); const i = this.movementCenterX; const n = this.movementCenterY; e.getWorldPoint(this.centerX, this.centerY, mc); const s = mc.x; const r = mc.y; const o = this.rotation; if (Array.isArray(t)) for (let a = t, h = 0, l = a.length; h < l; h++)(t = a[h]).x += i, t.y += n, gc(t, s, r, o); else t.x += i, t.y += n, gc(t, x, y, o); return this; } }; Object.assign(Sc.prototype, Oc); var Tc = 'IDLE'; var Pc = 'BEGIN'; var Mc = 'RECOGNIZED'; c.register('rotate', function (t) { return new Sc(this.scene, t); }), ut(window, 'RexPlugins.UI.Rotate', Sc); function Ec(e, i, t) { let n; if (void 0 === e)e = t.texture.key, i = t.frame.name; else if (zc(e)) { const s = e; e = Bc(s, 'key', t.texture.key), i = Bc(s, 'frame', t.frame.name); } else typeof e === 'string' || (n = e); return void 0 === n && (n = function (t) { t.setTexture(e, i); }), n; } var zc = Phaser.Utils.Objects.IsPlainObject; var Bc = Phaser.Utils.Objects.GetValue; const _c = Phaser.Utils.Objects.GetValue; const jc = Phaser.Utils.Objects.GetAdvancedValue; const Dc = (function () {
    i(s, fs); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t, { eventEmitter: !0 })).gameObject = t, i.resetFromJSON(e), i; } return w(s, [{ key: 'resetFromJSON', value(t) { return this.setOrientation(_c(t, 'orientation', 0)), this.setDelay(jc(t, 'delay', 0)), this.setDuration(jc(t, 'duration', 500)), this.setEase(_c(t, 'ease', 'Sine')), this.setFrontFace(_c(t, 'front', void 0)), this.setBackFace(_c(t, 'back', void 0)), this.setFace(_c(t, 'face', 0)), this; } }, { key: 'shutdown', value() { return g(p(s.prototype), 'shutdown', this).call(this), this.gameObject = void 0, this; } }, { key: 'setOrientation', value(t) { return typeof t === 'string' && (t = Ic[t]), this.orientation = t, this; } }, { key: 'setDelay', value(t) { return this.delay = t, this; } }, { key: 'setDuration', value(t) { return this.duration = t, this; } }, { key: 'setEase', value(t) { return void 0 === t && (t = 'Linear'), this.ease = t, this; } }, { key: 'setFace', value(t) { return this.face = t, this; } }, { key: 'toggleFace', value() { const t = this.face === 0 ? 1 : 0; return this.setFace(t), this; } }, { key: 'setFrontFace', value(t, e) { return this.frontFaceCallback = Ec(t, e, this.gameObject), this; } }, { key: 'setBackFace', value(t, e) { return this.backFaceCallback = Ec(t, e, this.gameObject), this; } }, {
      key: 'start',
      value() {
        if (this.isRunning) return this; const t = {
          targets: this.gameObject, delay: this.delay, duration: this.duration / 2, ease: this.ease, yoyo: !0, repeat: 0, onYoyo: this.toggleFace, onYoyoScope: this,
        }; return t[this.orientation === 0 ? 'scaleX' : 'scaleY'] = { start: 1, to: 0 }, g(p(s.prototype), 'start', this).call(this, t), this;
      },
    }, { key: 'flip', value(t) { return this.isRunning || (void 0 !== t && this.setDuration(t), this.start()), this; } }, { key: 'face', get() { return this._face; }, set(t) { typeof t === 'string' && (t = Yc[t]), (this._face = t) === 0 && this.frontFaceCallback ? this.frontFaceCallback(this.gameObject) : t === 1 && this.backFaceCallback && this.backFaceCallback(this.gameObject); } }]), s;
  }()); var Ic = {
    x: 0, horizontal: 0, y: 1, vertical: 1,
  }; var Yc = { front: 0, back: 1 }; c.register('flip', (t, e) => new Dc(t, e)), ut(window, 'RexPlugins.UI.Flip', Dc); function Rc(t, e, i) { let n; let s; for (const r in void 0 === i && (i = {}), t)n = t[r], void 0 !== (s = Xc(e, r, n[1])) && (i[n[0]] = s); return i; } function Lc(i, t, n) { function e(e) { t[n[e]] = function (t) { i.emit(e, i, t); }; } for (const s in n)e(s); } const Fc = fi; const Ac = vi; var Xc = Phaser.Utils.Objects.GetValue; const Hc = function (t) { t.stopPropagation(); }; const Uc = Phaser.GameObjects.DOMElement; const Vc = Phaser.Utils.Objects.IsPlainObject; const Wc = Phaser.Utils.Objects.GetValue; const Gc = (function () { i(v, Uc); const f = S(v); function v(t, e, i, n, s, r) { let o; let a; B(this, v), Vc(e) ? (e = Wc(r = e, 'x', 0), i = Wc(r, 'y', 0), n = Wc(r, 'width', 0), s = Wc(r, 'height', 0)) : Vc(n) && (n = Wc(r = n, 'width', 0), s = Wc(r, 'height', 0)), void 0 === r && (r = {}); const h = Wc(r, 'type', 'text'); h === 'textarea' ? (a = document.createElement('textarea')).style.resize = 'none' : (a = document.createElement('input')).type = h, Rc(Zc, r, a); let l = Wc(r, 'style', void 0); l = Rc(qc, r, l); let u; const c = a.style; for (const d in r)d in Zc || d in qc || d in c && (l[d] = r[d]); return l['box-sizing'] = 'border-box', (o = f.call(this, t, e, i, a, l)).type = 'rexInputText', o.resize(n, s), Lc(_(o), a, $c), (u = a).addEventListener('touchstart', Hc, !1), u.addEventListener('touchmove', Hc, !1), u.addEventListener('touchend', Hc, !1), u.addEventListener('mousedown', Hc, !1), u.addEventListener('mouseup', Hc, !1), u.addEventListener('mousemove', Hc, !1), o; } return w(v, [{ key: 'setText', value(t) { return this.text = t, this; } }, { key: 'selectText', value() { return this.node.select(), this; } }, { key: 'setPlaceholder', value(t) { return this.placeholder = t, this; } }, { key: 'setTooltip', value(t) { return this.tooltip = t, this; } }, { key: 'setTextChangedCallback', value(t) { return this.onTextChanged = t, this; } }, { key: 'setReadOnly', value(t) { return void 0 === t && (t = !0), this.readOnly = t, this; } }, { key: 'setSpellCheck', value(t) { return this.spellCheck = t, this; } }, { key: 'setStyle', value(t, e) { return this.node.style[t] = e, this; } }, { key: 'getStyle', value(t) { return this.node.style[t]; } }, { key: 'scrollToBottom', value() { return this.node.scrollTop = this.node.scrollHeight, this; } }, { key: 'setEnabled', value(t) { return void 0 === t && (t = !0), this.node.disabled = !t, this; } }, { key: 'setBlur', value() { return this.node.blur(), this; } }, { key: 'setFocus', value() { return this.node.focus(), this; } }, { key: 'text', get() { return this.node.value; }, set(t) { this.node.value = t; } }, { key: 'placeholder', get() { return this.node.placeholder; }, set(t) { this.node.placeholder = t; } }, { key: 'tooltip', get() { return this.node.title; }, set(t) { this.node.title = t; } }, { key: 'readOnly', get() { return this.node.readOnly; }, set(t) { this.node.readOnly = t; } }, { key: 'spellCheck', get() { return this.node.spellcheck; }, set(t) { this.node.spellcheck = t; } }]), v; }()); const Nc = { resize(t, e) { if (this.scene.scale.autoRound && (t = Math.floor(t), e = Math.floor(e)), this.width === t && this.height === e) return this; const i = this.node.style; return i.width = ''.concat(t, 'px'), i.height = ''.concat(e, 'px'), this.updateSize(), this; } }; Object.assign(Gc.prototype, Nc); function Jc(t, e, i) { for (var n, s = 0, r = t.length; s < r; s++) if (n = t[s], bs(n, e, i)) return n.pointToChild(e, i); return null; } function Kc(t, e, i, n, s, r) { let o; (o = void 0 === s ? n : Jc(i, n, s)) && t.emit(e, o, r); } var Zc = {
    id: ['id', void 0], text: ['value', void 0], placeholder: ['placeholder', void 0], tooltip: ['title', void 0], readOnly: ['readonly', !1], spellCheck: ['spellcheck', !1], autoComplete: ['autocomplete', 'off'],
  }; var qc = {
    align: ['textAlign', void 0], paddingLeft: ['padding-left', void 0], paddingRight: ['padding-right', void 0], paddingTop: ['padding-top', void 0], paddingBottom: ['padding-bottom', void 0], fontFamily: ['fontFamily', void 0], fontSize: ['font-size', void 0], color: ['color', '#ffffff'], backgroundColor: ['backgroundColor', 'transparent'], border: ['border', 0], borderColor: ['borderColor', 'transparent'], outline: ['outline', 'none'],
  }; var $c = {
    textchange: 'oninput', click: 'onclick', dblclick: 'ondblclick', focus: 'onfocus', blur: 'onblur',
  }; const Qc = Phaser.Utils.Objects.GetValue; const td = function (t) { return t.hasOwnProperty('align') ? t.align : t.hasOwnProperty('halign') ? t.halign : 'left'; }; const ed = Phaser.Utils.Objects.GetValue; const id = (function () { function e(t) { B(this, e), this.gameObject = t, this.scene = Zn(t), this.inputText = void 0, this.onClose = void 0, this.delayCall = void 0, this.boot(); } return w(e, [{ key: 'boot', value() { return this.gameObject.on('destroy', this.destroy, this), this; } }, { key: 'shutdown', value() { return this.close(), this.gameObject = void 0, this.scene = void 0, nd === this && (nd = void 0), this; } }, { key: 'destroy', value() { return this.shutdown(), this; } }, { key: 'open', value(t, e) { void 0 !== nd && nd.close(), nd = this, ms(t) && (e = t, t = void 0), void 0 === e && (e = ed(t, 'onClose', void 0)); const i = ed(t, 'onTextChanged', void 0); return this.inputText = (function (t, e) { void 0 === e && (e = {}); const i = t.scene; const n = t.style; let s = Qc(e, 'backgroundColor', n.backgroundColor); s === null && (s = 'transparent'), e.text = Qc(e, 'text', t.text), e.fontFamily = Qc(e, 'fontFamily', n.fontFamily), e.fontSize = Qc(e, 'fontSize', n.fontSize), e.color = Qc(e, 'color', n.color), e.backgroundColor = s, e.align = Qc(e, 'align', td(n)); const r = new Gc(i, t.x, t.y, Qc(e, 'width', t.width), Qc(e, 'height', t.height), e); return r.setOrigin(t.originX, t.originY), i.add.existing(r), r; }(this.gameObject, t)).on('textchange', function (t) { const e = t.text; i ? i(this.gameObject, e) : this.gameObject.text = e; }, this).setFocus(), this.gameObject.setVisible(!1), this.onClose = e, this.scene.input.keyboard.once('keydown-ENTER', this.close, this), this.delayCall = this.scene.time.delayedCall(0, function () { this.scene.input.once('pointerdown', this.close, this); }, [], this), this; } }, { key: 'close', value() { return nd = void 0, this.inputText && (this.gameObject.setVisible(!0), this.inputText.destroy(), this.inputText = void 0, this.delayCall && (this.delayCall.remove(), this.delayCall = void 0), this.scene.input.keyboard.off('keydown-ENTER', this.close, this), this.scene.input.off('pointerdown', this.close, this), this.onClose && this.onClose(this.gameObject)), this; } }, { key: 'isOpened', get() { return void 0 !== this.inputText; } }, { key: 'text', get() { return this.isOpened ? this.inputText.text : this.gameObject.text; } }]), e; }()); var nd = void 0; const sd = Phaser.Utils.Objects.GetValue; const rd = Phaser.Utils.Objects.GetValue; const od = function (t) { const e = Jc(this.input.targetSizers, t.x, t.y); const i = this.input.lastOverChild; e && i && e === i || (this.input.lastOverChild = e, Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'out'), this.input.targetSizers, i, void 0, t), Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'over'), this.input.targetSizers, e, void 0, t)); }; const ad = function (t) { const e = this.input.lastOverChild; this.input.lastOverChild = null, Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'out'), this.input.targetSizers, e, void 0, t); }; const hd = Phaser.Utils.Objects.GetValue; const ld = Phaser.Utils.Objects.GetValue; const ud = Phaser.Utils.Objects.GetValue; const cd = Phaser.Utils.Objects.GetValue; const dd = (function () { i(s, Phaser.Plugins.ScenePlugin); const n = S(s); function s(t, e) { let i; return B(this, s), (i = n.call(this, t, e)).add = new c(t), i; } return w(s, [{ key: 'viewport', get() { return Jn(this.scene, !0); } }]), s; }()); const fd = {
    getParentSizer: Fc, getTopmostSizer: Ac, hide: ko, show: xo, isShown: Co, edit(t, e, i) { return t._edit || (t._edit = new id(t)), t._edit.open(e, i), t._edit; }, isInTouching: ys, waitEvent: vs, waitComplete: ps, setChildrenInteractive(t, e) { return t.setInteractive(), t.eventEmitter = cd(e, 'eventEmitter', t), t.input.targetSizers = cd(e, 'targets', [t]), t.input.eventNamePrefix = cd(e, 'inputEventPrefix', 'child.'), function (t) { let e = sd(t, 'click', void 0); !1 !== e && (void 0 === e && (e = {}), e.hasOwnProperty('threshold') || (e.threshold = 10), this._click = new go(this, e), this._click.on('click', function (t, e, i) { Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'click'), this.input.targetSizers, i.x, i.y, i); }, this)); }.call(t, e), function (t) { !1 !== rd(t, 'over', void 0) && this.on('pointermove', od, this).on('pointerover', od, this).on('pointerout', ad, this); }.call(t, e), function (t) { const e = hd(t, 'tap', void 0); !1 !== e && (this._tap = new Jh(this, e), this._tap.on('tap', function (t, e, i) { Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix).concat(t.tapsCount, 'tap'), this.input.targetSizers, t.x, t.y, i); }, this)); }.call(t, e), function (t) { const e = ld(t, 'press', void 0); !1 !== e && (this._press = new tl(this, e), this._press.on('pressstart', function (t, e, i) { Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'pressstart'), this.input.targetSizers, t.x, t.y, i); }, this).on('pressend', function (t, e, i) { Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'pressend'), this.input.targetSizers, t.x, t.y, i); }, this)); }.call(t, e), function (t) { let e = ud(t, 'swipe', void 0); !1 !== e && (void 0 === e && (e = {}), e.dir = '4dir', this._swipe = new dl(this, e), this._swipe.on('swipe', function (t, e, i) { const n = t.left ? 'left' : t.right ? 'right' : t.up ? 'up' : 'down'; Kc(this.eventEmitter, ''.concat(this.input.eventNamePrefix, 'swipe').concat(n), this.input.targetSizers, t.x, t.y, i); }, this)); }.call(t, e), t; },
  }; return Object.assign(dd.prototype, fd), dd;
}));
